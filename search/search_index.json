{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Programaci\u00f3n","text":"<p>Estos apuntes desarrollan los materiales did\u00e1cticos del m\u00f3dulo de Programaci\u00f3n (PRO). Las ense\u00f1anzas m\u00ednimas se definen en el RD 686/2010, el cual fue modificado por el RD 405/2023, y se concreta el curr\u00edculo en la Orden 50/2012 de 25 de septiembre.</p> <p>Info</p> <p>Cabe destacar las siguientes caracter\u00edsticas del m\u00f3dulo de Programaci\u00f3n:</p> <ul> <li>En la modalidad presencial la duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de 8 horas semanales.</li> <li>Se ha planificado bas\u00e1ndose en el horario de 1\u00ba de DAW del IES La Encant\u00e1 en Rojales, Alicante, durante el curso 2024/2025.</li> </ul>"},{"location":"index.html#objetivos-generales-de-ciclo-formativo","title":"Objetivos generales de ciclo formativo","text":"<p>El m\u00f3dulo de Programaci\u00f3n contribuye a los siguientes Objetivos Generales del Ciclo:</p> <ul> <li>e. Interpretar el dise\u00f1o l\u00f3gico, verificando los par\u00e1metros establecidos para gestionar bases de datos.</li> <li>j. Emplear herramientas y lenguajes espec\u00edficos, siguiendo las especificaciones, para desarrollar componentes multimedia.</li> <li>q. Programar y realizar actividades para gestionar el mantenimiento de los recursos inform\u00e1ticos.</li> <li>w. Evaluar situaciones de prevenci\u00f3n de riesgos laborales y de protecci\u00f3n ambiental, proponiendo y aplicando medidas de prevenci\u00f3n personales y colectivas, de acuerdo a la normativa aplicable en los procesos del trabajo, para garantizar entornos seguros.</li> </ul>"},{"location":"index.html#competencias-del-titulo","title":"Competencias del t\u00edtulo","text":"<p>El m\u00f3dulo de Programaci\u00f3n contribuye a las siguientes Competencias profesionales, personales y sociales:</p> <ul> <li>e. Desarrollar aplicaciones web con acceso a bases de datos utilizando lenguajes, objetos de acceso y herramientas de mapeo adecuados a las especificaciones.</li> <li>j. Desarrollar e integrar componentes software en el entorno del servidor web, empleando herramientas y lenguajes espec\u00edficos, para cumplir las especificaciones de la aplicaci\u00f3n.</li> <li>t. Generar entornos seguros en el desarrollo de su trabajo y el de su equipo, supervisando y aplicando los procedimientos de prevenci\u00f3n de riesgos laborales y ambientales de acuerdo con lo establecido por la normativa y los objetivos de la empresa.</li> <li>w. Ejercer sus derechos y cumplir con las obligaciones derivadas de su actividad profesional, de acuerdo con lo establecido en la legislaci\u00f3n vigente, participando activamente en la vida econ\u00f3mica, social y cultural.</li> </ul>"},{"location":"index.html#mapa-general-de-la-programacion-didactica","title":"Mapa General de la Programaci\u00f3n Did\u00e1ctica","text":"<p>A modo de resumen de la Programaci\u00f3n did\u00e1ctica (PD) de PRO, se muestra la secuenciaci\u00f3n de las Unidades de trabajo planificadas y los Resultados de aprendizaje (RRAA) tratados en cada una de dichas unidades.</p> <p>UUTT</p> <p>RA1</p> <p>RA2</p> <p>RA3</p> <p>RA4</p> <p>RA5</p> <p>RA6</p> <p>RA7</p> <p>RA8</p> <p>RA9</p> <p>Relevancia temporal</p> <p>Relevancia porcentual</p> <p>Primera Evaluaci\u00f3n</p> <p>01. Identificaci\u00f3n de los elementos de un programa inform\u00e1tico</p> <p>8</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>8</p> <p>3,5%</p> <p>02. Elementos b\u00e1sicos de un lenguaje de programaci\u00f3n</p> <p>8</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>8</p> <p>3,5%</p> <p>03. Estructuras de control</p> <p></p> <p></p> <p>24</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>24</p> <p>10,3%</p> <p>04. Programaci\u00f3n modular.</p> <p></p> <p>16</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>16</p> <p>6,9%</p> <p>05. Estructuras b\u00e1sicas de almacenamiento. Arrays.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>16</p> <p></p> <p></p> <p></p> <p>16</p> <p>6,9%</p> <p>06. Introducci\u00f3n a la programaci\u00f3n orientada a objetos</p> <p></p> <p>16</p> <p></p> <p>16</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>32</p> <p>13,8%</p> <p>Segunda Evaluaci\u00f3n</p> <p>07. Programaci\u00f3n orientada a objetos avanzada. Herencia, polimorfismo, interfaces.</p> <p></p> <p></p> <p></p> <p>8</p> <p></p> <p></p> <p>24</p> <p></p> <p></p> <p>32</p> <p>13,8%</p> <p>08. Control de excepciones. Funciones Lambda. Expresiones regulares.</p> <p></p> <p></p> <p>16</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>16</p> <p>6,9%</p> <p>09. Colecciones.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>16</p> <p></p> <p></p> <p></p> <p>16</p> <p>6,9%</p> <p>10. Tratamiento de colecciones mediante programaci\u00f3n funcional.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>16</p> <p></p> <p></p> <p></p> <p>16</p> <p>6,9%</p> <p>11. Conexi\u00f3n a BBDD relacionales.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>12</p> <p>12</p> <p>24</p> <p>10,3%</p> <p>Tercera Evaluaci\u00f3n</p> <p>12. Creaci\u00f3n de aplicaciones gr\u00e1ficas.</p> <p></p> <p></p> <p></p> <p></p> <p>24</p> <p></p> <p></p> <p></p> <p></p> <p>24</p> <p>10,3%</p> <p>FCT</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Resultados de aprendizaje</p> <p>RA1. Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado.</p> <p>16</p> <p>7%</p> <p>RA2. Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos.</p> <p>32</p> <p>14%</p> <p>RA3. Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje.</p> <p>40</p> <p>17%</p> <p>RA4. Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos.</p> <p>24</p> <p>10%</p> <p>RA5. Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases.</p> <p>24</p> <p>10%</p> <p>RA6. Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos.</p> <p>48</p> <p>21%</p> <p>RA7. Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n.</p> <p>24</p> <p>10%</p> <p>RA8. Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n.</p> <p>12</p> <p>5,5%</p> <p>RA9. Gestiona informaci\u00f3n almacenada en bases de datos manteniendo la integridad y consistencia de los datos.</p> <p>12</p> <p>5,5%</p>"},{"location":"index.html#evaluacion","title":"Evaluaci\u00f3n","text":"<p>Para la evaluaci\u00f3n del m\u00f3dulo de Programaci\u00f3n se ponderar\u00e1n los resultados de aprendizaje respecto a los porcentajes indicados en el apartado anterior.</p> <p>Para la evaluaci\u00f3n de cada RA, emplearemos diferentes Instrumentos de Evaluaci\u00f3n (IE), como pueden ser:</p> <ul> <li>Actividades de ense\u00f1anza/aprendizaje, normalmente realizadas en el aula, acompa\u00f1adas de una r\u00fabrica. Distinguiremos las actividades de clase (AC), las cuales se calificar\u00e1n normalmente sobre una escala de 3 puntos, de las actividades de refuerzo (AR), tambi\u00e9n sobre 3 puntos para consolidar uno o varios CE no conseguidos, as\u00ed como actividades de profundizaci\u00f3n (AP) que aportar\u00e1n puntos extra al RA.</li> <li>Pr\u00e1cticas (PR) o trabajo de investigaci\u00f3n (TI), con una carga temporal variable, entre una semana o toda una unidad did\u00e1ctica. Normalmente calificados sobre 10 puntos.</li> <li>Proyectos (PY), bien de desarrollo individual o en parejas, sobre un determinado RA. Normalmente calificados sobre 30 puntos.</li> <li>Pruebas objetivas (PO). En algunos RA, y no de forma generalizada, se realizar\u00e1 una prueba objetiva (ya sea escrita o en ordenador). Normalmente calificados sobre 30 puntos.</li> </ul> <p>Para calcular la calificaci\u00f3n de cada resultado de aprendizaje, se realizar\u00e1 la media ponderada simple de los diferentes instrumentos de evaluaci\u00f3n empleados en dicho RA.</p> <p>Todas las calificaciones, tanto de los instrumentos de evaluaci\u00f3n como de los propios RA, se podr\u00e1 consultar en todo momento en la plataforma Aules del curso.</p> <p>Para superar el m\u00f3dulo</p> <p>Se deber\u00e1 aprobar todos los Resultados de Aprendizaje para dar el m\u00f3dulo por superado. En caso de no superar uno de ellos, la calificaci\u00f3n del m\u00f3dulo profesional ser\u00e1 de 4.</p>"},{"location":"index.html#materiales","title":"Materiales","text":"<p>A lo largo del curso, iremos trabajando diferentes materiales disponibles en este espacio web.</p> <p>Cada una de las UT comenzar\u00e1 con un resumen de la Propuesta Did\u00e1ctica que se plantea, los elementos que va a cubrir, tanto el RA o RRAA a trabajar como sus CCEE asociados.</p> <p>En cada UT, adem\u00e1s de diferentes recursos de Referencia para ampliar conocimientos, se plantean una serie de Actividades que iremos trabajando en su mayor medida en el aula. Cada una de las actividades indica el RA que cubre, los CE que trabaja as\u00ed como su calificaci\u00f3n, la cual luego se ver\u00e1 reflejada en la r\u00fabrica de la entrega dicha tarea en Aules. Adem\u00e1s, las actividades est\u00e1n codificadas con el prefijo del tipo de instrumento de evaluaci\u00f3n, as\u00ed como la unidad que cubren (por ejemplo, la actividad AC 207, ser\u00e1 la 7\u00aa actividad de clase de la unidad 2).</p>"},{"location":"includes/abbreviations.html","title":"Abbreviations","text":""},{"location":"uutt/ut01/011_ProgramaLenguajes.html","title":"Programa y lenguajes de programaci\u00f3n","text":"<p>Un programa es una secuencia de instrucciones que un ordenador ejecuta para realizar alguna tarea. Parece una idea bastante simple, pero para que el ordenador pueda hacer uso de las instrucciones, deben estar escritas de forma que las pueda usar. Esto significa que los programas deben estar escritos en lenguajes de programaci\u00f3n.</p> <p>Los lenguajes de programaci\u00f3n se diferencian de los lenguajes humanos ordinarios en que son completamente inequ\u00edvocos y muy estrictos sobre lo que est\u00e1 y no est\u00e1 permitido en un programa. Las reglas que determinan lo que est\u00e1 permitido se denominan sintaxis del lenguaje. Las reglas de sintaxis especifican el vocabulario b\u00e1sico del lenguaje y c\u00f3mo se pueden construir los programas.</p>"},{"location":"uutt/ut01/011_ProgramaLenguajes.html#caracteristicas","title":"Caracter\u00edsticas","text":"<p>Los lenguajes de programaci\u00f3n, o lenguajes de alto nivel, est\u00e1n espec\u00edficamente dise\u00f1ados para programar computadores. Tiene las siguientes caracter\u00edsticas fundamentales:</p> <ul> <li>Son independientes de la arquitectura del computador.</li> <li>Normalmente, una sentencia en un lenguaje de alto nivel requiere de varias instrucciones en lenguaje m\u00e1quina.</li> <li>Utilizan notaciones cercanas a las habituales en el \u00e1mbito en que se usan.</li> </ul> <p>Como consecuencia de este alejamiento de la m\u00e1quina y acercamiento a las personas, los programas escritos en lenguajes de programaci\u00f3n no pueden ser directamente interpretados por el computador, siendo necesario realizar previamente su traducci\u00f3n a lenguaje m\u00e1quina.</p>"},{"location":"uutt/ut01/011_ProgramaLenguajes.html#el-proceso-de-traduccion","title":"El proceso de traducci\u00f3n","text":"<p>Como el computador puede interpretar y ejecutar \u00fanicamente c\u00f3digo m\u00e1quina, existen traductores que traducen programas escritos en lenguajes de programaci\u00f3n a lenguaje m\u00e1quina. El programa inicial se denomina programa fuente y el programa obtenido, programa objeto.</p> <p>La traducci\u00f3n por un compilador (la compilaci\u00f3n) consta de dos etapas fundamentales: la etapa de an\u00e1lisis del programa y la etapa de s\u00edntesis del programa objeto. El an\u00e1lisis del texto fuente implica la realizaci\u00f3n de un an\u00e1lisis del l\u00e9xico, de la sintaxis y de la sem\u00e1ntica. La s\u00edntesis del programa objeto conduce a la generaci\u00f3n de c\u00f3digo y su optimizaci\u00f3n.</p>"},{"location":"uutt/ut01/011_ProgramaLenguajes.html#compiladores-e-interpretes","title":"Compiladores e int\u00e9rpretes","text":"<p>Un compilador traduce un programa fuente, escrito en un lenguaje de alto nivel, a un programa objeto, escrito en lenguaje ensamblador o m\u00e1quina. Un int\u00e9rprete hace que un programa fuente escrito en un lenguaje vaya, sentencia a sentencia, traduci\u00e9ndose y ejecut\u00e1ndose directamente por el computador.</p>"},{"location":"uutt/ut01/011_ProgramaLenguajes.html#tipos-de-lenguajes-de-programacion","title":"Tipos de lenguajes de programaci\u00f3n","text":"Tipos de lenguajes programaci\u00f3n"},{"location":"uutt/ut01/012_LenguajeJava.html","title":"El lenguaje de programaci\u00f3n Java","text":"<p>Java es un lenguaje de programaci\u00f3n orientado a objetos desarrollado por Sun Microsystems a principios de los a\u00f1os 90. Su creador, James Gosling, lo bautiz\u00f3 como Oak. Sun deseaba disponer de un lenguaje para programar peque\u00f1os dispositivos electr\u00f3nicos (electrodom\u00e9sticos y otros aparatos electr\u00f3nicos de consumo). La dificultad de estos dispositivos es que cambian continuamente y para que un programa funcione en el siguiente dispositivo aparecido, hay que reescribir el c\u00f3digo. Por eso Sun quer\u00eda crear un lenguaje independiente del dispositivo.</p> <p>En 1995, Oak pasa a llamarse Java. El lenguaje Java debe su nombre a un tipo de caf\u00e9. En EEUU se conoce como Java al caf\u00e9, y tomarse una taza de Java es tomarse una taza de caf\u00e9. De ah\u00ed que el logotipo oficial de Java es una taza humeante de caf\u00e9.</p> Evoluci\u00f3n logo Java <p>Desde su lanzamiento en 1995 Java se da a conocer al p\u00fablico y adquiere notoriedad r\u00e1pidamente. Se comienza a hablar de Java y de sus applets. Un applet es un programa Java que se ejecuta en el contexto de una p\u00e1gina web en cualquier ordenador independientemente de su Sistema Operativo y de la arquitectura de su procesador. El entorno de ejecuci\u00f3n era relativamente seguro y los principales navegadores web pronto incorporaron la posibilidad de ejecutar applets Java incrustadas en las p\u00e1ginas web, si bien es cierto que hoy en d\u00eda ha deca\u00eddo su uso.</p> <p>Eslogan de Java</p> <p>Write Once, Run Anywhere</p> <p>En 2010 Oracle compr\u00f3 Sun Microsystems por 7.400 millones de d\u00f3lares. Java ha continuado su evoluci\u00f3n a\u00f1adiendo nuevas caracter\u00edsticas para la programaci\u00f3n web como los JSP y Servlets, los EJBs para el desarrollo de aplicaciones empresariales e introdujo adem\u00e1s las clases necesarias para la programaci\u00f3n de m\u00f3viles.</p> <p>Nota</p> <p>En este curso no veremos nada relacionado con JSP ni Servlets ni EJBs por no usarse en la actualidad m\u00e1s all\u00e1 del mantenimiento que hace alguna empresa de soluciones pasadas.</p> <p>En la actualidad existen tres distribuciones principales de Java:</p> <ul> <li>Java SE (Java Platform, Standard Edition), anteriormente conocido como J2SE. Es la versi\u00f3n est\u00e1ndar de Java y es la base de las otras distribuciones. Contiene todos los fundamentos b\u00e1sicos del lenguaje. Est\u00e1 orientada al desarrollo de aplicaciones de escritorio.</li> <li>Jakarta EE (Java Platform, Enterprise Edition), anteriormente conocido como Java EE y J2EE. Utiliza muchos de los componentes de J2SE y a\u00f1ade nuevas funcionalidades. Est\u00e1 orientada al desarrollo de servicios web, networking, aplicaciones en el lado del servidor y aplicaciones basadas en la web. Es uno de los est\u00e1ndares para el desarrollo de aplicaciones web.</li> <li>Java ME (Java Platform, Micro Edition), anteriormente conocido como J2ME. Esta distribuci\u00f3n de Java est\u00e1 orientada a la programaci\u00f3n de dispositivos m\u00f3viles, dispositivos inal\u00e1mbricos y peque\u00f1os dispositivos.</li> </ul>"},{"location":"uutt/ut01/012_LenguajeJava.html#la-maquina-virtual-de-java","title":"La m\u00e1quina virtual de Java","text":"<p>La gran innovaci\u00f3n que introdujo Java respecto a los dem\u00e1s lenguajes de programaci\u00f3n existentes que hizo posible que un programa funcionara en cualquier plataforma, fue la creaci\u00f3n de la Java Virtual Machine (JVM) o M\u00e1quina Virtual Java.</p> <p>Normalmente un programa escrito en un lenguaje de programaci\u00f3n (c\u00f3digo fuente) se debe traducir a un lenguaje entendible por la m\u00e1quina (c\u00f3digo m\u00e1quina o ejecutable). La traducci\u00f3n la realiza un programa traductor, generalmente un compilador.</p> <p>Este c\u00f3digo m\u00e1quina o c\u00f3digo ejecutable es distinto para cada arquitectura. Ordenadores con sistemas operativos y/o hardware distintos tienen distinto c\u00f3digo m\u00e1quina. Si cambia el c\u00f3digo fuente hay que realizar una compilaci\u00f3n para cada tipo de arquitectura donde ese vaya a ejecutar el programa. Para eliminar la dependencia de la m\u00e1quina:</p> <ul> <li>En Java un programa no se traduce directamente a c\u00f3digo ejecutable.</li> <li>Un programa Java se compila y se obtiene un c\u00f3digo intermedio llamado bytecode.</li> <li>El bytecode lo interpreta la M\u00e1quina Virtual de Java (JVM) y obtiene el c\u00f3digo ejecutable.</li> </ul> <p>La m\u00e1quina virtual de Java (o JVM) se distribuye gratuitamente para pr\u00e1cticamente todos los sistemas operativos. Un archivo .class (bytecode) se puede ejecutar en cualquier ordenador que tenga instalada la m\u00e1quina virtual Java.</p> <p>La JVM forma parte del JRE (Java Runtime Environment) o entorno de ejecuci\u00f3n de Java.</p>"},{"location":"uutt/ut01/012_LenguajeJava.html#caracteristicas-del-lenguaje-java","title":"Caracter\u00edsticas del lenguaje Java","text":""},{"location":"uutt/ut01/012_LenguajeJava.html#simple","title":"Simple","text":"<p>El estilo de programaci\u00f3n es simple y el c\u00f3digo es f\u00e1cil de entender. La sintaxis es similar a la de C++ y a la de otros lenguajes como C, C#, PHP... , por lo que si se conoce alguno de estos lenguajes se facilita su aprendizaje. Adem\u00e1s, cuando sabemos Java se puede aprender uno de estos lenguajes con mayor facilidad. Aunque la sintaxis sea similar a C++ elimina algunas de las caracter\u00edsticas m\u00e1s conflictivas de este lenguaje:</p> <ul> <li>No hay punteros.</li> <li>No hay sobrecarga operadores.</li> <li>No permite la herencia m\u00faltiple.</li> <li>No hay necesidad de liberar memoria manualmente. La gesti\u00f3n de memoria din\u00e1mica se hace autom\u00e1ticamente (recolector de basura).</li> </ul>"},{"location":"uutt/ut01/012_LenguajeJava.html#compilado-e-interpretado","title":"Compilado e interpretado","text":"<p>Normalmente un lenguaje es compilado o interpretado. Java es ambas cosas. El c\u00f3digo fuente se compila para obtener los bytecodes y posteriormente la m\u00e1quina virtual interpreta esos bytecodes y los convierte en c\u00f3digo m\u00e1quina.</p>"},{"location":"uutt/ut01/012_LenguajeJava.html#multiplataforma","title":"Multiplataforma","text":"<p>Java es independiente de la plataforma y puede ejecutarse en cualquier m\u00e1quina que tenga instalada la m\u00e1quina virtual de Java.</p>"},{"location":"uutt/ut01/012_LenguajeJava.html#orientado-a-objetos","title":"Orientado a objetos","text":"<p>Es un lenguaje orientado a objetos por lo que facilitar\u00e1 el dise\u00f1o y mantenimiento de programas grandes.</p>"},{"location":"uutt/ut01/012_LenguajeJava.html#robusto","title":"Robusto","text":"<p>Es capaz de manejar errores en tiempo de ejecuci\u00f3n mediante el controlador de excepciones. Utiliza un recolector de basura para eliminar de la memoria todos los objetos que ya no se usan quitando esa responsabilidad al programador. Realiza la comprobaci\u00f3n de tipos en cualquier operaci\u00f3n avisando si intervienen tipos incompatibles lo que hace que se eviten errores de c\u00e1lculo. Al no haber punteros, no se puede acceder de forma directa a la memoria del ordenador.</p>"},{"location":"uutt/ut01/012_LenguajeJava.html#multitarea","title":"Multitarea","text":"<p>Permite crear programas con varios hilos (threads) de ejecuci\u00f3n. Esto quiere decir que puede ejecutar diferentes l\u00edneas de c\u00f3digo al mismo tiempo lo que permite aprovechar las caracter\u00edsticas de los procesadores con m\u00faltiples n\u00facleos. Los hilos son importantes en programaci\u00f3n multimedia, aplicaciones web, etc.</p>"},{"location":"uutt/ut01/012_LenguajeJava.html#que-necesito-para-programar-en-java","title":"\u00bfQu\u00e9 necesito para programar en Java?","text":"<p>A la hora de empezar a programar en Java necesitamos:</p> <ol> <li> <p>El JDK (Java Development Kit o Kit de Desarrollo en Java). Es el software que nos permite crear aplicaciones Java de distintos tipos. Es lo primero que debemos tener instalado en nuestro ordenador. El JDK incluye:</p> <ul> <li>El JRE (Java Runtime Environment). Es la m\u00e1quina virtual de Java que traduce el bytecode a c\u00f3digo ejecutable.</li> <li>El compilador de Java. Es el encargado de convertir nuestro c\u00f3digo fuente a bytecode.</li> <li>API de Java (Application Programming Interface). Contiene todos los paquetes, clases e interfaces del lenguaje Java. Es el c\u00f3digo que proporciona Java para que el programador desarrolle sus propias aplicaciones.</li> </ul> <p>El entorno JDK funciona \u00fanica y exclusivamente mediante comandos de consola:</p> <ul> <li><code>javac</code> Es el comando compilador de Java. Su sintaxis es: <code>javac ejemplo.java</code> La entrada de este comando ha de ser necesariamente un fichero que contenga c\u00f3digo escrito en lenguaje Java y con extensi\u00f3n .java. El comando nos crear\u00e1 un fichero .class por cada clase que contenga el fichero Java.</li> <li><code>java</code> Es el int\u00e9rprete de Java. Permite ejecutar aplicaciones que previamente hayan sido compiladas y transformadas en ficheros .class. Su sintaxis es: <code>java ejemplo</code>. No es necesario aqu\u00ed suministrar la extensi\u00f3n del fichero, ya que siempre ha de ser un fichero .class.</li> </ul> </li> <li> <p>Un IDE (Integrated Development Environment). Los entornos de desarrollo son herramientas software que ayudan al programador el desarrollo de los programas avanzados. Entre otras muchas funciones, un entorno de desarrollo contiene distintas herramientas en una sola interfaz gr\u00e1fica. Generalmente contiene:</p> <ul> <li>Un editor de texto que ayuda a escribir el c\u00f3digo resaltando la sintaxis con indicaciones visuales.</li> <li>Un depurador que sirve para probar y depurar el c\u00f3digo.</li> <li>Herramientas para compilar y ejecutar el programa.</li> </ul> <p>Mediante un IDE, el desarrollador de aplicaciones puede escribir, compilar y ejecutar programas de forma sencilla.</p> </li> </ol>"},{"location":"uutt/ut01/012_LenguajeJava.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 101 (RA1 / CE1a / IC1 / 3p) Crea un fichero llamado <code>HolaMundo.java</code>. Guarda el archivo \"HolaMundo.java\" en una ubicaci\u00f3n de tu elecci\u00f3n en tu sistema. Abre la terminal o l\u00ednea de comandos de tu sistema operativo. Navega hasta la ubicaci\u00f3n donde guardaste el archivo <code>HolaMundo.java</code>. Compila el fichero desde la consola o terminal usando el compilador de Java.</p> <p>Entrega</p> <p>Adem\u00e1s de los ficheros, responde a las siguientes cuestiones:</p> <ul> <li>a) \u00bfSe ha generado alg\u00fan fichero extra al realizar el paso de compilaci\u00f3n?, Si es as\u00ed, \u00bfc\u00f3mo se llama el fichero compilado?</li> <li>b) \u00bfQu\u00e9 incluye dicho fichero?</li> <li>c) Si ahora quisiera ejecutar el programa HolaMundo desde otro sistema operativo \u00bfqu\u00e9 pasos tendr\u00eda que realizar?</li> </ul> <p>Crea capturas de pantalla donde se vea el resultado de ejecutar el programa HolaMundo.</p> </li> <li> <p>AC 102 (RA1 / CE1a / IC1 / 3p) Crea dos archivos Java, uno llamado <code>Calculadora.java</code> y otro <code>MainApp.java</code>, con el siguiente c\u00f3digo:</p> <p>Calculadora.java<pre><code>public class Calculadora {\n    public static int sumar(int a, int b){\n        return a+b;\n    }\n    public static int restar (int a, int b){\n        return a-b; \n    }\n    public static int multiplicar (int a, int b){\n        return a*b;\n    }\n    public static int dividir (int a, int b){\n        if(b != 0){ \n            return a/b;\n        }else{ \n            System.out.println(\"Error\");\n            return 0;\n        }\n    }\n}\n</code></pre> MainApp.java<pre><code>public class MainApp {\n    public static void main(String[] args) {\n        if (args.length != 3) {\n            System.out.println(\"Uso incorrecto. Debes proporcionar dos n\u00fameros y una operaci\u00f3n.\"); \n            System.out.println(\"Ejemplo: java MainApp 5 + 3\");\n            return;\n        }\n\n        int num1 = Integer.parseInt(args[0]); \n        String operacion = args[1];\n        int num2 = Integer.parseInt(args[2]);\n        int resultado = 0;\n\n        switch (operacion) {\n            case \"+\":\n                resultado = Calculadora.sumar(num1, num2); \n                break;\n            case \"-\":\n                resultado = Calculadora.restar(num1, num2); \n                break;\n            case \"*\":\n                resultado = Calculadora.multiplicar(num1, num2); \n                break;\n            case \"/\":\n                resultado = Calculadora.dividir(num1, num2); \n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida. Las operaciones v\u00e1lidas son +, -, *, y /.\"); \n                return;\n        }\n        System.out.println(\"Resultado: \" + resultado); \n    }\n}\n</code></pre></p> <p>Info</p> <p>Guarda ambos archivos en la misma ubicaci\u00f3n. Abre la terminal o l\u00ednea de comandos y navega hasta la ubicaci\u00f3n donde guardaste los archivos. Compila ambos archivos Java  Una vez que la compilaci\u00f3n se complete sin errores, puedes ejecutar el programa MainApp con argumentos de l\u00ednea de comandos. </p> <p>Por ejemplo, para sumar 5 y 3, escribe: <code>java MainApp 3 + 5</code></p> <p>Entrega</p> <ul> <li>a) Experimenta con diferentes operaciones (+, -, *, /) y n\u00fameros para ver c\u00f3mo funciona la calculadora simple y realiza capturas de pantalla.</li> <li>b) Mirando el c\u00f3digo, \u00bfqu\u00e9 l\u00edneas de c\u00f3digo contienen los n\u00fameros que se ejecutan por l\u00ednea de comandos?</li> <li>c) \u00bfQu\u00e9 pasa cuando haces una operaci\u00f3n que no existe? Realiza capturas de pantalla.</li> </ul> </li> <li> <p>AR 103 (RA1 / CE1a / IC1 / 1p) Genera la clase <code>Programa103.java</code>, este programa ha de devolver un saludo con el nombre que se le pase por par\u00e1metro a trav\u00e9s del terminal.</p> </li> <li> <p>AR 104 (RA1 / CE1a / IC1 / 1p) Genera la clase <code>Programa104.java</code>, este programa ha de devolver el d\u00eda que se le pase por par\u00e1metro a trav\u00e9s del terminal.</p> </li> <li> <p>AP 105 (RA1 / CE1a / IC1 / 3p) Escribe un nuevo programa <code>Programa105.java</code> que muestre el promedio de tres n\u00famero, por ejemplo, se le pasa por terminal 9, 7 y 5 y ha de mostrar el promedio.</p> </li> <li> <p>AP 106 (RA1 / CE1a / IC1 / 3p) Escribe un nuevo programa <code>Programa106.java</code> el cuadrado del n\u00famero introducido, por ejemplo, se le pasa por terminal 9, debe devolver 81.</p> </li> </ul>"},{"location":"uutt/ut01/013_Estructura.html","title":"Estructura y bloques fundamentales de un programa","text":"<p>Para solucionar un problema real, es necesario encontrar un m\u00e9todo de resoluci\u00f3n del problema y, posteriormente, descomponerlo en acciones sencillas, que el ordenador sea capaz de realizar.</p> <p>El pseudoc\u00f3digo es un lenguaje que permite pasar casi de manera directa la soluci\u00f3n del problema a un lenguaje de programaci\u00f3n espec\u00edfico. El pseudoc\u00f3digo es una serie de pasos bien detallados y claros que conducen a la resoluci\u00f3n de un problema. La facilidad de pasar casi de forma directa el pseudoc\u00f3digo a la computadora ha dado como resultado que muchos programadores implementen de forma directa los programas en la computadora.</p> <p>Ejemplo volumen</p> <p>Escribe el pseudoc\u00f3digo para determinar el volumen de una caja de dimensiones A, B y C. Para ello podemos resolverlo con el siguiente pseudoc\u00f3digo:</p> <ol> <li>Inicio</li> <li>Leer las medidas A, B y C</li> <li>Realizar el producto de A * B * C y guardarlo en V (V = A * B * C)</li> <li>Escribir el resultado V</li> <li>Fin</li> </ol>"},{"location":"uutt/ut01/013_Estructura.html#concepto-de-algoritmo","title":"Concepto de algoritmo","text":"<p>No todos los m\u00e9todos de soluci\u00f3n de un problema son susceptibles de ser utilizados por un computador. Para que un procedimiento pueda ser implementado en un computador debe cumplir determinados requisitos:</p> <ul> <li>Ha de estar compuesto de acciones bien definidas.</li> <li>Debe estar formado por una secuencia finita de operaciones con un orden definido.</li> <li>Por \u00faltimo, debe acabar en un tiempo finito.</li> </ul> <p>Se puede dar la siguiente definici\u00f3n de algoritmo: un algoritmo es un procedimiento no ambiguo que resuelve un problema. Un procedimiento es una secuencia de operaciones bien definidas, cada una de las cuales requiere una cantidad finita de memoria y se realiza en un tiempo finito.</p> <p>Ejemplo n\u00famero par</p> <p>Escribe un algoritmo que determine si un n\u00famero es par. Siendo N un n\u00famero cualquiera.</p> <ol> <li>Leer N</li> <li>Si N=2 entonces Escribe (\u201ces par\u201d)</li> <li>Si N=1 entonces Escribe (\u201ces impar\u201d)</li> <li>N=N-2</li> <li>Si N&gt;0 ir a 2</li> <li>Fin</li> </ol> <p>Para resolver un mismo problema, se pueden definir infinidad de algoritmos. Normalmente interesa, no solo encontrar un algoritmo, sino que este sea suficientemente bueno. La bondad de un algoritmo puede medirse por dos factores:</p> <ul> <li>El tiempo que se necesita para ejecutarlo. Est\u00e1 en relaci\u00f3n con el n\u00famero de instrucciones de cada tipo necesarias.</li> <li>Los recursos que se necesitan para implementar el algoritmo.</li> </ul> <p>No hay ning\u00fan procedimiento riguroso que permita construir un algoritmo que resuelva un problema dado, teniendo gran importancia la imaginaci\u00f3n y experiencia de la persona que lo realiza.</p> <p>Ejemplo n\u00famero par m\u00e1s eficiente</p> <p>Escribe un algoritmo que determine si un n\u00famero es par. Siendo N un n\u00famero cualquiera.</p> <ol> <li>Leer N</li> <li>M=2*int(N/2)</li> <li>Si M=N entonces Escribe (\u201ces par\u201d)</li> <li>Si no entonces Escribe (\u201ces impar\u201d)</li> <li>Fin</li> </ol>"},{"location":"uutt/ut01/013_Estructura.html#diagrama-de-flujo","title":"Diagrama de flujo","text":"<p>Los diagramas de flujo permiten representar visualmente qu\u00e9 operaciones se requieren y en qu\u00e9 secuencia se deben efectuar para solucionar un problema dado. Dentro de los diagramas de flujo se pueden utilizar los s\u00edmbolos que se presentan a continuaci\u00f3n, con los cuales se indican las operaciones que se efectuar\u00e1n sobre los datos para producir un resultado La importancia de usar unos s\u00edmbolos est\u00e1ndares, est\u00e1 en que cualquiera puede entender nuestro diagrama o bien nosotros comprender lo que se nos pide programar.</p> <p>En todo diagrama de flujo se acompa\u00f1ar\u00e1 con una tabla en la que se especificar\u00e1: nombre de variable, una descripci\u00f3n y tipo.</p>"},{"location":"uutt/ut01/013_Estructura.html#estructuras-secuenciales","title":"Estructuras secuenciales","text":"<p>En este tipo de estructura las instrucciones se realizan o se ejecutan una despu\u00e9s de la otra y, por lo general, se espera que se proporcione uno o varios datos, los cuales son asignados a variables para que con ellos se produzcan los resultados que representen la soluci\u00f3n del problema.</p>"},{"location":"uutt/ut01/013_Estructura.html#estructuras-selectivas","title":"Estructuras selectivas","text":"<p>Hasta ahora s\u00f3lo hemos resuelto problemas que se pod\u00edan hacer de manera secuencial. Pero, \u00bfqu\u00e9 pasar\u00eda si quiere hacer un algoritmo que me resuelva un problema que requiere elegir? Es por ello que los algoritmos, en determinados momentos, requieren ser selectivos en lo que respecta a las acciones que deben seguir. De aqu\u00ed que las estructuras selectivas para los algoritmos sean tan importantes, de modo que en la mayor\u00eda de los problemas se tiene presente una estructura selectiva, que implica seguir o no un determinado flujo de secuencia del problema.</p> <p>En los algoritmos para la soluci\u00f3n de problemas donde se utilizan estructuras selectivas se emplean frases que est\u00e1n estructuradas de forma adecuada dentro del pseudoc\u00f3digo.</p>"},{"location":"uutt/ut01/013_Estructura.html#estructuras-repetitivas","title":"Estructuras repetitivas","text":"<p>De igual forma se pueden presentar muchos casos donde el proceso se debe repetir varias veces. Por tal motivo se emplean estructuras denominadas repetitivas, de ciclo o de bucle, e independientemente del nombre que se les aplique, lo que importa es que permiten que un proceso pueda realizarse N veces, donde solo cambien los par\u00e1metros que se utilizan en el proceso.</p> <p>Cuando se requiere que un proceso se efect\u00fae de manera c\u00edclica, se emplean estructuras que permiten el control de ciclos. Estas estructuras se utilizan en base a las condiciones propias de cada problema, los nombres con los que se conocen son: \u201cMientras\u201d, \u201cRepite hasta\u201d y \u201cDesde ... hasta\u201d.</p>"},{"location":"uutt/ut01/013_Estructura.html#cuando-uso-cada-una","title":"\u00bfCu\u00e1ndo uso cada una?","text":"<p>Con estas estructuras bases podemos llegar a representar cualquier tipo de problema que pueda ser resuelto por un ordenador. No hay que hacer un mal uso de las mismas, pues cada una tiene una funcionalidad asociada.</p> <p>No usar\u00e9 una secuencial cuando tengo que hacer una elecci\u00f3n. Del mismo modo que no usar\u00e9 una repetitiva si es una sola secuencia.</p> <p>Hay que tener en cuenta la optimizaci\u00f3n y el rendimiento de los algoritmos que desarrollemos, pues esto nos ayudar\u00e1 a simplificar el c\u00f3digo y a ahorrar recursos. Un programa ser\u00e1 mejor o peor en cuanto su algoritmo est\u00e9 optimizado de una manera u otra.</p> <p>Ellen Ullman</p> <p>Programming is the art of algorithm design and the craft of debugging errant code.</p>"},{"location":"uutt/ut01/013_Estructura.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 107 (RA1 / CE1a / IC1 / 3p) Abre tu navegador y accede a la URL: www.draw.io. Se abrir\u00e1 un software para realizar diagramas online. Realiza el diagrama de flujo y el pseudoc\u00f3digo del proceso de c\u00e1lculo del \u00e1rea de un rect\u00e1ngulo, tomando b y a como su base y altura, y teniendo en cuenta que el \u00e1rea es A = b*a.</p> <p>Entrega</p> <p>Realiza un documento donde se identifique la actividad y contenga: </p> <ul> <li>Diagrama de flujo</li> <li>Pseudoc\u00f3digo</li> <li>Tipo de variables</li> </ul> </li> <li> <p>AC 108 (RA1 / CE1a / IC1 / 3p) Abre tu navegador y accede a la URL: www.draw.io. Se abrir\u00e1 un software para realizar diagramas online. Realiza el diagrama de flujo y escribe el pseudoc\u00f3digo del proceso de compra de un producto en un supermercado, teniendo como variables (de tipo real) CP (coste del producto), CDC (cantidad de dinero del cliente) y D(devoluci\u00f3n). Recuerda indicar primero el tipo de variables que utilizas.</p> </li> <li> <p>AR 109 (RA1 / CE1a / IC1 / 1p) Abre tu navegador y accede a la URL: www.draw.io. Se abrir\u00e1 un software para realizar diagramas online. Se requiere obtener el \u00e1rea (A) de una circunferencia de radio R, sabiendo que A = PI*R2 . Realiza el algoritmo correspondiente y repres\u00e9ntalo mediante un diagrama de flujo y el pseudoc\u00f3digo correspondiente. Recuerda indicar las variables</p> </li> <li> <p>PR 110 (RA1 / CE1a / IC1 / 5p) El consultorio del Dr. Lorenzo tiene como pol\u00edtica cobrar al paciente en funci\u00f3n del n\u00famero de citas o consultas (NC), de la siguiente forma:</p> <ul> <li>Las tres primeras citas a 50 \u20ac/cita.</li> <li>Las siguientes dos citas a 40 \u20ac/cita.</li> <li>Las restantes a 30 \u20ac/cita, mientras dure el tratamiento.</li> </ul> <p>Se requiere un \u00fanico algoritmo para determinar cu\u00e1nto pagar\u00e1 el paciente por cada cita (CC) y el total (TOTAL) de lo que ha pagado por el tratamiento. Para la soluci\u00f3n de este problema se necesita saber inicialmente cu\u00e1ntas citas se efectuar\u00e1n, y con ello se podr\u00e1 determinar el costo que tendr\u00e1 cada cita y cu\u00e1nto se ha gastado en el tratamiento.</p> </li> <li> <p>PR 111 (RA1 / CE1a / IC1 / 5p) Se requiere un algoritmo para determinar, de N cantidades, cu\u00e1ntas son menores o iguales a cero y cu\u00e1ntas mayores a cero. Realiza el diagrama de flujo y escribe su pseudoc\u00f3digo utilizando los ciclos:</p> <ul> <li>a. Mientras.</li> <li>b. Repite hasta. </li> <li>c. Desde...hasta.</li> </ul> </li> </ul>"},{"location":"uutt/ut01/014_IDE.html","title":"Entornos Integrados de Desarrollo (IDE)","text":"<p>Para programar s\u00f3lo se necesita un simple bloc de notas o editor de texto. En el caso de Java un compilador. Pero la escritura y compilaci\u00f3n de programas hecha de esta forma es un poco incomoda. Por ello numerosas empresas fabrican sus propios entornos de edici\u00f3n, algunos incluyen el compilador y otras utilizan el propio JDK de Oracle.</p> <p>Algunas ventajas que ofrecen son:</p> <ul> <li>Facilidades para escribir c\u00f3digo.</li> <li>Facilidades de depuraci\u00f3n.</li> <li>Facilidad de configuraci\u00f3n del sistema.</li> <li>Facilidades para organizar los archivos de c\u00f3digo.</li> <li>Facilidad para exportar e importar proyectos</li> </ul>"},{"location":"uutt/ut01/014_IDE.html#netbeans","title":"Netbeans","text":"<p>Uno de los IDE Java m\u00e1s populares. Es un entorno gratuito de c\u00f3digo abierto para la generaci\u00f3n de c\u00f3digo en diversos lenguajes. Contiene pr\u00e1cticamente todo lo que se suele pedir a un entorno de desarrollo, editor avanzado de c\u00f3digo, depurador, diversos lenguajes, extensiones de todo tipo, etc. Tiene una arquitectura extensible con m\u00f3dulos espec\u00edficos para desarrollo web, aplicaciones m\u00f3viles, dise\u00f1o UML, etc.</p>"},{"location":"uutt/ut01/014_IDE.html#eclipse","title":"ECLIPSE","text":"<p>Junto a NetBeans, el entorno de desarrollo Java gratuito m\u00e1s utilizado. Es un entorno completo de c\u00f3digo abierto. Tambi\u00e9n permite el desarrollo en C++ y otros lenguajes de programaci\u00f3n.</p>"},{"location":"uutt/ut01/014_IDE.html#intellij-idea","title":"IntelliJ IDEA","text":"<p>Entorno de desarrollo completo creado por JetBrains para la creaci\u00f3n de software y est\u00e1 disponible en dos versiones, una versi\u00f3n para la comunidad y otra versi\u00f3n comercial.</p>"},{"location":"uutt/ut01/014_IDE.html#visual-studio-code","title":"Visual Studio Code","text":"<p>Editor de c\u00f3digo fuente ligero pero eficaz. Incluye compatibilidad integrada con JavaScript, TypeScript y Node.js, y cuenta con un amplio ecosistema de extensiones para otros lenguajes (como C++, C#, Java, Python, Go, .NET).</p>"},{"location":"uutt/ut01/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 01","text":""},{"location":"uutt/ut01/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA1.CE <ul> <li>Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado.</li> </ul> <ul> <li>a. Se han identificado los bloques que componen la estructura de un programa inform\u00e1tico.</li> </ul>"},{"location":"uutt/ut01/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li> <p>Programa y lenguajes de programaci\u00f3n</p> <ol> <li>Caracter\u00edsticas</li> <li>El proceso de traducci\u00f3n </li> <li>Compiladores e int\u00e9rpretes</li> <li>Tipos de lenguajes de programaci\u00f3n</li> </ol> </li> <li> <p>El lenguaje de programaci\u00f3n Java </p> <ol> <li>La m\u00e1quina virtual de Java</li> <li>Caracter\u00edsticas del lenguaje Java</li> <li>\u00bfQu\u00e9 necesito para programar en Java?</li> </ol> </li> <li> <p>Estructura y bloques fundamentales de un programa</p> <ol> <li>Concepto de algoritmo</li> <li>Diagramas de flujo</li> <li>Estructuras secuenciales</li> <li>Estructuras selectivas</li> <li>Estructuras repetitivas</li> </ol> </li> <li> <p>Entornos Integrados de Desarrollo (IDE)</p> </li> </ol>"},{"location":"uutt/ut01/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>09/09/2024</p> <p>1.1. Programa y lenguajes de programaci\u00f3n</p> <p></p> <p>02</p> <p>09/09/2024</p> <p>1.2. El lenguaje de programaci\u00f3n Java</p> <p>AC 101AC 102</p> <p>03</p> <p>10/09/2024</p> <p></p> <p>AR 103AP 106</p> <p>04</p> <p>11/09/2024</p> <p>1.3. Estructura y bloques fundamentales de un programa 1.4. IDE</p> <p>AC 107AC 108</p> <p>05</p> <p>11/09/2024</p> <p></p> <p>AC 109</p> <p>06</p> <p>12/09/2024</p> <p></p> <p>PR 110</p> <p>07</p> <p>12/09/2024</p> <p></p> <p>PR 111</p> <p>08</p> <p>13/09/2024</p> <p></p> <p>PO UT 01</p>"},{"location":"uutt/ut01/ResumenUT.html#referencias","title":"Referencias","text":"<ul> <li>Web: Getting Started with Java in VS Code</li> <li>Web: Java (programming language)</li> <li>Web: Escribe tu primer Hola Mundo en Java</li> <li>Web: \u00bfQu\u00e9 es un diagrama de flujo? por LucidChart</li> <li>Web: \u00bfQu\u00e9 es un diagrama de flujo? por Miro</li> </ul>"},{"location":"uutt/ut01/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":"<ul> <li>V\u00eddeo: What is Java and Why Do I Need It?</li> <li>V\u00eddeo: Why Java Is So Hard To Learn</li> </ul>"},{"location":"uutt/ut02/021_TiposDatos.html","title":"Tipos de datos","text":"<p>Un tipo de datos es un conjunto de valores y un conjunto de operaciones definidas en ellos. Se pueden clasificar en primitivos y objetos.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#tipos-nativos","title":"Tipos nativos","text":"<p>Los primitivos son los m\u00e1s b\u00e1sicos y fundamentales, vienen integrados en Java. Especifican el tipo de valor almacenado en una variable y el tama\u00f1o de la memoria. Hay 8 tipos primitivos de datos integrados en el lenguaje Java. Estos incluyen: int, byte, short, long, float, double, boolean y char.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#byte","title":"byte","text":"<p>Como su propio nombre denota, emplea un solo byte (8 bits) de almacenamiento. Esto permite almacenar valores en el rango [-128, 127]. Raramente se usa. Ocupa menos memoria y puede ser m\u00e1s r\u00e1pido accedido.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#short","title":"short","text":"<p>Usa el doble de almacenamiento que el anterior, es decir, ocupa 16 bits [-32.768, 32.767].</p>"},{"location":"uutt/ut02/021_TiposDatos.html#int","title":"int","text":"<p>Emplea 4 bytes (32 bits) de almacenamiento y es el tipo de dato entero m\u00e1s empleado. Necesita cuatro veces el espacio que ocupa un byte. Es el entero predeterminado usado en Java.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#long","title":"long","text":"<p>Es el tipo entero de mayor tama\u00f1o, 8 bytes (64 bits). </p>"},{"location":"uutt/ut02/021_TiposDatos.html#float","title":"float","text":"<p>Tiene una parte flotante que sirve para expresar n\u00fameros decimales. Es de simple precisi\u00f3n (formato y cantidad de espacio que ocupa) porque ocupa 32 bits. No se recomienda mucho su uso.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#double","title":"double","text":"<p>Es un n\u00famero de precisi\u00f3n doble y ocupa 64 bits. Es el flotante predeterminado en Java. Se recomienda su uso. Muchas librer\u00edas internas de Java, relacionadas con operaciones matem\u00e1ticas, usan double.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#char","title":"char","text":"<p>Se utiliza para almacenar caracteres (letras, n\u00fameros, signos, etc.) individuales. Ocupa 2 bytes en memoria (16 bits). Permite almacenar caracteres Unicode. Unicode es un est\u00e1ndar de codificaci\u00f3n internacional que nos permite representar diferentes idiomas; y la forma en que funciona es usando una combinaci\u00f3n de los dos bytes que un char ocupa en la memoria, que puede representar hasta 65535 diferentes tipos de caracteres</p> <p>Un car\u00e1cter precedido por una barra invertida (<code>\\</code>) es una secuencia de escape y tiene un significado especial para el compilador. </p>"},{"location":"uutt/ut02/021_TiposDatos.html#boolean","title":"boolean","text":"<p>S\u00f3lo permite almacenar dos posibles valores que son true o false. Tiene la finalidad de facilitar el trabajo con valores \"verdadero/falso\" (booleanos), resultantes por regla general de evaluar expresiones.</p> <p>Este tipo de datos representa un bit de informaci\u00f3n, pero su \"tama\u00f1o\" no es algo que est\u00e9 definido con precisi\u00f3n.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#wrapper-classes-clases-contenedores","title":"Wrapper classes (clases contenedores)","text":"<p>Las clases contenedoras proporcionan una forma de utilizar tipos de datos primitivos como objetos. En Java, tenemos una <code>Wrapper class</code> para cada uno de los 8 tipos de datos primitivos, estas clases las veremos m\u00e1s avanzado el curso.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#string","title":"String","text":"<p>Un String es un tipo de dato no primitvo que, en Java representa una cadena de caracteres no modificable. Todos los literales de la forma \"cualquier texto\", es decir, literales entre comillas dobles, que aparecen en un programa java se implementan como objetos de la clase String.</p> <p>Tres manera de usarlos</p> <ul> <li>Comillas dobles p. ej. String texto = \"IES La Encant\u00e1\";</li> <li>Utilizando new p. ej. String texto2 = new String (\"IES La Encant\u00e1\"); </li> <li>Utilizando el operador concatenaci\u00f3n <code>+</code> p. ej. String s2 = texto + \" 2024\u201d;     //s2 contiene \"IES La Encant\u00e1 2023\"</li> </ul>"},{"location":"uutt/ut02/021_TiposDatos.html#operador-concatenacion","title":"Operador concatenaci\u00f3n","text":"<p>La clase proporciona el operador <code>+</code> (concatenaci\u00f3n) para unir dos o m\u00e1s String. El resultado de aplicar este operador es un nuevo String concatenaci\u00f3n de los otros. </p>"},{"location":"uutt/ut02/021_TiposDatos.html#indices","title":"\u00cdndices","text":"<p>Cada uno de los caracteres que forman un String son del tipo primitivo char. Los caracteres de un string est\u00e1n numerados internamente con \u00edndices empezando desde el cero:</p> <p>El primer car\u00e1cter tiene \u00edndice 0 y el \u00faltimo tiene la longitud del string menos 1.</p>"},{"location":"uutt/ut02/021_TiposDatos.html#metodos-de-la-clase-string","title":"M\u00e9todos de la clase String","text":"<p>La clase String proporciona m\u00e9todos para el tratamiento de las cadenas de caracteres: acceso a caracteres individuales, buscar y extraer una subcadena, copiar cadenas, convertir cadenas a may\u00fasculas o min\u00fasculas, etc.</p> <p>\u00bfC\u00f3mo los uso?</p> <p>Para acceder a alguno de los m\u00e9todos siguientes utilizamos la notaci\u00f3n <code>.</code></p> <pre><code>String texto = \"Clase\";\nint longitud = texto.length(); //devuelve 5 \n</code></pre>"},{"location":"uutt/ut02/021_TiposDatos.html#comparar-strings","title":"Comparar Strings","text":"<p>Los operadores relacionales como <code>==</code> o <code>&lt;</code> o <code>&gt;</code> no se utilizan para comparar Strings, aunque el c\u00f3digo compile no es correcto, ya que <code>==</code> compara objetos, y devolver\u00eda falso aunque dos strings tuvieran el mismo texto puesto que son objetos diferentes. Para comparar <code>Strings</code> utilizamos el m\u00e9todo <code>equals</code>.</p> <p><pre><code>String name = \"Luffy\";\n\n  if (name.equals(\"Luffy\")) {\n    System.out.println(\"Coincide.\");\n  }\n</code></pre> La siguiente tabla muestra los m\u00e9todos que se utilizan para comparar <code>String</code></p>"},{"location":"uutt/ut02/021_TiposDatos.html#char-dentro-de-string","title":"char dentro de String","text":"<p>Como se ha comentado, un <code>String</code> est\u00e1 compuesto de caracteres tipo <code>char</code>. Para acceder a los caracteres dentro de un <code>String</code> usamos el m\u00e9todo <code>charAt()</code>. Se puede usar la concatenaci\u00f3n <code>+</code> para concatenar <code>char</code> con <code>String</code>.</p> <pre><code>String food = \"cookie\";\nchar firstLetter = food.charAt(0); // 'c'\nSystem.out.println(firstLetter + \" is for \" + food); \n</code></pre>"},{"location":"uutt/ut02/021_TiposDatos.html#char_1","title":"char","text":"<p>A todos los valores char se les asigna un n\u00famero internamente por el ordenador, son los llamados valores ASCII</p> <p>Cuidando con sumar enteros</p> <p>Mezclar tipos de datos char e int autom\u00e1ticamente causa una conversi\u00f3n en entero. </p> <p>'a' + 10 --&gt; devuelve 107.</p> <p>Para convertir un entero en su equivalente a car\u00e1cter (char) har\u00edamos:</p> <p>(char) ('a' + 2) --&gt; devuelve 'c'</p>"},{"location":"uutt/ut02/021_TiposDatos.html#diferencias-entre-char-y-string","title":"Diferencias entre char y String","text":"<ul> <li><code>String</code> es un objeto, por tanto, contiene m\u00e9todos.</li> <li><code>char</code> es un tipo de dato primitivo, no puedes llamar a m\u00e9todos con \u00e9l.</li> <li><code>String</code> utiliza comillas dobles.</li> <li><code>char</code> utiliza comillas simples.</li> <li>No se puede comparar un <code>String</code> usando operadores relacionales.</li> <li>S\u00ed se puede comparar un <code>char</code> usando operadores relacionales: <code>'a' &lt; 'b', 'X' == 'X', ...</code></li> </ul>"},{"location":"uutt/ut02/021_TiposDatos.html#actividades","title":"Actividades","text":"<ul> <li>AC 201 (RA1 / CE1b CE1c CE1d / IC1 / 3p) Ay\u00fadate de los rangos de los valores para saber qu\u00e9 tipo de datos es, del nombre que se le ha dado y del valor que almacena cada variable. Las variables con valor F\u00f3rmula, son variables que calculan expresiones ayud\u00e1ndose de otras variables. Su tipo de datos es el predefinido por Java.</li> </ul> <p>Note</p> <p>Muestra las variables por pantalla con su nombre como hacemos en el siguiente ejemplo:</p> <pre><code>System.out.println(\u201cisOccupied:\u201d + isOccuppied); \nSalida por pantalla: isOccupied: false\n</code></pre> <p>Entrega un zip con el c\u00f3digo del programa y un PDF con capturas y comentarios.</p>"},{"location":"uutt/ut02/022_Fechas.html","title":"Manejo de fechas en Java","text":"<p>Dado que las clases base de manejo de fechas en Java son tan problem\u00e1ticas, surgieron alternativas a <code>Date</code> por parte de la comunidad. La m\u00e1s conocida y utilizada siempre ha sido la biblioteca Joda-Time, que es gratuita y Open Source. Tan popular era que sus desarrolladores participaron junto a Oracle en la definici\u00f3n de las nuevas clases oficiales para manejo de fechas en Java: las incluidas en el paquete <code>java.time</code>. Este paquete <code>java.time</code> incluye muchas clases, pero las b\u00e1sicas son:</p> <ul> <li><code>LocalDate</code>: representa a fechas sin la hora y nos facilita su manejo para declararlas, sumar y restar fechas y compararlas.</li> <li><code>LocalTime</code>: es id\u00e9ntica a la anterior pero para el manejo de horas, sin ninguna fecha asociada, pudiendo as\u00ed compararlas, sumar o restar tiempo a las mismas...</li> <li><code>LocalDateTime</code>: como puedes suponer, es una combinaci\u00f3n de las dos anteriores, que permite hacer lo mismo con fechas y horas simult\u00e1neamente.</li> <li><code>Instant</code>: es muy parecida a la anterior pero a la vez muy diferente. Se usa para almacenar un punto determinado en el tiempo, o sea con fecha y hora, pero guarda su valor como un timestamp de UNIX, es decir, en nanosegundos desde el epoch de UNIX (1/1/1970 a las 00:00) y usando la zona horaria UTC. Es muy \u00fatil para manejar momentos en el tiempo de manera neutra e intercambiarlo entre aplicaciones y sistemas, por lo que lo ver\u00e1s utilizado muy a menudo.</li> <li><code>ZonedDateTime</code>: esta clase es como la LocalDateTime pero teniendo en cuenta una zona horaria concreta, ya que las anteriores no la tienen en cuenta.</li> <li><code>Period</code>: esta clase auxiliar nos ayuda a obtener diferencias entre fechas en distintos periodos (segundos, minutos, d\u00edas...) y tambi\u00e9n a a\u00f1adir esas diferencias a las fechas.</li> <li><code>Duration</code>: esta es muy parecida a la anterior pero para manejo de horas exclusivamente.</li> </ul>"},{"location":"uutt/ut02/022_Fechas.html#construyendo-fechas-y-horas-con-javatime","title":"Construyendo fechas y horas con <code>java.time</code>","text":"<p>Estas clases producen instancias inmutables, al contrario de lo que pasaba con las antiguas clases Date de Java, por lo que son thread-safe. Dado que carecen de constructores p\u00fablicos, se instancian usando m\u00e9todos de tipo \"factor\u00eda\", es decir, tienen m\u00e9todos que construyen estas clases a partir de posibles par\u00e1metros que le pasemos.</p> <p>En concreto, todas las de manejo de fechas y horas disponen de tres m\u00e9todos importantes, que son:</p> <ul> <li><code>now()</code>: crean instancias nuevas a partir de la fecha y hora actual.</li> <li><code>of()</code>: construyen fechas y horas a partir de sus partes.</li> <li><code>with()</code>: modifican la fecha u hora actual en funci\u00f3n del par\u00e1metro que se le pase, con alguna cantidad (a\u00f1os, d\u00edas, horas...) o alguna clase de ajuste que enseguida estudiaremos.</li> </ul> <p>Vamos a ver <code>now()</code> en acci\u00f3n con algunas de estas clases</p> <pre><code>System.out.println(\"La fecha actual es: \" + LocalDate.now());\nSystem.out.println( \"La hora actual es: \" + LocalTime.now() );\nSystem.out.println( \"La fecha y hora actuales son: \" + LocalDateTime.now() ); \nSystem.out.println( \"El instante actual es: \" + Instant.now() );\nSystem.out.println( \"La fecha y hora actuales con zona horaria son: \" + ZonedDateTime.now() );\n</code></pre> <p>Al convertirlas a cadena para mostrarlas se generan en el formato ISO 8601, que es un est\u00e1ndar ampliamente aceptado. Luego veremos c\u00f3mo formatearlas de otro modo que nos interese m\u00e1s. Para controlar qu\u00e9 fechas y horas generamos podemos usar el m\u00e9todo factor\u00eda of() que admite ciertos par\u00e1metros en funci\u00f3n del tipo de dato utilizado.</p> <pre><code>System.out.println( \"Fecha de mi cumplea\u00f1os: \" + LocalDate.of(1984, Month.MAY, 23) );\n</code></pre> <p>F\u00edjate en que para el mes, aunque podr\u00eda haber utilizado los n\u00fameros del 1 al 12 para indicarlo, he usado una enumeraci\u00f3n espec\u00edfica que existe para ello llamada <code>Month</code>, cuyos miembros son los nombres de los meses en ingl\u00e9s. As\u00ed que mayo, que ser\u00eda el mes 5, se convierte en <code>Month.MAY</code>.</p>"},{"location":"uutt/ut02/023_ConstantesLiterales.html","title":"Contantes y literales","text":""},{"location":"uutt/ut02/023_ConstantesLiterales.html#constantes","title":"Constantes","text":"<p>Un programa puede contener ciertos valores que no deben cambiar durante su ejecuci\u00f3n. Estos valores se llaman constantes. Es por ello que se puede definir constante como \u201cUna constante es una zona de memoria que se referencia con un identificador, conocido como nombre de la constante, donde se almacena un valor que no puede cambiar durante la ejecuci\u00f3n del programa\u201d. La nomenclatura para definir las constantes es la siguiente:</p> <ul> <li>Todas las letras de cada palabra deben estar en may\u00fasculas</li> <li>Se separa cada palabra con un _</li> <li>Se declaran similar a las variables, con la diferencia de que el tipo de dato va despu\u00e9s de la palabra reservada final</li> </ul> <pre><code>final double PI = 3.141591; \nfinal int MIN_WIDTH = 4; \nfinal double TASAS = 0.045;\n</code></pre> <p>Las constantes hacen que el programa sea m\u00e1s f\u00e1cil de leer y verificar que sea correcto. Si es necesario cambiar una constante (por ejemplo, si cambian las tasas), todo lo que tendremos que hacer es cambiar la declaraci\u00f3n de la constante. No ser\u00e1 necesario buscar en todo el programa cada aparici\u00f3n de ese n\u00famero espec\u00edfico.</p>"},{"location":"uutt/ut02/023_ConstantesLiterales.html#los-literales","title":"Los literales","text":"<p>Un literal Java es un valor de tipo entero, real, l\u00f3gico, car\u00e1cter, cadena de caracteres o un valor nulo (null) que puede aparecer dentro de un programa.</p> <p><pre><code>int x = 25;\ndouble precio = 10.99;\nString mes = \"enero\"\n</code></pre> Los literales suelen aparecer en la asignaci\u00f3n de valores a las variables o formando parte de expresiones aritm\u00e9ticas o l\u00f3gicas.</p> <p>Cuando se utilizan literales, es muy importante tener en cuenta que Java es un lenguaje fuertemente tipado, esto quiere decir que realiza un control estricto de los tipos de datos que pueden contener las variables.</p>"},{"location":"uutt/ut02/023_ConstantesLiterales.html#palabras-reservadas","title":"Palabras reservadas","text":"<p>Las palabras reservadas son identificadores predefinidos que tienen un significado para el compilador y por tanto no pueden usarse como identificadores creados por el usuario en los programas.</p> Palabras reservadas"},{"location":"uutt/ut02/024_Variables.html","title":"Variables en Java","text":"<p>Las variables en Java es una forma de almacenar informaci\u00f3n en nuestro ordenador. Definimos variables asign\u00e1ndoles un nombre. De igual manera se puede acceder a la informaci\u00f3n que guardar las variable, simplemente accediendo por el nombre que le hemos dado. Es el ordenador el que se encarga de averiguar d\u00f3nde se almacena internamente en la memoria RAM del ordenador.</p> <p>Como su nombre indica \"variable\", se puede modificar el contenido que \u00e9sta almacena, es decir, es variable. Lo \u00fanico que tenemos que hacer es decirle al PC qu\u00e9 tipo de informaci\u00f3n queremos guardar en nuestra variable y darle un nombre. Existe diferentes tipos de informaci\u00f3n que podemos utilizar para definir nuestras variables. Se les conoce como tipos de datos o data types. Los tipos de datos son palabras reservas keywords en Java, es decir, no podemos utilizarlas fuera del contexto de tipo de datos. Para definir una variable, necesitamos especificar el tipo de datos, luego darle un nombre a nuestra variable, y opcionalmente, podemos agregar una expresi\u00f3n para inicializar la variable con un valor.</p> <p>Reglas para el nombrado de variables</p> <ul> <li>Tiene que comenzar con una letra o '_', nunca con n\u00fameros.</li> <li>Puede contener n\u00fameros. No debe contener espacios en blanco.</li> <li>No debe ser muy largo y debe expresar algo en el contexto.</li> <li>No se pueden usar palabras reservadas.</li> <li>May\u00fasculas y min\u00fasculas se tratan diferente.</li> </ul>"},{"location":"uutt/ut02/024_Variables.html#visibilidad-y-vida-de-las-variables","title":"Visibilidad y vida de las variables","text":"<p>Las variables son memorias reservadas para almacenar valores en RAM. Estas posiciones de memoria se liberan tan pronto como termina la vida de la variable. Seg\u00fan la vida de las variables, hay tres tipos de Variables.</p> <ol> <li>Variables locales: La vida permanece dentro de un bloque donde se ha declarado.</li> <li>Variables de instancia: Declaradas dentro de la clase pero fuera de los m\u00e9todos. No deber\u00eda ser est\u00e1tico.</li> <li>Variables est\u00e1ticas: es como una variable global. Declarado como est\u00e1tico en la clase pero fuera de los m\u00e9todos.</li> </ol>"},{"location":"uutt/ut02/024_Variables.html#visibilidad","title":"Visibilidad","text":"<p>En las variables locales, su \u00e1mbito y uso se encuentra dentro del m\u00e9todo o bloque en el que se defini\u00f3 y se destruyen despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo. Es decir, no se puede usar una variable local fuera del m\u00e9todo actual. A las variables de instancia se puede acceder solo a trav\u00e9s de objetos de la clase para la que se defini\u00f3.</p> <p>Un campo / variable est\u00e1tico pertenece a la clase y se cargar\u00e1 en la memoria junto con la clase. Se invocan sin crear un objeto. (Usando el nombre de la clase como referencia). Solo hay una copia de la variable est\u00e1tica disponible en toda la clase, es decir, el valor de la variable est\u00e1tica ser\u00e1 el mismo en todos los objetos. Puede definir una variable est\u00e1tica utilizando la palabra clave static.</p>"},{"location":"uutt/ut02/024_Variables.html#scope-ambito","title":"Scope \u2013 \u00c1mbito","text":"<p>El alcance o \u00e1mbito (scope) de una variable es la parte de un programa en la que existe. En Java, el alcance de una variable comienza donde se declara y termina cuando se alcanza la llave de cierre del bloque que la contiene.</p> <p>Ejemplo</p> <pre><code>public static void main(String[] args) { \n    int x = 5;\n    for (int i = 1; i &lt;= 5; i++) {\n        int y = 10;\n        System.out.println(x) // \u00a1x todav\u00eda est\u00e1 dentro del alcance aqu\u00ed!\n    }\n    System.out.println(x) // \u00a1x todav\u00eda est\u00e1 dentro del alcance aqu\u00ed tambi\u00e9n! \n}\n</code></pre> <ul> <li>x est\u00e1 dentro del alcance entre su declaraci\u00f3n en la l\u00ednea 2 y la llave que la encierra en la l\u00ednea 8.</li> <li>y est\u00e1 dentro del alcance entre su declaraci\u00f3n en la l\u00ednea 4 y la llave que la encierra en la l\u00ednea 6.</li> <li>Las variables de bucle est\u00e1n dentro del alcance entre sus bucles for { }. Entonces, i est\u00e1 dentro del alcance entre las l\u00edneas 3 - 6. ```</li> </ul> <p>Dos variables con el mismo nombre no pueden existir dentro del mismo \u00e1mbito (<code>scope</code>).</p>"},{"location":"uutt/ut02/024_Variables.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 202 (RA1 / CE1e / IC1 / 3p) Escribe la declaraci\u00f3n para cada una de las variables y as\u00edgnales un valor inicial en la propia declaraci\u00f3n de variable.</p> <ul> <li>a. Variables enteras: p, q</li> <li>b. Variables float: x, y, z</li> <li>c. Variables car\u00e1cter: a, b, c</li> <li>d. Variables double: raiz1, raiz2</li> <li>e. Variable entera larga: contador</li> <li>f. Variable entera corta: indicador</li> <li>g. Variable entera: \u00edndice</li> <li>h. Variables double: precio, precioFinal</li> <li>i. Variables car\u00e1cter: car1, car2</li> <li>j. Variable tipo byte: valor</li> <li>k. Variables l\u00f3gicas: primero, ultimo</li> <li>l. Variable de tipo cadena de caracteres: nombre</li> </ul> </li> <li> <p>AC 203 (RA1 / CE1b CE1c CE1d CE1h / IC1 / 3p) Escribe la declaraci\u00f3n m\u00e1s apropiada para cada una de las siguientes variables. El nombre de cada una indica el tipo de dato que contendr\u00e1 y servir\u00e1 para determinar el tipo de dato m\u00e1s adecuado en la declaraci\u00f3n de la variable.</p> <ul> <li>a. edad</li> <li>b. c\u00f3digoPostal</li> <li>c. altura</li> <li>d. genero (valores: H: hombre, M: mujer) </li> <li>e. nombre</li> <li>f. n\u00fameroDeHijos</li> <li>g. iva (valores: % a aplicar)</li> <li>h. tallaCamisa (valores num\u00e9ricos)</li> <li>i. peso</li> <li>j. precio</li> <li>k. alumnoRepetidor (valores: SI/NO) </li> <li>l. mensaje</li> <li>m. letra</li> <li>n. mayorEdad</li> <li>o. minutos</li> <li>p. d\u00edas</li> <li>q. matriculaCoche</li> <li>r. contador</li> <li>s. mayorDeEdad (valores:V/F)</li> <li>t. tallaCamiseta (valores: S, L, XL...)</li> </ul> </li> <li> <p>PR 204 (RA1 / CE1b CE1c CE1h CE1i / IC2 / 5p) Escribe un programa que implemente el siguiente algoritmo descrito mediante diagrama de flujo y pseudoc\u00f3digo.</p> </li> </ul>"},{"location":"uutt/ut02/025_OperadoresExpresiones.html","title":"Operadores y expresiones","text":"<p>Los operadores son s\u00edmbolos especiales en Java que realizan operaciones entre uno o varios operandos y devuelve un resultado. Uno de los m\u00e1s usados es el operador suma (+) como ya hemos visto.</p> <ul> <li>Operando: Es cualquier t\u00e9rmino, que puede ser una variable o valor y que es manipulado por un operador.</li> <li>Expresi\u00f3n: Es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor.</li> </ul> <p>Java examina la expresi\u00f3n de la derecha del signo igual y realiza el c\u00e1lculo de una expresi\u00f3n matem\u00e1tica. Despu\u00e9s asigna ese valor a la variable resultado. Podr\u00edamos complicar m\u00e1s la expresi\u00f3n utilizando operadores como par\u00e9ntesis, multiplicaciones, divisiones, etc.</p> <p>Las partes de una expresi\u00f3n deben estar ordenadas correctamente. Las reglas para las expresiones Java correctas son casi las mismas que las del \u00e1lgebra:</p> <ol> <li>Cada operador debe tener el n\u00famero correcto de operandos.<ul> <li>Multiplicaci\u00f3n *, Divisi\u00f3n /, Suma +, Resta: debe tener dos operandos, uno en cada lado.</li> <li>La negaci\u00f3n - y unario m\u00e1s + deben ir seguidos de un operando.</li> </ul> </li> <li>Los par\u00e9ntesis () pueden rodear una expresi\u00f3n legal para convertirla en operando.</li> </ol>"},{"location":"uutt/ut02/025_OperadoresExpresiones.html#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Se utilizan para realizar operaciones aritm\u00e9ticas simples.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n + Suma Realiza la suma de los operandos. - Resta Realiza la resta de los operandos * Producto Multiplica los operandos. / Divisi\u00f3n Realiza la divisi\u00f3n. % M\u00f3dulo Calcula el resto."},{"location":"uutt/ut02/025_OperadoresExpresiones.html#operadores-relacionales","title":"Operadores relacionales","text":"<p>Estos operadores se utilizan para verificar relaciones como igualdad, mayor que, menor que. Devuelven el resultado booleano despu\u00e9s de la comparaci\u00f3n.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n == Igual a Devuelve verdadero si el valor de la izquierda del s\u00edmbolo es igual al de la derecha. != Distinto a Devuelve verdadero si el valor de la izquierda es distinto al de la derecha. &lt; Menor que Devuelve verdadero si el valor de la izquierda es menor que el de la derecha. &lt;= Menor o igual que Devuelve verdadero si el valor de la izquierda es menor o igual que el de la derecha. &gt; Mayor que Devuelve verdadero si el valor de la izquierda es mayor que el de la derecha. &gt;= Mayor o igual que Devuelve verdadero si el valor de la izquierda es mayor o igual al de la derecha."},{"location":"uutt/ut02/025_OperadoresExpresiones.html#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Estos operadores se utilizan para realizar operaciones l\u00f3gicas AND y OR. Se usa ampliamente en sentencias if-then o bucles para verificar condiciones, establecer un punto de salida de un bucle o la toma de decisiones.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n &amp;&amp; AND l\u00f3gico Devuelve verdadero cuando ambas condiciones son ciertas. <code>||</code> OR l\u00f3gico Devuelve verdadero si al menos una condici\u00f3n es cierta. <pre><code>int a = 20, b = 10, c= 10;\nSystem.out.println((b == c &amp;&amp; a == c)); //False \nSystem.out.println((a == c &amp;&amp; b == c)); //False \nSystem.out.println((a == b || b == c)); //True\n</code></pre>"},{"location":"uutt/ut02/025_OperadoresExpresiones.html#operadores-unitarios-o-unarios","title":"Operadores unitarios o unarios","text":"<p>Los operadores unarios solo necesitan un operando. Se usan para incrementar, disminuir o negar un valor.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n ++ Incremento Incrementa el valor en 1 unidad. -- Decremento El valor disminuye en 1 unidad. ! NOT l\u00f3gico Invierte un valor booleano. <p>Existen dos versiones de estos operadores:</p> <ul> <li> <p>Pre-incremento y pre-decremento. El valor se aumenta/disminuye primero y luego se calcula el resultado.</p> <pre><code>int a = 8, b = 1;\nb = ++a; //b=9, a=9\n</code></pre> </li> <li> <p>Post-Incremento y post-decremento: el valor se usa por primera vez para calcular el resultado y luego se incrementa o decrementa.</p> <pre><code>int a = 8, b = 1;\nb = a++;//b = 8, a = 9\n</code></pre> </li> </ul>"},{"location":"uutt/ut02/025_OperadoresExpresiones.html#operadores-de-bits","title":"Operadores de bits","text":"S\u00edmbolo Operaci\u00f3n Descripci\u00f3n &amp; AND Si ambos bits de entrada son 1, establece como resultado 1. De lo contrario 0. <code>||</code> OR Si por lo menos uno de los bits de entrada es 1, establece como resultado 1. De lo contrario 0. ^ XOR Si uno de los bits de entrada es 1 y el otro 0, establece como resultado 1. Si los bits son iguales establece 0. ~ NOT Invierte todos los bits y devuelve el resultado en complemento a 2."},{"location":"uutt/ut02/025_OperadoresExpresiones.html#operadores-de-asignacion","title":"Operadores de asignaci\u00f3n","text":"<p>Es uno de los operadores m\u00e1s usados, se representa con el s\u00edmbolo =. Se usa para asignar un valor a cualquier variable. Tiene una asociaci\u00f3n de derecha a izquierda, es decir, el valor dado en el lado derecho del operador se asigna a la variable de la izquierda y, por lo tanto, el valor del lado derecho debe declararse antes de usarlo o debe ser una constante. En muchos casos, el operador de asignaci\u00f3n se puede combinar con otros operadores para construir una versi\u00f3n m\u00e1s corta de la declaraci\u00f3n llamada Declaraci\u00f3n Compuesta (Compound Statement).</p> <ul> <li><code>+=</code>, para sumar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. <pre><code>int a = 5;\na += 5; // a = a + 5;\n</code></pre></li> <li><code>\u2013 =</code>, para restar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. <pre><code>int a = 5;\na -= 5; // a = a - 5;\n</code></pre></li> <li><code>*=</code>, para multiplicar el operando izquierdo con el operando derecho y luego asign\u00e1ndolo a la variable de la izquierda. <pre><code>int a = 5;\na *= 5; // a = a * 5;\n</code></pre></li> <li><code>/ =</code>, para dividir el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. <pre><code>int a = 5;\na /= 5; // a = a / 5;\n</code></pre></li> <li><code>% =</code>, para asignar el m\u00f3dulo del operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. <pre><code>int a = 5;\na %= 5; // a = a % 5;\n</code></pre></li> </ul>"},{"location":"uutt/ut02/025_OperadoresExpresiones.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 205 (RA1 / CE1b CE1c CE1d CE1h / IC1 / 3p) Escribe un programa que calcule y muestre por pantalla: </p> <ul> <li>a. El \u00e1rea de un cuadrado de lado 5cm.</li> <li>b. El per\u00edmetro de un rect\u00e1ngulo cuyas medidas son 8x4. </li> <li>c. El \u00e1rea de un tri\u00e1ngulo, b = 18cm, h = 15cm.</li> <li>d. El \u00e1rea y per\u00edmetro de un c\u00edrculo, radio = 7.5 cm.</li> </ul> </li> <li> <p>AR 206 (RA1 / CE1h / IC1 / 3p) Calcula las siguientes expresiones y a\u00f1ade el tipo de dato que devuelve la expresi\u00f3n.</p> <ul> <li>12 / 3</li> <li>12 / 8</li> <li>11.0 / 6.0</li> <li>2.0 / 4.0</li> <li>1.0 / 2.0 </li> <li>12 / 6 </li> <li>11 / 2</li> </ul> </li> </ul>"},{"location":"uutt/ut02/026_Precendia.html","title":"Precedencia","text":"<p>El orden de precedencia, es decir, como Java decide la prioridad al evaluar los operadores en una expresi\u00f3n:</p> <p>A mayor n\u00famero mayor es la prioridad.</p>"},{"location":"uutt/ut02/027_Casting.html","title":"Conversiones de tipos (casting entre tipos nativos)","text":""},{"location":"uutt/ut02/027_Casting.html#conversiones-por-defecto","title":"Conversiones por defecto","text":"<p>Las reglas de Java para saber el tipo de datos resultante de una expresi\u00f3n se siguen las siguientes reglas</p> Si alg\u00fan operando es El otro operando se transforma a double double float float long long byte or short int <p>Si se aplican dos reglas, se elige la que aparece primero en la tabla.</p>"},{"location":"uutt/ut02/027_Casting.html#conversiones-forzosas-casting-entre-tipos-nativos","title":"Conversiones forzosas (casting entre tipos nativos)","text":"<p>Es una forma de convertir un n\u00famero de un tipo a otro tipo de dato. Para hacerlo ponemos en par\u00e9ntesis el tipo de dato al que queremos convertirlo.</p> <pre><code>byte miByte = (byte) (14 / 2); //convierto la operaci\u00f3n divisi\u00f3n que devuelve un int a byte //Otra forma\nfloat a = 8.0f;\nint b = 10;\nb = (int) a;//convierto el tipo float a int\n</code></pre>"},{"location":"uutt/ut02/028_Comentarios.html","title":"Comentarios en l\u00ednea y multil\u00ednea","text":"<p>Un comentario es un texto que se escribe dentro de un programa con el fin de facilitar la comprensi\u00f3n del mismo. Los comentarios se utilizan para explicar y documentar el c\u00f3digo fuente. En Java se pueden utilizar tres tipos de comentarios:</p> <ul> <li>Comentario tradicional estilo C/C++. Empieza con los caracteres <code>/*</code> y acaba con <code>*/</code>. Pueden ocupar m\u00e1s de una l\u00ednea y pueden aparecer en cualquier lugar donde pueda aparear un espacio en blanco. No pueden anidarse.</li> </ul> Ejemplos de comentarios estilo C/C++:<pre><code>/* Programa Ecuaci\u00f3n segundo grado\nCalcula las soluciones de una ecuaci\u00f3n de segundo grado */ \n/* Lectura de datos por teclado */\n</code></pre> <ul> <li>Comentarios de una sola l\u00ednea. Comienzan con una doble barra ( <code>//</code> ) y se pueden extender hasta el final de la l\u00ednea. No tienen car\u00e1cter de terminaci\u00f3n.</li> </ul> Ejemplos de comentarios de una sola l\u00ednea<pre><code>// Programa Ecuaci\u00f3n segundo grado\n// Calcula las soluciones de una ecuaci\u00f3n de segundo grado int p; \n// precio del producto\n</code></pre> <ul> <li>Comentarios para documentaci\u00f3n. Realmente este tipo de comentario es el mismo que el de varias l\u00edneas con la diferencia de que la informaci\u00f3n que contenga ser\u00e1 usada para un procesamiento especial que lleva a cabo la herramienta <code>javadoc</code>. Se distingue del comentario de varias l\u00edneas porque se agrega un asterisco adicional al inicio del comentario.</li> </ul> <pre><code>/**\nEste tipo de comentarios los utiliza la\nherramienta javadoc\n*/\n</code></pre>"},{"location":"uutt/ut02/029_IOConsola.html","title":"Entrada y salida de datos por consola","text":"<p>Java viene con una biblioteca de clases que se puede usar para realizar tareas comunes. La biblioteca de clases de Java est\u00e1 organizada en un conjunto de paquetes, donde cada paquete contiene una colecci\u00f3n de clases relacionadas. En esta secci\u00f3n presentamos las clases System y Scanner que se utilizan para imprimir la salida y leer la entrada de un programa.</p> <p>El tipo m\u00e1s simple de interfaz de usuario es la interfaz de l\u00ednea de comandos, en la que la entrada se toma de la l\u00ednea de comandos a trav\u00e9s del teclado y la salida se muestra en la consola. Algunas aplicaciones Java utilizan este tipo de interfaz otros usan interfaz gr\u00e1fica como veremos m\u00e1s adelante.</p>"},{"location":"uutt/ut02/029_IOConsola.html#salida-de-la-informacion","title":"Salida de la informaci\u00f3n","text":"<p>En Java, cualquier origen o destino de I/O se considera un flujo de bytes o caracteres. Para realizar la salida, insertamos bytes o caracteres en la secuencia. Para realizar la entrada, extraemos bytes o caracteres del flujo (<code>stream</code>). Incluso los caracteres introducidos en un teclado, si se consideran como una secuencia de pulsaciones de teclas, se pueden representar como un stream.</p> <p>En Java, la I/O se maneja a trav\u00e9s de m\u00e9todos que pertenecen a clases contenidas en el paquete <code>java.io</code>. Ya hemos visto c\u00f3mo se usa el m\u00e9todo de salida <code>println()</code> para enviar una cadena a la consola.</p> <p>Los objetos <code>System.out</code> y <code>System.err</code> se pueden usar para escribir la salida en la consola. Como sugiere su nombre, el flujo de errores se usa principalmente para mensajes de error, mientras que el flujo de salida se usa para otras salidas impresas.</p> <p>La \u00fanica diferencia entre los m\u00e9todos <code>print()</code> y <code>println()</code> es que <code>println()</code> tambi\u00e9n imprimir\u00e1 un retorno de carro y un avance de l\u00ednea despu\u00e9s de imprimir sus datos, lo que permitir\u00e1 que la salida posterior se imprima en una nueva l\u00ednea.</p> <pre><code>System.out.print(\"Hola\"); \nSystem.out.print(\"mundo\"): \nSystem.out.println(\"Texto con salto de l\u00ednea\"); \nSystem.out.println(\"adi\u00f3s\");\n\nSalida:\n\nHolamundoTexto con salto de l\u00ednea \nadi\u00f3s\n</code></pre>"},{"location":"uutt/ut02/029_IOConsola.html#entrada-de-la-informacion","title":"Entrada de la informaci\u00f3n","text":"<p>Se ha agregado la clase <code>Scanner</code> al paquete <code>java.util</code> que permite la entrada de teclado sin forzar el programador para manejar las excepciones. La clase Scanner est\u00e1 dise\u00f1ada para ser una forma muy flexible de reconocer fragmentos de datos que se ajustan a patrones espec\u00edficos de cualquier flujo de entrada.</p> <p>Para usar la clase Scanner para la entrada de teclado, debemos crear una instancia de <code>Scanner</code> y asociarla con <code>System.in</code>. La clase tiene un constructor para este prop\u00f3sito, por lo que la declaraci\u00f3n</p> <pre><code>Scanner sc = new Scanner(System.in);\n</code></pre> <p>declara y crea una instancia de un objeto que se puede utilizar para la entrada del teclado. Despu\u00e9s de crear un objeto <code>Scanner</code>, podemos hacer una llamada a <code>nextInt()</code>, <code>nextDouble()</code>, o <code>next()</code> para leer, respectivamente, un entero, un n\u00famero real, o String del teclado.</p> <pre><code>public static void main(String[] args) {\nScanner sc = new Scanner (System.in); \nSystem.out.print(\"Introduce un n\u00famero: \");\nint num = sc.nextInt();//Read the integer \nSystem.out.println(\"El n\u00famero introducido es: \" + num);\n}\n</code></pre> <p>Cuando se ejecuta el m\u00e9todo <code>nextInt()</code>, no se ejecutan m\u00e1s declaraciones hasta que el m\u00e9todo devuelve un valor <code>int</code>. Normalmente, esto no sucede hasta que el usuario ha escrito los d\u00edgitos de un n\u00famero entero y presiona la tecla Intro.</p> <p>Para leer un String utilizamos el m\u00e9todo <code>next()</code>.</p> <p><pre><code>public static void main(String[] args) {\nScanner sc = new Scanner (System.in); \nSystem.out.print(\"Introduce una palabra: \");\nString str = sc.next();\nSystem.out.println(str);\n}\n</code></pre> Un objeto Scanner tiene un conjunto de cadenas de caracteres que separan o delimitan los fragmentos de datos que est\u00e1 buscando. De forma predeterminada, este conjunto de delimitadores consta de cualquier secuencia no vac\u00eda de caracteres en blanco, es decir, los caracteres de espacio, tabulaci\u00f3n, retorno y nueva l\u00ednea. Esto permitir\u00e1 al usuario ingresar varios n\u00fameros enteros separados por espacios antes de presionar la tecla Enter. En c\u00f3digo ser\u00eda:</p> <pre><code>System.out.print(\"Introduce dos n\u00fameros: \"); \nint num = sc.nextInt();\nint num2 = sc.nextInt();\n</code></pre> <p>Los espacios en blanco como delimitadores tambi\u00e9n significan que el m\u00e9todo <code>next()</code> no puede devolver una cadena vac\u00eda ni puede devolver una cadena que contenga espacios. Por ejemplo, considere el c\u00f3digo:</p> <p><pre><code>System.out.print(\"Introduce un texto separado por espacio en blanco: \"); \nString str = sc.next();\n</code></pre> Si se escribe \"Hola mundo\" y se presiona la tecla enter, la cadena str almacenar\u00e1 s\u00f3lo \"Hola\". Para que un objeto Scanner lea cadenas que contienen espacios, debemos usar el m\u00e9todo <code>nextLine()</code>:</p> <pre><code>String str = sc.nextLine();\n</code></pre>"},{"location":"uutt/ut02/029_IOConsola.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 207 (RA1 / CE1e / IC1 / 3p) Escribe un programa que intercambie el valor de dos variables introducidas por entrada </p> </li> <li> <p>AC 208 (RA1 / CE1f CE1i / IC1 / 3p) Crea el siguiente men\u00fa utilizando las librer\u00edas de entrada/salida (input/output):</p> <p><pre><code>*****MEN\u00da DE SELECCI\u00d3N***** \n***** 1. A\u00f1adir un entrante.*****\n***** 2. A\u00f1adir un plato principal.***** \n***** 3. Elegir postre.*****\n***** 4. No sentarme en este restaurante porque...*****\n</code></pre> Elige una opci\u00f3n: El usuario debe elegir una opci\u00f3n por entrada de teclado. Se le deber\u00e1 mostrar el n\u00famero de la opci\u00f3n introducida.</p> </li> <li> <p>PR 209 (RA1 / CE1b CE1c CE1h CE1i / IC2 / 5p) Escribe un programa que solicite tus apellidos, los asigne a variables e intercambie los valores de estas variables. En este caso para asignar valores a las variables de tipo <code>String</code> deber\u00e1s emplear el m\u00e9todo <code>nextLine()</code> de la clase Scanner.</p> </li> <li> <p>PR 210 (RA1 / CE1b CE1c CE1h CE1i / IC2 / 5p) Escribe un programa llamado <code>A\u00f1oMesDia</code> que tome como argumento una cantidad de d\u00edas y calcule a cu\u00e1ntos a\u00f1os, meses y d\u00edas corresponde. Realiza la suposici\u00f3n de que todos los meses tienen 30 d\u00edas.</p> </li> <li> <p>PR 211 (RA1 / CE1b CE1c CE1h CE1i / IC2 / 5p) Escribe un programa que solicite el valor del lado de un tri\u00e1ngulo equil\u00e1tero (los 3 lados son de igual longitud). Este lado debe almacenarse en una variable de tipo double. El programa calcular\u00e1 el \u00e1rea y el per\u00edmetro del tri\u00e1ngulo equil\u00e1tero. El \u00e1rea de cualquier tri\u00e1ngulo se calcula mediante la f\u00f3rmula: \u00e1\ud835\udc5f\ud835\udc52\ud835\udc4e = (\ud835\udc4f\ud835\udc4e\ud835\udc60\ud835\udc52 \u00d7 \ud835\udc4e\ud835\udc59\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc4e)/ 2 La altura de un tri\u00e1ngulo equil\u00e1tero se calcula mediante la f\u00f3rmula: \ud835\udc4e\ud835\udc59\ud835\udc61 = (\ud835\udc59\ud835\udc4e\ud835\udc51\ud835\udc5c \u00d7 \u221a3)/ 2. Para calcular la ra\u00edz cuadrada se utilizar\u00e1 la expresi\u00f3n <code>Math.sqrt(n\u00famero)</code></p> </li> </ul> <p>PR211</p> <p>Nota 1: Aunque no se debe mostrar la altura por pantalla, es recomendable guardar su valor en una variable. De esta manera, se simplificar\u00e1 el c\u00e1lculo posterior del \u00e1rea.</p> <p>Nota 2: Ante cualquier duda sobre la prioridad de operadores, utiliza los par\u00e9ntesis. De esta manera te asegurar\u00e1 que el c\u00e1lculo se realiza correctamente.</p>"},{"location":"uutt/ut02/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 02","text":""},{"location":"uutt/ut02/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA1.CE <ul> <li>Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado.</li> </ul> <ul> <li>b. Se han creado proyectos de desarrollo de aplicaciones.</li> <li>c. Se han utilizado entornos integrados de desarrollo.</li> <li>d. Se han identificado los distintos tipos de variables y la utilidad espec\u00edfica de cada uno.</li> <li>e. Se ha modificado el c\u00f3digo de un programa para crear y utilizar variables.</li> <li>f.  Se han creado y utilizado constantes y literales.</li> <li>g. Se han clasificado, reconocido y utilizado en expresiones los operadores del lenguaje.</li> <li>h. Se ha comprobado el funcionamiento de las conversiones de tipo expl\u00edcitas e impl\u00edcitas.</li> <li>i.  Se han introducido comentarios en el c\u00f3digo.</li> </ul>"},{"location":"uutt/ut02/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li> <p>Tipos de datos</p> <ol> <li>Tipos nativos</li> <li>String</li> <li>Date</li> </ol> </li> <li> <p>Constantes y literales</p> <ol> <li>Las constantes</li> <li>Los literales</li> <li>Palabras reservadas</li> </ol> </li> <li> <p>Variables</p> <ol> <li>Visibilidad y vida de las variables</li> </ol> </li> <li> <p>Operadores y expresiones</p> <ol> <li>Operadores aritm\u00e9ticos</li> <li>Operadores relacionales</li> <li>Operadores l\u00f3gicos</li> <li>Operadores unitarios o unarios</li> <li>Operadores de bits</li> <li>Operadores de asignaci\u00f3n</li> </ol> </li> <li> <p>Precedencia de operadores</p> </li> <li>Conversiones de tipos (casting entre tipos nativos)</li> <li>Comentarios en l\u00ednea y multil\u00ednea</li> <li>Programaci\u00f3n de la consola: entrada y salida de informaci\u00f3n</li> </ol>"},{"location":"uutt/ut02/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>16/09/2024</p> <p>2.1. Tipos de datos </p> <p>AC201</p> <p>02</p> <p>16/09/2024</p> <p>2.2. Manejo de fechas 2.3. Constantes y literales </p> <p></p> <p>03</p> <p>17/09/2024</p> <p>2.4. Variables</p> <p>AC 202AC 203PR 204</p> <p>04</p> <p>18/09/2024</p> <p>2.5. Operadores y expresiones 2.6. Precedencia  </p> <p>AC 205</p> <p>05</p> <p>18/09/2024</p> <p>2.7. Casting 2.8. Comentarios  </p> <p></p> <p>06</p> <p>19/09/2024</p> <p>2.9. Entrada y salida por consola </p> <p>AC 207AC 208</p> <p>07</p> <p>19/09/2024</p> <p></p> <p>PR 209PR 210PR 211</p> <p>08</p> <p>20/09/2024</p> <p></p> <p>PO UT 02</p>"},{"location":"uutt/ut02/ResumenUT.html#referencias","title":"Referencias","text":"<ul> <li>Web: Java 15. Precedencia de los Operadores Aritm\u00e9ticos en Java: Una Gu\u00eda Completa </li> <li>V\u00eddeo: Operadores L\u00f3gicos y Relacionales </li> <li>V\u00eddeo: VARIABLES en Java \u2615 Todo lo que ten\u00e9s que saber \u2705 </li> </ul>"},{"location":"uutt/ut02/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":"<ul> <li>Web: Precedencia del operador</li> </ul>"},{"location":"uutt/ut03/031_EstructuraSecuencial.html","title":"Estructura Secuencial","text":"<p>El orden en que se ejecutan por defecto las sentencias de un programa es secuencial. Esto significa que las sentencias se ejecutan en secuencia, una despu\u00e9s de otra, en el orden en que aparecen escritas dentro del programa.</p> <p>Cada una de las instrucciones est\u00e1n separadas por el car\u00e1cter punto y coma (<code>;</code>). Las instrucciones se suelen agrupar en bloques.</p> <pre><code>/* Programa que lee dos n\u00fameros por teclado y los muestre por pantalla. */\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args){\n        //declaraci\u00f3n de variables\n        int n1, n2;\n        Scanner sc = new Scanner(System.in);\n        //leer el primer n\u00famero\n        System.out.println(\"Introduce un n\u00famero entero: \");\n        n1 = sc.nextInt(); //lee un entero por teclado\n        //leer el segundo n\u00famero\n        System.out.println(\"Introduce otro n\u00famero entero: \");\n        n2 = sc.nextInt(); //lee un entero por teclado\n        //mostrar resultado\n        System.out.println(\"Ha introducido los n\u00fameros: \" + n1 + \" y \" + n2);\n    }\n}\n</code></pre> <p>Para modificar el orden de ejecuci\u00f3n de las instrucciones de un programa Java se utilizan las estructuras condicionales y repetitivas.</p>"},{"location":"uutt/ut03/032_EstructuraSeleccion.html","title":"Estructuras de selecci\u00f3n","text":"<p>La estructura condicional determina si se ejecutan unas instrucciones u otras seg\u00fan se cumpla o no una determinada condici\u00f3n.</p> <p>En Java la estructura condicional se implementa mediante:</p> <ul> <li>Instrucci\u00f3n <code>if</code>.</li> <li>Instrucci\u00f3n <code>switch</code>.</li> <li>Instrucci\u00f3n condicional <code>? :</code></li> </ul>"},{"location":"uutt/ut03/032_EstructuraSeleccion.html#if","title":"if","text":"<p>La declaraci\u00f3n <code>if</code> es la m\u00e1s b\u00e1sica de todas las declaraciones de flujo de control. Le dice a su programa que ejecute una determinada secci\u00f3n de c\u00f3digo solo si una prueba en particular se eval\u00faa como verdadera. Puede ser del tipo:</p> <ul> <li>Condicional simple: <code>if</code></li> <li>Condicional doble: <code>if \u2026 else \u2026</code></li> <li>Condicional m\u00faltiple: <code>if \u2026 else if \u2026</code></li> </ul> <p>La condici\u00f3n debe ser una expresi\u00f3n booleana es decir debe dar como resultado un valor booleano (<code>true</code> o <code>false</code>). </p>"},{"location":"uutt/ut03/032_EstructuraSeleccion.html#condicional-simple","title":"Condicional simple","text":"<p>Se eval\u00faa la condici\u00f3n y si esta se cumple se ejecuta una determinada acci\u00f3n o grupo de acciones. En caso contrario se saltan dicho grupo de acciones.</p> <p>Si el bloque de instrucciones tiene una sola instrucci\u00f3n no es necesario escribir las llaves <code>{ }</code> aunque para evitar confusiones se recomienda escribir las llaves siempre.</p> <pre><code>/* Programa que pide una nota por teclado y muestra un mensaje si la nota * es mayor o igual que 5 */\nimport java.util.Scanner;\npublic class Ejemplo0If {\n    public static void main(String[] args ){\n        Scanner sc = new Scanner(System.in );\n        System.out.print(\"Nota: \");\n        int nota = sc.nextInt();\n        if (nota &gt;= 5){\n            System.out.println(\"\u00a1\u00a1Enhorabuena!!\");\n            System.out.println(\"Has aprobado\");\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut03/032_EstructuraSeleccion.html#condicional-doble","title":"Condicional doble","text":"<p>Se eval\u00faa la condici\u00f3n y si esta se cumple se ejecuta una determinada instrucci\u00f3n o grupo de instrucciones. Si no se cumple se ejecuta otra instrucci\u00f3n o grupo de instrucciones.</p> <pre><code>/* Programa que pide una nota por teclado y muestra si se ha aprobado o no */\nimport java.util.Scanner;\npublic class Ejemplo0If {\n    public static void main( String[] args ){\n        Scanner sc = new Scanner( System.in );\n        System.out.print(\"Nota: \");\n        int nota = sc.nextInt();\n        if (nota &gt;= 5){\n            System.out.println(\"Enorabuena!!\");\n            System.out.println(\"Has aprobado\");\n        } else{\n            System.out.println(\"Lo Siento, has suspendido\");\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut03/032_EstructuraSeleccion.html#condicional-multiple","title":"Condicional m\u00faltiple","text":"<p>Se obtiene anidando sentencias <code>if \u2026 else</code>. Permite construir estructuras de selecci\u00f3n m\u00e1s complejas.</p> <p>Cada <code>else</code> se corresponde con el <code>if</code> m\u00e1s pr\u00f3ximo que no haya sido emparejado. Una vez que se ejecuta un bloque de instrucciones, la ejecuci\u00f3n contin\u00faa en la siguiente instrucci\u00f3n que aparezca despu\u00e9s de las sentencias <code>if \u2026 else</code> anidadas.</p> <pre><code>/* Programa que muestra un saludo distinto seg\u00fan la hora introducida */\nimport java.util.Scanner;\npublic class Ejemplo2If {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int hora;\n        System.out.println(\"Introduzca una hora (un valor entero): \");\n        hora = sc.nextInt();\n        if (hora &gt;= 0 &amp;&amp; hora &lt; 12){\n            System.out.println(\"Buenos d\u00edas\");\n        }else if (hora &gt;= 12 &amp;&amp; hora &lt; 21){\n            System.out.println(\"Buenas tardes\");\n        }else if (hora &gt;= 21 &amp;&amp; hora &lt; 24){\n            System.out.println(\"Buenas noches\");\n        }else{\n            System.out.println(\"Hora no v\u00e1lida\");\n        }\n    }\n}\n</code></pre> <p>Un correcto uso de if junto con else, nos permitir\u00e1 tener un control sobre las posibilidades que tiene que tener nuestro algoritmo. El concepto es que se emplee la parte del else como el valor por defecto o el valor que queremos mostrar u obtener si no ha ido bien la cosa o los datos no son v\u00e1lidos. Esto es una forma de tener un control de excepciones, que los veremos en profundidad a lo largo del curso.</p>"},{"location":"uutt/ut03/032_EstructuraSeleccion.html#switch","title":"Switch","text":"<p>Se utiliza para seleccionar una de entre m\u00faltiples alternativas. La forma general de la instrucci\u00f3n switch en Java es la siguiente:</p> <p>La instrucci\u00f3n switch se puede usar con datos de tipo byte, short, char e int. A partir de Java 7 tambi\u00e9n pueden usarse datos de tipo String en un switch. Funcionamiento de la instrucci\u00f3n switch:</p> <ul> <li>Primero se eval\u00faa la expresi\u00f3n y salta al case cuya constante coincida con el valor de la expresi\u00f3n.</li> <li>Se ejecutan las instrucciones que siguen al case seleccionado hasta que se encuentra un break o hasta el final del switch. El break produce un salto a la siguiente instrucci\u00f3n a continuaci\u00f3n del switch.</li> <li>Si ninguno de estos casos se cumple se ejecuta el bloque default (si existe). No es obligatorio que exista un bloque default y no tiene porqu\u00e9 ponerse siempre al final, aunque es lo habitual.</li> </ul> <pre><code>/* Programa que pide un n\u00famero de mes y muestra el nombre correspondiente */\nimport java.util.Scanner;\npublic class Ejemplo0Switch {\n    public static void main(String[] args) {\n        int mes;\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Introduzca un numero de mes: \");\n        mes = sc.nextInt();\n        switch (mes){\n            case 1: System.out.println(\"ENERO\");\n                break;\n            case 2: System.out.println(\"FEBRERO\");\n                break;\n            case 3: System.out.println(\"MARZO\");\n                break;\n            case 4: System.out.println(\"ABRIL\");\n                break;\n            case 5: System.out.println(\"MAYO\");\n                break;\n            case 6: System.out.println(\"JUNIO\");\n                break;\n            case 7: System.out.println(\"JULIO\");\n                break;\n            case 8: System.out.println(\"AGOSTO\");\n                break;\n            case 9: System.out.println(\"SEPTIEMBRE\");\n                break;\n            case 10: System.out.println(\"OCTUBRE\");\n                break;\n            case 11: System.out.println(\"NOVIEMBRE\");\n                break;\n            case 12: System.out.println(\"DICIEMBRE\");\n                break;\n            default: System.out.println(\"Mes no v\u00e1lido\");\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut03/032_EstructuraSeleccion.html#instruccion-condicional","title":"Instrucci\u00f3n condicional","text":"<p>Se puede utilizar en sustituci\u00f3n de la sentencia de control <code>if-else</code>. Mediante los caracteres <code>?</code> y <code>:</code> Se utiliza de la forma siguiente:</p> <pre><code>expresi\u00f3n1 ? expresi\u00f3n2 : expresi\u00f3n3\n</code></pre> <p>Si expresi\u00f3n1 es cierta entonces se eval\u00faa expresi\u00f3n2 y \u00e9ste ser\u00e1 el valor de la expresi\u00f3n condicional. Si expresi\u00f3n1 es falsa, se eval\u00faa expresi\u00f3n3 y \u00e9ste ser\u00e1 el valor de la expresi\u00f3n condicional.</p> <pre><code>/* programa que pide un n\u00famero por teclado y calcula si es par o impar */\nimport java.util.Scanner;\npublic class Ejemplo1OperadorCondicional {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int num; System.out.println(\"Introduzca numero: \");\n        num = sc.nextInt(); System.out.println((num % 2) == 0 ? \"PAR\" : \"IMPAR\");\n    }\n}\n</code></pre>"},{"location":"uutt/ut03/032_EstructuraSeleccion.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 301 (RA3 / CE3a CE3g / IC1 / 3p) En la taquilla de un cine, a una persona menor de 13 a\u00f1os se le cobra la \"tarifa para ni\u00f1os\". De lo contrario, a una persona se le cobra la \"tarifa de adulto\". Completa un programa para que a una persona menor de 13 a\u00f1os se le cobre la tarifa de ni\u00f1o, con mostrar un mensaje ser\u00e1 suficiente.</p> </li> <li> <p>AR 302 (RA3 / CE3a CE3g / IC1 / 3p) Un hipermercado quiere un programa que calcule el impuesto sobre un aparato electr\u00f3nico. Un art\u00edculo que cuesta 300\u20ac o m\u00e1s tiene un impuesto del 5% (0.05); y un art\u00edculo que cuesta menos de 300\u20ac est\u00e1 libre de impuestos. Desarrolla un programa que solicite por teclado un precio, luego calcule e imprima el impuesto y luego imprima el coste total (precio + impuesto).</p> </li> <li> <p>AC 303 (RA3 / CE3a CE3g / IC1 / 3p) Quiero alquilar un coche en una agencia de alquiler de coches. Las condiciones para alquilar un coche son: tener al menos 21 a\u00f1os o m\u00e1s y 10.000 o m\u00e1s euros de cr\u00e9dito en mi tarjeta. Escribe un programa que pida al usuario introducir su edad y su cr\u00e9dito disponible y verifique si es apto para alquilar un coche o no. Muestra un mensaje al usuario de si es apto. </p> <ul> <li>\u00bfPodr\u00eda alguien con 25 a\u00f1os y 10.000 \u20ac alquilar un coche? </li> <li>\u00bfY alguien con 21 a\u00f1os y 9000\u20ac? </li> <li>\u00bfQu\u00e9 pasar\u00eda si cambiamos el y por un o, es decir, tener 21 a\u00f1os o m\u00e1s o tener 10.000? </li> </ul> <p>Explica c\u00f3mo afectar\u00eda a las preguntas anteriores, si obtendr\u00edamos el mismo resultado.</p> </li> <li> <p>AC 304 (RA3 / CE3a CE3g / IC1 / 3p) Los sabores de helado se representan como n\u00fameros enteros, donde 0 es vainilla, 1 es chocolate y 2 es fresa. Escribe un switch que pida al usuario un sabor de helado por pantalla y verifique el sabor e imprima el nombre del sabor del helado o imprima \"Error\" en el caso predeterminado.</p> </li> <li> <p>AP 305 (RA3 / CE3a CE3g / IC1 / 3p) El director de una escuela est\u00e1 organizando un viaje de estudios, y requiere determinar cu\u00e1nto debe cobrar a cada alumno y cu\u00e1nto debe pagar a la compa\u00f1\u00eda de viajes por el servicio.</p> <p>La forma de cobrar es la siguiente: si son 100 alumnos o m\u00e1s, el costo por cada alumno es de 65.0 euros; de 50 a 99 alumnos, el costo es de 70.5 euros, de 30 a 49, de 95.0 euros, y si son menos de 30, el costo del alquiler del autob\u00fas es de 400.0 euros, sin importar el n\u00famero de alumnos.</p> <p>Realiza un programa que permita determinar el pago a la compa\u00f1\u00eda de autobuses y lo que debe pagar cada alumno por el viaje. Al realizar un an\u00e1lisis del problema, se puede deducir que las variables que se requieren como datos son el n\u00famero de alumnos (NA) que se introducir\u00e1n por entrada est\u00e1ndar (mediante la clase Scanner), con lo que se puede calcular el pago por alumno (PA) y el costo total del viaje (TOT), que deber\u00e1n ser mostrados por salida est\u00e1ndar (impresi\u00f3n por pantalla). Determina qu\u00e9 tipo de dato es m\u00e1s adecuado para cada variable.</p> </li> <li> <p>PR 306 (RA3 / CE3a CE3f CE3g / IC2 / 5p) Crea un programa que lea por teclado tres n\u00fameros enteros, calcule el mayor de los tres y lo muestre por salida est\u00e1ndar.</p> </li> <li> <p>PR 307 (RA3 / CE3a CE3f CE3g / IC2 / 5p) Crea un programa que solicite un n\u00famero de mes, calcule la estaci\u00f3n a la que pertenece y la muestre por pantalla.</p> </li> <li> <p>PR 308 (RA3 / CE3a CE3f CE3g / IC2 / 5p) Crea un programa que permita adivinar un n\u00famero aleatorio entre 0 y 100. El usuario va introduciendo n\u00fameros y el programa le indicar\u00e1 si el n\u00famero buscado es mayor o menor que el introducido. El proceso finaliza cuando el usuario acierta mostr\u00e1ndose el n\u00famero de intentos. </p> <p>Info</p> <p>Para que el programa genere un n\u00famero al azar utilizamos el m\u00e9todo random() que genera un n\u00famero aleatorio entre 0 y 1. Entonces lo multiplicaremos por 100 y lo convertiremos a entero mediante el mecanismo de casting de tipos.</p> </li> </ul>"},{"location":"uutt/ut03/033_EstructuraRepeticion.html","title":"Estructuras de repetici\u00f3n","text":"<p>Permiten ejecutar de forma repetida un bloque espec\u00edfico de instrucciones. Las instrucciones se repiten mientras o hasta que se cumpla una determinada condici\u00f3n. Esta condici\u00f3n se conoce como condici\u00f3n de salida. Tipos de estructuras repetitivas:</p> <ul> <li>Ciclo while.</li> <li>Ciclo do \u2013 while.</li> <li>Ciclo for.</li> </ul>"},{"location":"uutt/ut03/033_EstructuraRepeticion.html#bucle-while","title":"Bucle while","text":"<p>Las instrucciones se repiten mientras la condici\u00f3n sea cierta. La condici\u00f3n se comprueba al principio del bucle por lo que las acciones se pueden ejecutar cero o m\u00e1s veces. La ejecuci\u00f3n del bucle while sigue los siguientes pasos:</p> <ol> <li>Primero se eval\u00faa la condici\u00f3n.</li> <li>Si el resultado es false, las instrucciones no se ejecutan y el programa sigue ejecut\u00e1ndose por la siguiente instrucci\u00f3n a continuaci\u00f3n del while.</li> <li>Si el resultado es true, se ejecutan las instrucciones del while y se vuelve al paso 1.</li> </ol> <pre><code>/* Programa que lee n\u00fameros hasta que se lee un negativo y muestra la * suma de los\nn\u00fameros le\u00eddos */\nimport java.util.Scanner;\npublic class Ejemplo1While {\n    public static void main(String[] args) {\n        int suma = 0, num;\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Introduzca un n\u00famero: \");\n        num = sc.nextInt();\n        while (num &gt;= 0){\n            suma = suma + num;\n            System.out.print(\"Introduzca un n\u00famero: \");\n            num = sc.nextInt();\n        }\n        System.out.println(\"La suma es: \" + suma );\n    }\n}\n</code></pre>"},{"location":"uutt/ut03/033_EstructuraRepeticion.html#bucle-do-while","title":"Bucle do-while","text":"<p>Las instrucciones se ejecutan mientras la condici\u00f3n sea cierta. La condici\u00f3n se comprueba al final del bucle, por lo que el bloque de instrucciones se ejecutar\u00e1 al menos una vez.</p> <p>Esta es la diferencia fundamental con la instrucci\u00f3n while. Las instrucciones de un bucle while no ejecutaban si la condici\u00f3n inicialmente era falsa. La ejecuci\u00f3n del bucle do - while sigue los siguientes pasos:</p> <ol> <li>Primero se ejecutan las instrucciones a partir de do{...</li> <li>Se eval\u00faa la condici\u00f3n.</li> <li>Si el resultado es false, el programa sigue ejecut\u00e1ndose por la siguiente instrucci\u00f3n a continuaci\u00f3n del while.</li> <li>Si el resultado es true, se vuelve al paso 1.</li> </ol> <pre><code>/* Programa que obliga al usuario a introducir un n\u00famero menor que 100 */\nimport java.util.Scaner;\npublic class Ejemplo1DoWhile {\n    public static void main(String[] args) {\n        int valor;\n        Scanner in = new Scanner(System.in);\n        do {\n            System.out.print(\"Escribe un entero &lt; 100: \");\n            valor = in.nextInt();\n        }while (valor &gt;= 100);\n        System.out.println(\"Ha introducido: \" + valor);\n\n    }\n}\n</code></pre>"},{"location":"uutt/ut03/033_EstructuraRepeticion.html#bucle-for","title":"Bucle for","text":"<p>La instrucci\u00f3n for hace que una instrucci\u00f3n o bloque de instrucciones se repitan un n\u00famero determinado de veces mientras se cumpla la condici\u00f3n. La estructura general de una instrucci\u00f3n for en Java es la siguiente:</p> <pre><code>for(inicializaci\u00f3n; condici\u00f3n; incremento/decremento){\n    instrucci\u00f3n 1;\n    ...........\n    instrucci\u00f3n N;\n}\n</code></pre> <p>A continuaci\u00f3n de la palabra for y entre par\u00e9ntesis debe haber siempre tres zonas separadas por punto y coma:</p> <ul> <li>zona de inicializaci\u00f3n.</li> <li>zona de condici\u00f3n o evaluaci\u00f3n.</li> <li>zona de incremento o decremento.</li> </ul> <p>Si en alguna ocasi\u00f3n no es necesario escribir alguna de ellas se pueden dejar en blanco, pero los dos punto y coma deben aparecer.</p> <p>Inicializaci\u00f3n: es la parte en la que la variable o variables de control del bucle toman su valor inicial. Puede haber una o m\u00e1s instrucciones en la inicializaci\u00f3n, separadas por comas. La inicializaci\u00f3n se realiza una sola vez.</p> <p>Evaluaci\u00f3n: es una expresi\u00f3n booleana que hace que se ejecute la sentencia o bloque de sentencias mientras dicha expresi\u00f3n sea cierta. Generalmente en la condici\u00f3n se compara la variable de control con un valor l\u00edmite.</p> <p>Incremento/decremento: es una expresi\u00f3n que decrementa o incrementa la variable o variables de control de bucle.</p> <p></p> <p>La ejecuci\u00f3n de un bucle for sigue los siguientes pasos:</p> <ol> <li>Se inicializa la variable o variables de control (inicializaci\u00f3n).</li> <li>Se eval\u00faa la condici\u00f3n (evaluaci\u00f3n).<ul> <li>Si la condici\u00f3n es cierta se ejecutan las instrucciones.</li> <li>Si es falsa, finaliza la ejecuci\u00f3n del bucle y contin\u00faa el programa en la siguiente instrucci\u00f3n despu\u00e9s del for.</li> </ul> </li> <li>Se actualiza la variable o variables de control (incremento / decremento).</li> <li>Se vuelve al paso 2.</li> </ol> <pre><code>/* programa que muestra los n\u00fameros del 1 al 10 */\npublic class Ejemplo0For {\n    public static void main(String[] args) {\n        int i;\n        for(i = 1; i &lt;= 10; i++){\n            System.out.println(i + \" \");\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut03/033_EstructuraRepeticion.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 309 (RA3 / CE3b CE3g / IC1 / 3p) Se requiere un algoritmo para determinar, de N cantidades, cu\u00e1ntas son menores o iguales a cero y cu\u00e1ntas mayores a cero. Ten en cuenta que el valor N se solicita al usuario por entrada est\u00e1ndar (mediante la clase Scanner). Resu\u00e9lvelo con la estructura de control <code>While</code>.</p> </li> <li> <p>AC 310 (RA3 / CE3b CE3g / IC1 / 3p)  Con un bucle imprime l\u00ednea por l\u00ednea los n\u00fameros de ordenadores de una clase de 6 ordenadores por fila, teniendo en cuenta que siguen la siguiente numeraci\u00f3n fila.numOrdenador. Por ejemplo, el primer ordenador ser\u00e1 7.1 y el \u00faltimo 7.6.</p> </li> <li> <p>AR 311 (RA3 / CE3b CE3g / IC1 / 3p) Desarrolla un programa utilizando un bucle <code>do-while</code> que imprima \u201cHola caracola\u201d 5 veces.</p> </li> <li> <p>AC 312 (RA3 / CE3b CE3g / IC1 / 3p) Escribe un programa que pida que se introduzcan dos n\u00fameros enteros N1 y N2 por teclado (mediante la clase Scanner) y muestre los n\u00fameros pares que hay entre ellos. N1 debe ser menor que N2. Si no es as\u00ed se mostrar\u00e1 un mensaje indic\u00e1ndolo y se vuelven a introducir. Utiliza la estructura de control <code>for</code>.</p> </li> <li> <p>AC 313 (RA3 / CE3b CE3g / IC1 / 3p) Genera un programa que permita seleccionar por teclado una opci\u00f3n de las que aparecen en el siguiente men\u00fa:</p> <ol> <li>Primera opci\u00f3n.</li> <li>Segunda opci\u00f3n.</li> <li>Tercera opci\u00f3n.</li> <li>Salir del programa.</li> </ol> </li> </ul> <p>Al escoger cualquiera de las opciones 1 a 3 mostrar\u00e1 por pantalla el texto: \u201cHas escogido la opci\u00f3n 1\u201d, \u201cHas escogido la opci\u00f3n 2\u201d \u00f3 \u201cHas escogido la opci\u00f3n 3\u201d y, tras ello, permitir\u00e1 escoger de nuevo una opci\u00f3n. En caso de escoger la opci\u00f3n 4 el programa seguir\u00e1 su ejecuci\u00f3n y acabar\u00e1. Utiliza la estructura de control <code>Do..While</code>.</p> <ul> <li> <p>AR 314 (RA3 / CE3b CE3g / IC1 / 3p) Utiliza un bucle for para escribir las siguientes secuencias.</p> <ol> <li>1 3 5 7 9</li> <li>1 2 4 8 16</li> </ol> </li> <li> <p>AC 315 (RA3 / CE3b CE3g / IC1 / 3p) Crea un programa que lea una fecha representada por dos enteros solicitados al usuario, mes y a\u00f1o, y d\u00e9 como resultado los d\u00edas que tiene ese mes teniendo en cuenta el a\u00f1o. El programa finaliza tras mostrar un resultado.</p> <p>Hay que tener en cuenta que febrero puede tener 28 d\u00edas, o bien 29 si el a\u00f1o es bisiesto. Un a\u00f1o es bisiesto cuando es m\u00faltiplo de 4 y no de 100 o cuando es m\u00faltiplo de 400.</p> <p>Por ejemplo, el a\u00f1o 2000 por las dos primeras condiciones no ser\u00eda bisiesto, pero s\u00ed lo es porque es m\u00faltiplo de 400; el a\u00f1o 2100 no es bisiesto porque, aunque sea m\u00faltiplo de 4, tambi\u00e9n lo es de 100 y no es m\u00faltiplo de 400.</p> </li> <li> <p>AP 316 (RA3 / CE3b CE3e CE3g / IC1 / 3p) Desarrolla un programa que pida al usuario introducir n\u00fameros por teclado, haga la suma de \u00e9stos y muestre el resultado al salir del programa. El usuario controla si desea continuar o no ingresando n\u00fameros, ya que si inserta un 0 sale del bucle, el mensaje que se muestra al usuario iterativamente es: \u201cInserta un n\u00famero (0 para salir)\u201d. Al finalizar se muestra: \u201cLa suma de los valores es X\u201d, donde X es el total.</p> <p>Adem\u00e1s de mostrar la suma de los valores introducidos por el usuario, muestra tambi\u00e9n el n\u00famero de valores totales distintos de cero que se insertaron. Para ello, necesitar\u00e1s agregar otra variable, ll\u00e1mala contador, y dado que cualquier n\u00famero distinto de cero ejecutar\u00e1 el cuerpo del bucle, todo lo que necesitas hacer es contador++ en el cuerpo del bucle para contar. Muestra el recuento en la salida despu\u00e9s de mostrar la suma.</p> <ul> <li>Ejemplo. Usuario inserta 1 2 3 0.</li> <li>Output: \u201cLa suma de los valores es 6. Total de n\u00famero insertados 3\u201d</li> </ul> <p>Agrega al programa anterior instrucciones para contar y mostrar tambi\u00e9n el n\u00famero de valores de entrada que son impares. Para saber si el valor es impar, se comprueba si el resto es 1, valor % 2 = 1. Esto requerir\u00e1 otra variable m\u00e1s para contar el n\u00famero de entradas impares. Inicial\u00edzala a 0, y a\u00f1ade una sentencia if en el cuerpo del bucle para probar si el valor es impar e incrementar esta variable. Finalmente, muestra un mensaje al final, antes de mostrar la suma que diga el n\u00famero de valores impares insertados.</p> <p>Agrega otra variable que se le solicitar\u00e1 al usuario antes del bucle y antes de pedirle los n\u00fameros. Este valor ser\u00e1 almacenado en la variable y ser\u00e1 un n\u00famero objetivo. Con otra instrucci\u00f3n if en el cuerpo del bucle, comprueba si el valor de entrada o n\u00famero es igual a este objetivo y, si es as\u00ed, incrementa en uno otra variable de contador. Despu\u00e9s del bucle, muestra tanto el valor objetivo como el n\u00famero de veces que el usuario insert\u00f3 ese valor objetivo.</p> <p>Ejemplo. Usuario entra 7 como n\u00famero objetivo.</p> <ul> <li>Usuario inserta 2 5 7 8 1 7 0</li> <li>Output: \u201cLa suma de los valores es 30. Total de n\u00famero insertados 6 .El n\u00famero de valores impares es 4. El valor 7 se insert\u00f3 2 veces\u201d</li> </ul> <p>A\u00f1ade otra variable, max, inicializada a cero, para almacenar el valor m\u00e1s grande insertado. En el cuerpo del bucle, determine si el nuevo n\u00famero o valor insertado por el usuario, es mayor que max (valor &gt; max) y, si es as\u00ed, establezca max en este nuevo valor. A\u00f1ade max a la salida del programa.</p> <p>Ejemplo. Usuario entra 7 como n\u00famero objetivo.</p> <ul> <li>Usuario inserta 2 5 7 8 1 7 0</li> <li>Output: \u201cLa suma de los valores es 30. Total de n\u00famero insertados 6. El n\u00famero de valores impares es 4. El valor 7 se insert\u00f3 2 veces. El m\u00e1ximo valor insertado es 8\u201d</li> </ul> </li> <li> <p>PR 317 (RA3 / CE3b CE3e CE3f CE3g / IC1 / 5p) Realiza un programa que solicite un n\u00famero n y genere esta sucesi\u00f3n hasta n. Utiliza 3 procedimientos distintos para solucionarlo empleando los bucles <code>for</code>, <code>while</code> y <code>do-while</code>. Por ejemplo: -1 2 -3 4 -5 6 -7 8 -9 \u2026 n</p> </li> <li> <p>PR 318 (RA3 / CE3b CE3e CE3f CE3g / IC1 / 5p) Crea un programa que pida por teclado la nota obtenida por cada alumno, de un total de n alumnos, en un examen, y calcule y muestre la nota media de la clase, la nota mayor y la nota menor.</p> </li> <li> <p>PR 319 (RA3 / CE3b CE3e CE3f CE3g / IC1 / 5p) Crea un programa que pida por teclado el nombre de barcos de cada banda, de un total de n bandas, has de sacar la longitud media de los nombres, el de menor longitud y el de mayor longitud.</p> </li> <li> <p>AP 320 (RA3 / CE3b CE3e CE3f CE3g / IC1 / 5p) Escribe un bucle for anidado por cada uno de los siguientes patrones:</p> <p> </p> </li> </ul>"},{"location":"uutt/ut03/034_EstructuraSalto.html","title":"Estructuras de salto","text":""},{"location":"uutt/ut03/034_EstructuraSalto.html#sentencias-break-y-continue","title":"Sentencias break y continue","text":"<p>Anteriormente vimos que la sentencia <code>break</code> finaliza la ejecuci\u00f3n de una sentencia <code>switch</code>. Pues bien, cuando se utiliza <code>break</code> en el bloque correspondiente a una sentencia <code>while</code>, <code>do</code> (<code>do-while</code>) o <code>for</code>  , hace lo mismo: finaliza la ejecuci\u00f3n del bucle. </p> <p>Cuando las sentencias <code>switch</code>, <code>while</code>, <code>do</code> o <code>for</code> est\u00e9n anidadas, la sentencia <code>break</code> solamente finaliza la ejecuci\u00f3n del bucle donde est\u00e9 incluida.</p> <pre><code>/* Programa que muestra valores de i desde 1 hasta 10 */\npublic class SentenciaBreak1 {\n    public static void main(String[] args) {\n        //Bucle for infinito ya que se repite siempre\n        for(int i = 1; ; i++){\n            System.out.print(i + \" | \");\n            if(i == 10)\n                break; //Permite la salida del bucle infinito\n        }\n    }\n}\n</code></pre> <p>La sentencia <code>continue</code> obliga a ejecutar la siguiente iteraci\u00f3n del bucle <code>while</code>, <code>do</code> o <code>for</code> en el que est\u00e1 contenida. Ejecuta el siguiente programa y observa que cada vez que se ejecuta la sentencia <code>continue</code>, se inicia la ejecuci\u00f3n del bloque de sentencias <code>for</code> para un nuevo valor de n.</p> <pre><code>public class SentenciaContinue{\n    public static void main(String[] args) {\n        for(int n = 0; n &lt;= 100; n++){\n            if(n %5 != 0){\n                continue; //si n no es m\u00faltiplo, siguiente iteraci\u00f3n\n            }\n            System.out.println(n + \" \"); //imprime siguiente m\u00faltiplo\n        }\n    }\n}\n</code></pre> <p>Se ha de intentar limitar el uso de las instrucciones <code>continue</code> y solo utilizarlas cuando esto simplifique el entendimiento del programa. Se puede implementar cualquier bucle sin el uso de la instrucci\u00f3n <code>continue</code>.</p>"},{"location":"uutt/ut03/034_EstructuraSalto.html#sentencias-break-y-continue-con-etiquetas","title":"Sentencias break y continue con etiquetas","text":"<p>Con las sentencias <code>break</code> y <code>continue</code> se puede tambi\u00e9n utilizar una etiqueta para indicar d\u00f3nde se debe reanudar la ejecuci\u00f3n. El uso de etiquetas es una mala pr\u00e1ctica en programaci\u00f3n, por lo que debe reducirse a casos excepcionales, pero se comenta aqu\u00ed por tener conciencia de su existencia.</p>"},{"location":"uutt/ut03/035_ComentarioEstructurado.html","title":"Comentarios estructurados en programas","text":"<p>A medida que los proyectos de software crecen en tama\u00f1o y complejidad, mantener la calidad y la legibilidad del c\u00f3digo se vuelve esencial. Aqu\u00ed es donde entran en juego los comentarios, una herramienta poderosa para facilitar la comprensi\u00f3n y el mantenimiento del c\u00f3digo.</p> <p>Los comentarios son fragmentos de texto que se pueden incluir en el c\u00f3digo fuente de un programa para proporcionar informaci\u00f3n adicional sobre c\u00f3mo funciona el c\u00f3digo, su prop\u00f3sito o cualquier otra aclaraci\u00f3n que sea relevante.</p> <p>En Java, los comentarios son ignorados por el compilador, lo que significa que no afectan la ejecuci\u00f3n del programa y est\u00e1n presentes \u00fanicamente para ayudar a los desarrolladores a entender y mantener el c\u00f3digo.</p> <p>Los comentarios de documentaci\u00f3n, tambi\u00e9n conocidos como <code>Javadoc</code>, son un tipo especial de comentario en Java que permite generar autom\u00e1ticamente documentaci\u00f3n en formato HTML para clases, interfaces, m\u00e9todos y variables. Estos comentarios comienzan con <code>/**</code> y terminan con <code>*/</code>. </p> <p><code>Javadoc</code> utiliza etiquetas especiales, tambi\u00e9n conocidas como tags, para proporcionar informaci\u00f3n estructurada sobre el c\u00f3digo.</p> <p>Etiquetas comunes de Javadoc:</p> <ul> <li><code>@author</code>: Indica el autor del c\u00f3digo.</li> <li><code>@version</code>: Especifica la versi\u00f3n del c\u00f3digo.</li> <li><code>@param</code>: Describe un par\u00e1metro de un m\u00e9todo.</li> <li><code>@return</code>: Describe el valor de retorno de un m\u00e9todo.</li> <li><code>@throws</code> o <code>@exception</code>: Indica las excepciones que puede lanzar un m\u00e9todo.</li> <li><code>@see</code>: Proporciona una referencia a otra clase, m\u00e9todo o campo relacionado.</li> <li><code>@since</code>: Indica la versi\u00f3n en la que se introdujo el elemento.</li> <li><code>@deprecated</code>: Marca el elemento como obsoleto y sugiere una alternativa.</li> </ul> <p>Para generar la documentaci\u00f3n HTML utilizando <code>Javadoc</code>, se debe ejecutar el siguiente comando en la l\u00ednea de comandos, reemplazando ruta_del_codigo por la ruta donde se encuentran los archivos de c\u00f3digo fuente:</p> <pre><code>javadoc -d docs ruta_del_codigo\n</code></pre> <p>Este comando generar\u00e1 la documentaci\u00f3n en la carpeta docs. Luego, se puede abrir el archivo <code>index.html</code> en un navegador para visualizar la documentaci\u00f3n generada.</p>"},{"location":"uutt/ut03/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 03","text":""},{"location":"uutt/ut03/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA3.CE <ul> <li>Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje.</li> </ul> <ul> <li>a. Se ha escrito y probado c\u00f3digo que haga uso de estructuras de selecci\u00f3n.</li> <li>b. Se han utilizado estructuras de repetici\u00f3n.</li> <li>c. Se han reconocido las posibilidades de las sentencias de salto.</li> <li>e. Se han creado programas ejecutables utilizando diferentes estructuras de control.</li> <li>f. Se han probado y depurado los programas.</li> <li>g. Se ha comentado y documentado el c\u00f3digo.</li> </ul>"},{"location":"uutt/ut03/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li>Estructura secuencial</li> <li>Estructuras de selecci\u00f3n<ol> <li>if</li> <li>Switch</li> <li>Instrucci\u00f3n condicional</li> </ol> </li> <li>Estructuras de repetici\u00f3n<ol> <li>Bucle while</li> <li>Bucle do while</li> <li>Bucle for</li> </ol> </li> <li>Estructuras de salto<ol> <li>Sentencias break y continue</li> <li>Sentencias break y continue con etiquetas</li> </ol> </li> <li>Comentarios estructurados en programas<ol> <li>Buenas pr\u00e1cticas</li> </ol> </li> </ol>"},{"location":"uutt/ut03/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>23/09/2024</p> <p>Estructura Secuencial Estructuras de selecci\u00f3n: if</p> <p>AC 301AR 302</p> <p>02</p> <p>23/09/2024</p> <p>Estructuras de selecci\u00f3n: switchEstructuras de selecci\u00f3n: ternarias</p> <p>AC 303AC 304</p> <p>03</p> <p>24/09/2024</p> <p></p> <p>AP 305</p> <p>04</p> <p>25/09/2024</p> <p></p> <p>PR 306</p> <p>05</p> <p>25/09/2024</p> <p></p> <p>PR 307</p> <p>06</p> <p>26/09/2024</p> <p></p> <p>PR 308</p> <p>07</p> <p>26/09/2024</p> <p>Estructuras de repetici\u00f3n: whileEstructuras de repetici\u00f3n: do-whileEstructuras de repetici\u00f3n: for</p> <p></p> <p>08</p> <p>27/09/2024</p> <p></p> <p>Trabajo en clase</p> <p>09</p> <p>30/09/2024</p> <p></p> <p>AC 309AC 310</p> <p>10</p> <p>30/09/2024</p> <p>Estructura de salto Comentario estructurado</p> <p>AR 311</p> <p>11</p> <p>01/10/2024</p> <p></p> <p>AC 312</p> <p>12</p> <p>02/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>13</p> <p>02/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>14</p> <p>03/10/2024</p> <p></p> <p>AC 313AR 314</p> <p>15</p> <p>03/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>16</p> <p>04/10/2024</p> <p></p> <p>AC 315</p> <p>17</p> <p>10/10/2024</p> <p></p> <p>AP 316</p> <p>18</p> <p>10/10/2024</p> <p></p> <p>PR 317</p> <p>19</p> <p>11/10/2024</p> <p></p> <p>PR 318</p> <p>20</p> <p>14/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>21</p> <p>14/10/2024</p> <p></p> <p>PR 319</p> <p>22</p> <p>15/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>23</p> <p>16/10/2024</p> <p></p> <p>PO UT 03</p> <p>24</p> <p>16/10/2024</p> <p></p> <p>PO UT 03</p>"},{"location":"uutt/ut03/ResumenUT.html#referencias","title":"Referencias","text":"<ul> <li>Web: Gu\u00eda de uso de estructuras de control en Java</li> <li>Web: Las sentencias de control de flujo en Java (if, switch, for, while, do-while, try-catch, break, continue e invocaci\u00f3n)</li> </ul>"},{"location":"uutt/ut03/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":"<ul> <li>V\u00eddeo: Curso JAVA Video 1 - Estructura de Control IF</li> <li>V\u00eddeo: Curso JAVA Video 2 - Estructura de Control FOR</li> <li>V\u00eddeo: Curso JAVA Video 3 - Estructura de Control SWITCH </li> </ul>"},{"location":"uutt/ut04/041_ConceptoClase.html","title":"Concepto de clase","text":"<p>Para poder seguir en nuestro camino como programadores, necesitamos definir y conocer el concepto de clase. La clase es la definici\u00f3n de un tipo de objeto. Al definir una clase lo que se hace es indicar c\u00f3mo funciona un determinado tipo de objetos. Luego, a partir de la clase, podremos crear objetos de ella.</p> <p>Java es un lenguaje orientado a objetos, es decir su paradigma principal (modelo o estilo de programaci\u00f3n) es la POO (programaci\u00f3n orientada a objetos). La POO permite abstraernos un nivel m\u00e1s y construir sistemas de mayor complejidad de una forma sencilla y organizada dividiendo el problema en subproblemas m\u00e1s simples. </p> <p>Est\u00e1 divisi\u00f3n se realiza en objetos, de forma que cada objeto funcione de forma totalmente independiente. Un objeto es un elemento del programa que posee sus propios datos y su propio funcionamiento. Es decir, un objeto est\u00e1 formado por datos (propiedades) y funciones que es capaz de realizar (m\u00e9todos).</p> <p>M\u00e1s adelante, nos adentraremos en la POO y veremos realmente la relevancia que esto tiene. En esta unidad nos centraremos en los conceptos b\u00e1sicos que, a lo largo del curso, nos permitir\u00e1n programar con el paradigma de POO.</p>"},{"location":"uutt/ut04/042_EstructuraClase.html","title":"Estructura y miembros de una clase","text":"<p>Teniendo en cuenta todo esto, podemos pasar a hablar de clase. Una clase es una plantilla para crear objetos. Para crear un clase en Java utilizamos la palabra reservada <code>class</code>.</p> <p>La nomenclatura del nombre de la clase es primera letra en may\u00fasculas y usar la regla <code>CamelCase</code> para palabras compuestas.</p> <pre><code>public class Coche{\n\n}\n</code></pre> <p>CamelCase</p> <p>Camel Case es una convenci\u00f3n muy popular para nombrar nuestras variables. Podemos usarlo en modo Upper Camel Case o Lower Camel Case, la diferencia es si comenzamos el nombre de la variable con may\u00fascula o min\u00fascula. Debemos usar Upper Camel Case en los nombres de las clases y archivos. Y Lower Camel Case en los nombres de las variables o m\u00e9todos.</p> <p>Ejemplos: CocheRojo, totalNinyos</p> <p>A partir de ahora ya sabes c\u00f3mo llamar a tus funciones, y es la manera que seguiremos, de ahora en adelante, para nombrar nuestras clases. </p> <p>Existen tres tipos de modificadores de acceso, cada uno nos indicia lo que queremos que otros accedan a nuestra clase:</p> <ul> <li><code>public</code>: en este caso, public especifica que no hay ninguna restricci\u00f3n de acceso.</li> <li><code>private</code>: nadie puede acceder a la clase.</li> <li><code>protected</code>: permite a las clases de este paquete acceder y subclases.</li> </ul> <p>La definici\u00f3n de una clase incluye varios componentes:</p> <ul> <li>Sus atributos. Es decir, los datos miembros de esa clase. Los datos pueden ser p\u00fablicos (accesibles desde otra clase), privados (solo accesibles desde su propia clase), etc, es decir tener distintos modificadores de acceso. A los atributos tambi\u00e9n se les llama campos.</li> <li>Sus m\u00e9todos. Las funciones miembro de la clase. Son las acciones (u operaciones) que puede realizar la clase. Tambi\u00e9n pueden tener distintos modificadores de acceso.</li> <li>C\u00f3digo de inicializaci\u00f3n. Para crear una clase normalmente hace falta realizar operaciones previas (es lo que se conoce como constructor de la clase).</li> <li>Otras clases. Dentro de una clase se pueden definir otras</li> </ul> <p>Los atributos se encuentran en la zona m\u00e1s interna, oculta a los usuarios del objeto. El acceso a esta zona se realizar\u00e1 a trav\u00e9s de los m\u00e9todos.</p> <p>El formato general para crear una clase en Java es:</p> <pre><code>[acceso] class NombreClase {\n    [acceso] [static] tipo atributo1;\n    [acceso] [static] tipo atributo2;\n    [acceso] [static] tipo atributo3;\n    ...\n    [acceso] [static] tipo metodo1(listaDeArgumentos){\n        ...\n    }\n    ...\n}\n</code></pre> <p>La palabra opcional <code>static</code> sirve para hacer que el m\u00e9todo o la propiedad a la que precede se pueda utilizar de manera est\u00e1tica los m\u00e9todos o propiedades as\u00ed definidos se llaman atributos de clase y m\u00e9todos de clase respectivamente. Su uso se ver\u00e1 m\u00e1s adelante.</p>"},{"location":"uutt/ut04/043_CreacionAtributos.html","title":"Creaci\u00f3n de atributos","text":"<p>Hasta ahora hemos creado variables dentro de un m\u00e9todo. A \u00e9stas se les llama variables locales porque son propias del m\u00e9todo en s\u00ed. Y no puedes acceder a ellas desde fuera de ese m\u00e9todo. Tambi\u00e9n vimos esto dentro de bloques de c\u00f3digo <code>{}</code>, donde las variables creadas en un bloque m\u00e1s interno no eran accesibles en bloques m\u00e1s externos.</p> <pre><code>public static void sumar(){\n    int contador = 0;\n\n    while (contador &lt; 10){\n        int suma = 0;\n        suma += contador;\n        contador ++;\n    }\n\n    System.out.println(suma); //esto da error, la variable suma no existe en este punto\n}\n</code></pre> <p>A diferencia de esto, las clases nos permiten crear variables que pueden ser accesibles desde cualquier lugar dentro de la clase que estamos creando. A estas variables se les conoce con el nombre de variables miembro/instancia, o de manera m\u00e1s com\u00fan como campos o atributos de la clase.</p> <p>Para crear un campo de la clase se debe especificar un modificador de acceso(opcional) + tipo de dato + nombre de la variable + inicializaci\u00f3n(opcional).</p> <p>Nota</p> <p>Si no se pone modificador utiliza el de por defecto en el que la variable es accesible por las clases dentro del mismo paquete.</p> <p>El modificador de acceso funciona de la misma forma a como lo hemos explicado anteriormente para la creaci\u00f3n de una clase.</p> <pre><code>public class Coche{\n    private int puertas;\n    private int ruedas;\n    private String modelo;\n    private String color;\n}\n</code></pre> <p>Como regla general, cuando definimos campos para la clase el modificador de acceso ser\u00e1 privado. Lo que hacemos es ocultar los campos de la clase del acceso p\u00fablico para que nadie pueda acceder y modificar los campos de la clase. Significa que la representaci\u00f3n del objeto se ocultar\u00e1 a la vista, es decir, el funcionamiento interno del objeto.</p> <p>Existen los siguientes tipos de modificadores, ordenados de menor a mayor restricci\u00f3n:</p> <ul> <li><code>public</code>: son accesibles desde cualquier lugar.</li> <li><code>protected</code>: son accesibles desde dentro del mismo paquete y en clases heredadas.</li> <li>sin modificador: son accesibles desde la propia clase y clases dentro del mismo paquete.</li> <li><code>private</code>: solo son accesibles desde la propia clase, no son accesibles desde fuera.</li> </ul> <p>Consejos para elegir un nivel de acceso</p> <ul> <li>Utiliza el nivel de acceso m\u00e1s restrictivo que tenga sentido para un miembro en particular. Usa private a menos que tengas una buena raz\u00f3n para no hacerlo.</li> <li>Evita los campos p\u00fablicos a excepci\u00f3n de las constantes.</li> </ul> <p>Si se usa la palabra clave <code>satic</code> en atributos o m\u00e9todos, se podr\u00e1n utilizar el miembro de la clase sin definir objeto alguno, utilizando el nombre de la clase como si fuera un objeto.</p> <p>En el caso de los atributos o variables podemos distinguir dos tipos:</p> <ul> <li>Atributos de instancia: son todos los atributos no <code>static</code>. Tambi\u00e9n conocidos como atributos din\u00e1micos. Cada objeto de la clase tiene sus propios valores para estas variables, es decir, cada objeto que se crea incluir\u00e1 su propia copia de los atributos con sus propios valores.</li> <li>Atributos de clase: son los declarados <code>static</code>. Tambi\u00e9n se llaman atributos est\u00e1ticos. Un atributo de clase no es espec\u00edfico de cada objeto. Solo hay una copia del mismo y su valor es compartido por todos los objetos de la clase. Podemos considerarlo como una variable global a la que tienen acceso todos los objetos de la clase.</li> </ul> <p>Para acceder a un atributo de clase se escribe: <code>NombreClase.Atributo;</code>.</p>"},{"location":"uutt/ut04/044_CreacionMetodos.html","title":"Creaci\u00f3n de m\u00e9todos.","text":"<p>Los m\u00e9todos en Java son bloques de c\u00f3digo que realizan una tarea en concreto, se utilizan para encapsular la l\u00f3gica de un programa en funciones o procedimientos reutilizables. Los m\u00e9todos sirven para hacer nuestro c\u00f3digo m\u00e1s legible, m\u00e1s f\u00e1cil de mantener y sin c\u00f3digo duplicado.</p> <p>Todo el tiempo hemos estado usando un m\u00e9todo llamado <code>main</code>, dentro de \u00e9l se encuentran todas las sentencias que hemos ido ejecutando, ahora vamos a crear nuestros propios m\u00e9todos. Para ello tendremos en cuenta:</p> <ul> <li>Tienen que estar dentro de una clase</li> <li>Tienen una definici\u00f3n: visibilidad [static] tipoDeRetorno nombreMetodo ([par\u00e1metros])<ul> <li>tipoDeRetorno, indica el tipo de dato que devuelve el m\u00e9todo. Si no devuelve ning\u00fan valor se pone void</li> <li>nombreDelMetodo</li> <li>par\u00e1metros: lista de variables que acepta el m\u00e9todo, esto es opcional.</li> </ul> </li> <li>Invocaci\u00f3n a m\u00e9todos: los m\u00e9todos se invocan desde otros m\u00e9todos o desde el <code>main</code>, para llamar a un m\u00e9todo se utiliza el nombre y par\u00e9ntesis, y si tiene se a\u00f1aden los argumentos.</li> </ul> <p>Importante</p> <p>La definici\u00f3n de los m\u00e9todos se alinean unos debajo de otros, no se puede insertar un m\u00e9todo dentro de otro m\u00e9todo, y adem\u00e1s deben estar dentro de la clase.</p> <p>Un valor devuelto es informaci\u00f3n que un m\u00e9todo devuelve al c\u00f3digo que lo llam\u00f3. Cada m\u00e9todo solo puede devolver un valor: cuando un m\u00e9todo regresa, deja de ejecutarse (y continuamos donde lo dejamos antes de llamar al m\u00e9todo). Para que el c\u00f3digo que llam\u00f3 al m\u00e9todo use el valor devuelto, el valor devuelto debe almacenarse en una variable o usarse inmediatamente.</p> <pre><code>public static type nombreMetodo(parametros){\n    ....\n    return expresion;\n}\n\n......\n\ntype nombreVariable = nombreMetodo(parametros)\n</code></pre> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        boolean gameOver = true;\n        int puntuacion = 5000;\n        int nivelCompletado = 5;\n        int bonus = 10;\n\n        int score = calcularPuntuacion(gameOver, puntuacion, nivelCompletado, bonus);\n        System.out.println(score);\n\n        // otra forma de hacerlo es pasarle directamente el valor de las variables\n        score = calcularPuntuacion(true, 1000, 10, 30);\n        System.out.println(score);\n    }\n\n    public static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\n        if (gameOver) {\n            int puntuacionFinal = puntuacion + (nivelCompletado * bonus);\n            puntuacionFinal += 100;\n            return puntuacionFinal;\n        } else {\n            return -1;\n        }\n    }\n\n    // OTRAS FORMAS M\u00c1S EFICIENTES DE CREAR EL M\u00c9TODO calcularPuntuaciones\n    // 1. M\u00e9todo m\u00e1s eficiente sin sentencia else\n    public static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\n        if (gameOver) {\n            int puntuacionFinal = puntuacion + (nivelCompletado * bonus);\n            puntuacionFinal += 100;\n            return puntuacionFinal;\n        }\n        return -1;\n    }\n\n    // 2. Otra forma de realizar el m\u00e9todo calcularPuntuacion sin utilizar dos sentencias de return seria\n    public static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\n        int puntuacionFinal = -1;\n        if (gameOver) {\n            int puntuacionFinal = puntuacion + (nivelCompletado * bonus);\n            puntuacionFinal += 100;\n        }\n\n        return puntuacionFinal;\n    }\n}\n</code></pre> <p>En el ejemplo vemos que se han usado muchos de los conceptos expuestos en la presente unidad, pero nos queda realizar una serie de matizaciones para poder lograr un pleno conocimiento de lo que es un m\u00e9todo.</p> <p>Aunque se ha tratado todo como m\u00e9todo, hay que hacer una distinci\u00f3n entre m\u00e9todo y funci\u00f3n:</p> <ul> <li>Funci\u00f3n: Las funciones son un conjunto de l\u00edneas de c\u00f3digo (instrucciones), encapsulados en un bloque, usualmente reciben par\u00e1metros, cuyos valores utilizan para efectuar operaciones y adicionalmente retornan un valor. En otras palabras una funci\u00f3n puede recibir par\u00e1metros o argumentos (algunas no reciben nada), hace uso de dichos valores recibidos como sea necesario y retorna un valor usando la instrucci\u00f3n <code>return</code>, si no retorna algo, entonces no es una funci\u00f3n. En Java las funciones usan el modificador <code>static</code>.</li> <li>M\u00e9todo: los m\u00e9todos y las funciones en Java est\u00e1n en capacidad de realizar las mismas tareas, es decir, son funcionalmente id\u00e9nticos, pero su diferencia radica en la manera en que hacemos uso de uno u otro (el contexto). Un m\u00e9todo tambi\u00e9n puede recibir valores, efectuar operaciones con estos y retornar valores, sin embargo en m\u00e9todo est\u00e1 asociado a un objeto, siempre, b\u00e1sicamente un m\u00e9todo es una funci\u00f3n que pertenece a un objeto o clase, mientras que una funci\u00f3n existe por s\u00ed sola, sin necesidad de un objeto para ser usada.</li> </ul> <p>Una vez visto esto, se puede enunciar que en Java se debe hablar de m\u00e9todos y no de funciones, pues en Java estamos siempre obligados a crear un objeto para usar el m\u00e9todo. Para que sea una funci\u00f3n esta debe ser <code>static</code>, para que no requiera de un objeto para ser llamada.</p> <p>Una vez que hemos aclarado esto, podemos hacer uso, en cualquier circunstancia, de nuestros m\u00e9todos. Nos queda ver qu\u00e9 es lo que pasa si llamamos a un m\u00e9todo a s\u00ed mismo, \u00bfes posible?</p>"},{"location":"uutt/ut04/044_CreacionMetodos.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 401 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC1 / 3p). Has de generar un programa que diga si se le concede una hipoteca a una persona o no. Para ello deber\u00e1s generar tres m\u00e9todos:</p> <ul> <li><code>edadOptima</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metro la edad, que si es mayor de 18 podr\u00e1 optar a un pr\u00e9stamo. Si es mayor de 65 se le denegar\u00e1. No ha de mostrar mensaje. Devolver\u00e1 si la edad es \u00f3ptima o no.</li> <li><code>ingresosPersona</code>: se le introducir\u00e1 el total de ingresos de una persona y el coste de la hipoteca que solicita. Si la hipoteca es mayor de un tercio de los ingresos debe denegarla.</li> <li><code>calculoHipoteca</code>: se le pasar\u00e1n por par\u00e1metros los resultados obtenidos y deber\u00e1 ver si se le concede o no. Debe mostrar un mensaje afirmativo, y en caso de que se deniegue mostrar las razones.</li> </ul> <p>Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> <li> <p>AC 402 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC1 / 3p). Has de generar un programa que calcule el coste por ni\u00f1o en una excursi\u00f3n. Para ello se deber\u00e1n programar los siguientes m\u00e9todos:</p> <ul> <li><code>calculoAutobus</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metro el n\u00famero de ni\u00f1os. Ha de devolver el coste por ni\u00f1o del autob\u00fas.</li> <li><code>calculoEntradas</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metro el n\u00famero de ni\u00f1os. Ha de devolver el coste por ni\u00f1o por entrada.</li> <li><code>calculoExcursion</code>: se le pasar\u00e1n por par\u00e1metros los resultados obtenidos y deber\u00e1 calcular el total de cada ni\u00f1o en la excursi\u00f3n. Se deber\u00e1 mostrar un mensaje en el que se indique el precio desglosado y el total por ni\u00f1o.</li> </ul> <p>Info</p> <p>La forma de cobrar el autob\u00fas es la siguiente: si son 100 alumnos o m\u00e1s, el costo por cada alumno es de 65.0 euros; de 50 a 99 alumnos, el costo es de 70.5 euros, de 30 a 49, de 95.0 euros, y si son menos de 30, el costo del alquiler del autob\u00fas es de 400.0 euros, sin importar el n\u00famero de alumnos. </p> <p>La forma de cobrar las entradas es la siguiente: si son 100 alumnos o m\u00e1s, el costo por cada alumno es de la mitad del coste base de la entrada; de 50 a 99 alumnos, el costo es dos terceras partes del coste base y menos de 50 es el coste base de la entrada. Este coste ha de estar parametrizado, y ha de ser un dato global y lo m\u00e1s protegido posible. Para la temporada 2023/2024 su coste es de 9.99\u20ac</p> <p>Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> <li> <p>AC 403 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC1 / 3p). Este programa calcular\u00e1 la nota media de un estudiante bas\u00e1ndose en tres tipos de evaluaciones (ex\u00e1menes, trabajos y participaci\u00f3n). Deber\u00e1s usar varios m\u00e9todos para desglosar el c\u00e1lculo de cada categor\u00eda. El programa deber\u00e1 contener los siguientes m\u00e9todos:</p> <ul> <li><code>calculoExamenes</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metros las notas de los ex\u00e1menes. Devolver\u00e1 el promedio de los ex\u00e1menes.</li> <li><code>calculoTrabajos</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metro las notas de los trabajos. Devolver\u00e1 el promedio de los trabajos.</li> <li><code>calculoParticipacion</code>: este m\u00e9todo recibir\u00e1 la nota de participaci\u00f3n del alumno. Devolver\u00e1 la nota de participaci\u00f3n.</li> <li><code>calculoNotaFinal</code>: este m\u00e9todo recibir\u00e1 los resultados de los m\u00e9todos anteriores y calcular\u00e1 la nota final del alumno. La nota final ser\u00e1 una combinaci\u00f3n ponderada: ex\u00e1menes 50%, trabajos 40%, participaci\u00f3n 10%. Se mostrar\u00e1 un desglose y el promedio final del alumno.</li> </ul> <p>Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> <li> <p>AC 404 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC1 / 3p). Este programa calcular\u00e1 el \u00cdndice de Masa Corporal de una persona a partir de su peso y altura. Se usar\u00e1 una serie de m\u00e9todos para hacer los c\u00e1lculos y evaluar la categor\u00eda del IMC (bajo peso, normal, sobrepeso, etc.).El programa deber\u00e1 contener los siguientes m\u00e9todos:</p> <ul> <li><code>calculoIMC</code>: recibir\u00e1 como par\u00e1metros el peso (en kg) y la altura (en metros). Devolver\u00e1 el resultado del IMC utilizando la f\u00f3rmula: IMC = peso / (altura * altura).</li> <li><code>clasificacionIMC</code>: recibir\u00e1 como par\u00e1metro el resultado del IMC calculado. Devolver\u00e1 la categor\u00eda correspondiente en base a los siguientes valores:<ul> <li>Menos de 18.5: Bajo peso</li> <li>Entre 18.5 y 24.9: Peso normal</li> <li>Entre 25 y 29.9: Sobrepeso</li> <li>30 o m\u00e1s: Obesidad</li> </ul> </li> <li><code>resultadoFinalIMC</code>: se le pasar\u00e1n por par\u00e1metro el peso, la altura, el IMC y la clasificaci\u00f3n del mismo, y deber\u00e1 mostrar un mensaje con toda la informaci\u00f3n desglosada.</li> </ul> <p>El IMC</p> <p>El IMC es un indicativo poco exacto de la apariencia de una persona. En este ejercicio se hace uso del mismo a t\u00edtulo educativo, en ning\u00fan caso se pretende que el alumnado tenga una concepci\u00f3n negativa de s\u00ed mismo.</p> <p>Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> <li> <p>AC 405 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC1 / 3p). Este programa calcular\u00e1 el salario neto de un trabajador tras aplicar deducciones como impuestos y seguridad social. El programa deber\u00e1 contener los siguientes m\u00e9todos:</p> <ul> <li><code>calculoImpuestos</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metro el salario bruto y el porcentaje de impuestos aplicables. Devolver\u00e1 la cantidad descontada por impuestos.</li> <li><code>calculoSeguridadSocial</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metro el salario bruto y el porcentaje que se descuenta para la seguridad social. Devolver\u00e1 el descuento correspondiente.</li> <li><code>calculoSalarioNeto</code>: recibir\u00e1 como par\u00e1metros el salario bruto, el importe de impuestos y el importe de seguridad social. Devolver\u00e1 el salario neto del trabajador. Mostrar\u00e1 un desglose del salario bruto, las deducciones y el salario neto final.</li> </ul> <p>Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> <li> <p>AR 406 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC1 / 3p). Este programa convertir\u00e1 una temperatura de grados Celsius a Fahrenheit y Kelvin. Utilizar\u00e1 varios m\u00e9todos para descomponer el c\u00e1lculo y mostrar los resultados. El programa deber\u00e1 contener los siguientes m\u00e9todos:</p> <ul> <li><code>convertirAFahrenheit</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metro una temperatura en grados Celsius y devolver\u00e1 su equivalente en grados Fahrenheit. La f\u00f3rmula de conversi\u00f3n es: F = (C * 9/5) + 32.</li> <li><code>convertirAKelvin</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metro una temperatura en grados Celsius y devolver\u00e1 su equivalente en Kelvin. La f\u00f3rmula de conversi\u00f3n es: K = C + 273.15.</li> <li><code>mostrarResultados</code>: este m\u00e9todo recibir\u00e1 como par\u00e1metros la temperatura en Celsius, Fahrenheit y Kelvin, y deber\u00e1 mostrar un mensaje con los valores de las tres temperaturas de forma clara.</li> </ul> <p>Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> <li> <p>PR 407 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC2 / 5p). Desarrolla un programa que contenga:</p> <ol> <li>Un m\u00e9todo que pida al usuario introducir n\u00fameros por teclado, haga la suma de \u00e9stos y muestre el resultado al salir del programa. El usuario controla si desea continuar o no ingresando n\u00fameros, ya que si inserta un 0 sale del bucle, el mensaje que se muestra al usuario iterativamente es: \u201cInserta un n\u00famero (0 para salir)\u201d. Al finalizar se muestra: \u201cLa suma de los valores es X\u201d, donde X es el total.</li> <li>Agrega al programa anterior un m\u00e9todo que de cada n\u00famero introducido por par\u00e1metro diga si es par o impar. Se llamar\u00e1 <code>esPar</code>. </li> <li>Gracias al uso de variables y su definici\u00f3n, genera dos m\u00e9todos que calculen de los n\u00fameros introducidos cu\u00e1l es el m\u00e1ximo y cu\u00e1l es el m\u00ednimo. Se llamar\u00e1n <code>maxIntroducido</code> y <code>minIntroducido</code>.</li> </ol> <p>Es obligatorio el uso de m\u00e9todos y comentarios en javadoc para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> <li> <p>PR 408 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC2 / 5p). Desarrolla un programa que muestre el siguiente men\u00fa:</p> <ol> <li>Entrantes</li> <li>Primeros</li> <li>Segundos</li> <li>Postres</li> <li>Salir</li> </ol> <p>El men\u00fa ha de devolver la opci\u00f3n selecciona. En funci\u00f3n de esta, cada uno de ellos (salvo en el 5) deber\u00e1s mostrar un m\u00ednimo de 3 opciones (a tu elecci\u00f3n) cada opci\u00f3n con un precio diferente. Ser\u00eda interesante que generases los siguientes m\u00e9todos (o puede que otros):</p> <ul> <li><code>entrantes</code>: Muestra el men\u00fa de entrantes, no devuelve nada solo mensaje del plato seleccionado.</li> <li><code>primerosPlatos</code>: Muestra el men\u00fa de primeros platos, no devuelve nada solo mensaje del plato seleccionado.</li> <li><code>segundosPlatos</code>: Muestra el men\u00fa de segundos platos, no devuelve nada solo mensaje del plato seleccionado.</li> <li><code>postres</code>: entrantes: Muestra el men\u00fa de postres, no devuelve nada solo mensaje del plato seleccionado.</li> </ul> <p>Al final se ha de generar otro m\u00e9todo que muestre la cuenta total. Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> <p>Aclaraci\u00f3n</p> <p>Un men\u00fa ha de estar compuesto por al menos un primero o un segundo. Esto ha de servirte como indicador para poder salir del men\u00fa. El men\u00fa ha de mostrarse hasta que se marque Salir, pero el precio no se mostrar\u00e1 si no se ha rellenado un men\u00fa v\u00e1lido.</p> <p>Se considerar\u00e1 seleccionado cuando se entre al men\u00fa de opciones. No se contempla entrar y no elegir.</p> </li> </ul>"},{"location":"uutt/ut04/045_Recursividad.html","title":"Recursividad","text":"<p>Un m\u00e9todo recursivo es un m\u00e9todo que se llama a s\u00ed mismo. Un m\u00e9todo iterativo es un m\u00e9todo que usa un bucle para repetir una acci\u00f3n. En cierto sentido, la recursividad es una alternativa a las estructuras de control iterativas (en bucle).</p> <pre><code>public void holaIterativo(int n){\n    for (int i = 0; i &lt; n; i++){\n        System.out.println(\"Hola\");\n    }\n}\n\npublic void holaRecursivo(int n){\n    if (n &gt; 0){\n        System.out.println(\"Hola\");\n        holaRecursivo(n-1); // Llamada recursiva\n    }\n}\n</code></pre> <p>En el ejemplo anterior, es mucho menos eficiente llamar a un m\u00e9todo cinco veces que repetir un bucle for cinco veces. Las llamadas a m\u00e9todos ocupan m\u00e1s memoria que los bucles e implican m\u00e1s sobrecarga computacional, en tareas como pasar par\u00e1metros, asignar almacenamiento para las variables locales del m\u00e9todo y devolver los resultados del m\u00e9todo.</p> <p>Sobre eficiencia</p> <p>Los algoritmos y m\u00e9todos iterativos son generalmente m\u00e1s eficientes que los algoritmos recursivos que hacen lo mismo.</p> <p>Recursividad como un enfoque de resoluci\u00f3n de problemas</p> <p>Dado que la recursividad no es realmente necesaria, si un lenguaje de programaci\u00f3n tiene bucles, y no es m\u00e1s eficiente que los bucles, \u00bfpor qu\u00e9 es tan importante?</p> <p>Porque la recursividad es un enfoque eficaz para la resoluci\u00f3n de problemas. Es una forma de ver un problema.</p> <p>La recursividad se basa en dos conceptos clave de resoluci\u00f3n de problemas: \"divide y vencer\u00e1s\" y \"auto-similaridad\".</p>"},{"location":"uutt/ut04/045_Recursividad.html#parte-recursiva-y-caso-base","title":"Parte recursiva y caso base","text":"<p>Una definici\u00f3n recursiva consta de dos partes: una parte recursiva que se repite y reduce el problema en una versi\u00f3n m\u00e1s peque\u00f1a del problema original, y un caso base o l\u00edmite no recursivo, que define una condici\u00f3n l\u00edmite y se utiliza para detener la recursividad.</p> <p>Veamos un ejemplo con el c\u00e1lculo de un factorial de n! Recordamos como se hac\u00eda el c\u00e1lculo de n!: n! = n * (n-1) * n(n-2) * .... mientras n &gt; 0. Adem\u00e1s, 0! se define como 1.</p> <p>Ejemplos:</p> <ul> <li>4! = 4 * 3 * 2 * 1 = 24</li> <li>3! = 3 * 2 * 1 = 6</li> <li>1! = 1</li> <li>0! = 1</li> </ul> <p>Como vemos en el ejemplo, podemos deducir que el factorial se repite en t\u00e9rminos de (n-1) y el \u00fanico caso donde no se calcula el factorial es 0!, esto nos lleva a que:</p> <ul> <li>n! = 1 --&gt; if n = 0 //caso base</li> <li>n! = n * (n-1) --&gt; if n &gt; 0 //caso recursivo</li> </ul> <p>De forma que el factorial de un n\u00famero quedar\u00eda codificado de la siguiente forma:</p> <pre><code>public int factorial(int n){\n    if (&lt;=0){\n        return 1;\n    }else{\n        return n * factorial(n-1);\n    }\n}\n</code></pre>"},{"location":"uutt/ut04/045_Recursividad.html#actividades","title":"Actividades","text":"<ul> <li>AC 409 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC1 / 3p). Realiza un programa que solicite la base de una potencia y el exponente. Has de resolverlo de manera recursiva.</li> <li> <p>AC 410 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC1 / 3p). Has de realizar un programa que muestra los N primeros n\u00fameros de la sucesi\u00f3n de Fibonacci de forma recursiva.     Ejemplo de los primeros n\u00fameros de Fibonacci: 0,1,1,2,3,5,8,13,21,34\u2026</p> <p>Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> <li> <p>PR 411 (RA2 / CE2b, CE2d, CE2e, CE2f, CE2i  / IC2 /5p). Realiza un programa que te ayude a resolver el juego de las Torres de Hanoi de manera recursiva.</p> <p>Las torres de Hanoi</p> <p>Las Torres de Hanoi es un juego oriental que consta de tres columnas llamadas origen, destino y auxiliar y una serie de discos de distintos tama\u00f1os. Los discos est\u00e1n colocados de mayor a menor tama\u00f1o en la columna origen. El juego consiste en pasar todos los discos a la columna destino y dejarlos como estaban de mayor a menor. (el m\u00e1s grande en la base, el m\u00e1s peque\u00f1o arriba)</p> <p>Las reglas del juego son las siguientes:</p> <ul> <li>S\u00f3lo se puede mover un disco cada vez.</li> <li>Para cambiar los discos de lugar se pueden usar las tres columnas.</li> <li>Nunca deber\u00e1 quedar un disco grande sobre un disco peque\u00f1o.</li> </ul> <p>En este caso haremos que los discos sean n\u00fameros generados aleatoriamente del 1 al 9. Trabajaremos con 4 discos</p> <p>Es obligatorio el uso de m\u00e9todos y comentarios en <code>javadoc</code> para obtener la m\u00e1xima puntuaci\u00f3n del ejercicio.</p> </li> </ul>"},{"location":"uutt/ut04/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 04","text":""},{"location":"uutt/ut04/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA2.CE <ul> <li>Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos.</li> </ul> <ul> <li>b. Se han escrito programas simples.</li> <li>d. Se han utilizado m\u00e9todos y propiedades de los objetos</li> <li>e. Se han escrito llamadas a m\u00e9todos est\u00e1ticos.</li> <li>f. Se han utilizado par\u00e1metros en la llamada a m\u00e9todos.</li> <li>i. Se ha utilizado el entorno integrado de desarrollo en la creaci\u00f3n y compilaci\u00f3n de programas simples.</li> </ul>"},{"location":"uutt/ut04/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li>Concepto de clase.</li> <li>Estructura y miembros de una clase. </li> <li>Creaci\u00f3n de atributos. </li> <li>Creaci\u00f3n de m\u00e9todos.</li> <li>Recursividad <ol> <li>Recursividad como un enfoque de resoluci\u00f3n de problemas </li> <li>Parte recursiva y caso base </li> </ol> </li> </ol>"},{"location":"uutt/ut04/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>17/10/2024</p> <p>Concepto de clase Estructuras y miembros de una claseCreaci\u00f3n de atributosCreaci\u00f3n de m\u00e9todos</p> <p></p> <p>02</p> <p>17/10/2024</p> <p></p> <p>AC 401AC 402</p> <p>03</p> <p>18/10/2024</p> <p></p> <p>AC 403</p> <p>04</p> <p>21/10/2024</p> <p></p> <p>AC 404AC 405</p> <p>05</p> <p>21/10/2024</p> <p></p> <p>PR 407</p> <p>06</p> <p>22/10/2024</p> <p></p> <p>PR 408</p> <p>07</p> <p>23/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>08</p> <p>23/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>09</p> <p>24/10/2024</p> <p>Recursividad</p> <p></p> <p>10</p> <p>24/10/2024</p> <p></p> <p>AC 409</p> <p>11</p> <p>25/10/2024</p> <p></p> <p>AC 410</p> <p>12</p> <p>28/10/2024</p> <p></p> <p>PR 411</p> <p>13</p> <p>28/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>14</p> <p>29/10/2024</p> <p></p> <p>Trabajo en clase</p> <p>15</p> <p>30/10/2024</p> <p></p> <p>PO UT 04</p> <p>16</p> <p>30/10/2024</p> <p></p> <p>PO UT 04</p>"},{"location":"uutt/ut05/051_Arrays.html","title":"Arrays","text":"<p>En programaci\u00f3n, un array (o arreglo en espa\u00f1ol) es una estructura de datos que permite almacenar m\u00faltiples elementos del mismo tipo en una secuencia o lista. Los elementos de un array est\u00e1n organizados en posiciones indexadas, lo que significa que cada elemento tiene una posici\u00f3n o \u00edndice dentro del array, comenzando generalmente desde 0.</p> <p>Para acceder a cada elemento del array se utiliza el nombre del array y un \u00edndice que indica la posici\u00f3n que ocupa el elemento dentro del array. El \u00edndice se escribe entre corchetes [ ] y debe ser entero positivo. El primer elemento del array ocupa la posici\u00f3n 0, el segundo la posici\u00f3n 1, etc. En un array de n elementos el \u00faltimo ocupar\u00e1 la posici\u00f3n n-1.</p> <p>En el ejemplo anterior, <code>notas[0]</code> contiene la nota del primer alumno y <code>notas[19]</code> contiene la del \u00faltimo.</p>"},{"location":"uutt/ut05/051_Arrays.html#declaracion","title":"Declaraci\u00f3n","text":"<p>En la declaraci\u00f3n se crea la referencia al array. La referencia ser\u00e1 el nombre con el que manejaremos el array en el programa. Se debe indicar el nombre del array y el tipo de datos que contendr\u00e1. De forma general, un array unidimensional se puede declarar en Java de cualquiera de las siguientes formas:</p> <pre><code>tipo [] nombreArray;\ntipo nombreArray[];\n</code></pre> <ul> <li>tipo: indica el tipo de datos que contendr\u00e1. Aun array puede contener elementos de tipo b\u00e1sico o primitivo o referencias a objetos.</li> <li>nombreArray: es la referencia al array. Es el nombre que se usar\u00e1 en el programa para manejarlo.</li> </ul> <p>Ejemplos de arrays</p> <pre><code>int [] ventas; // array de datos de tipo int llamado ventas\ndouble [] temperaturas; // array de datos de tipo double llamado temperaturas\nString [] nombres; // array de tipo String llamado nombres\n</code></pre> <p>A tener en cuenta</p> <p>En un array podemos almacenar cualquier tipo de elementos, desde un byte a un objeto. Aunque la POO se inicia en la UT 06, es importante que vay\u00e1is teniendo esto en cuenta.</p>"},{"location":"uutt/ut05/051_Arrays.html#instancia","title":"Instancia","text":"<p>Mediante la instanciaci\u00f3n se reserva un bloque de memoria para almacenar todos los elementos del array. La direcci\u00f3n donde comienza el bloque de memoria donde se almacenar\u00e1 el array se asigna al nombre del array. De forma general:</p> <pre><code>nombreArray = new tipo[tama\u00f1o];\nventas = new int[5]; //se reserva memoria para 5 enteros y se asigna la direcci\u00f3n de inicio del array a ventas.\n</code></pre> <ul> <li>nombreArray: es el nombre creado en la declaraci\u00f3n.</li> <li>tipo: indica el tipo de datos que contiene.</li> <li>tama\u00f1o: es el n\u00famero de elementos del array. Debe ser una expresi\u00f3n entera positiva. El tama\u00f1o del array no se puede modificar durante la ejecuci\u00f3n del programa.</li> <li>new: operador para crear objetos. Mediante new se asigna la memoria necesaria para ubicar el objeto. Java implementa los arrays como objetos.</li> </ul> <p>Lo normal es que la declaraci\u00f3n y la instanciaci\u00f3n se hagan en una sola instrucci\u00f3n:</p> <pre><code>tipo [] nombreArray = new tipo[tama\u00f1o];\nint [] ventas = new int[5];\n</code></pre> <p>El tama\u00f1o del array tambi\u00e9n se puede indicar durante la ejecuci\u00f3n del programa, es decir, en tiempo de ejecuci\u00f3n se puede pedir por teclado el tama\u00f1o del array y crearlo:</p> <pre><code>Scanner sc = new Scanner(System.in);\nSystem.out.print(\"N\u00famero de elementos del array: \");\nint numeroElementos = sc.nextInt();\nint [] ventas = new int[numeroElementos];\n</code></pre> <p>Cuidado</p> <p>Si no hay memoria suficiente para crear el array, new lanza una excepci\u00f3n <code>java.lang.OutOfMemoryError</code>. El manejo de excepciones lo veremos mucho m\u00e1s adelante, en la UT 08.</p>"},{"location":"uutt/ut05/051_Arrays.html#diferencia-entre-la-referencia-y-el-contenido-del-array","title":"Diferencia entre la referencia y el contenido del array.","text":"<p>Debe quedar clara la diferencia entre la referencia (manejador del array o nombre del array) y el contenido del array. El nombre del array contiene la direcci\u00f3n de memoria del contenido del array.</p>"},{"location":"uutt/ut05/051_Arrays.html#inicializacion","title":"Inicializaci\u00f3n","text":"<p>Un array es un objeto, por lo tanto, cuando se crea, a sus elementos se les asigna autom\u00e1ticamente un valor inicial:</p> <ul> <li>0 para arrays num\u00e9ricos.</li> <li><code>\\u0000</code> o <code>\\0</code> (car\u00e1cter nulo) para arrays de caracteres.</li> <li><code>false</code> para arrays booleanos.</li> <li><code>null</code> para arrays de String y de referencias a objetos.</li> </ul> <p>Tambi\u00e9n podemos dar otros valores iniciales al array cuando se crea. Los valores iniciales se escriben entre llaves separados por comas. Los valores iniciales deber\u00e1n aparecer en el orden en que ser\u00e1n asignados a los elementos del array. El n\u00famero de valores determina el tama\u00f1o del array. </p> <pre><code>//creaci\u00f3n de un array de 4 elementos booleanos\nboolean [] resultados = {true,false,true,false};\n//creaci\u00f3n de un array de 7 elementos de tipo String\nString [] dias = {\"Lunes\", \"Martes\", \"Mi\u00e9rcoles\", \"Jueves\", \"Viernes\", \"S\u00e1bado\", \"Domingo\"};\n</code></pre>"},{"location":"uutt/ut05/051_Arrays.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 501 (RA6 /CE6a / IC1/ 3p) Declara de forma adecuada el array que sea necesario en cada caso:</p> <ul> <li>a. Se quiere almacenar la evoluci\u00f3n del precio del combustible por litro en una gasolinera concreta. Por ejemplo: 1.677 \u20ac/litro.</li> <li>b. Una tienda de ropa necesita almacenar un listado con los productos que van a tener precio rebajado a partir del mes de enero. Por ejemplo: \u201cJersey de lana\u201d</li> <li>c. Se necesita guardar las notas finales de la 1\u00aa evaluaci\u00f3n de un grupo de alumnos.</li> <li>d. El sistema de acceso de una empresa requiere almacenar en un array la letra del dni sus empleados para controlar la entrada a cierta zona restringida.</li> </ul> </li> <li> <p>AC 502 (RA6 /CE6a / IC1/ 3p) Crea el array adecuado para cada caso asign\u00e1ndole los valores que se indican:</p> <ul> <li>a. Se quiere almacenar la evoluci\u00f3n del precio del combustible por litro en una gasolinera concreta durante la \u00faltima semana. 1.677 1.674 1.668 1.668 1.663 1.657 1.655</li> <li>b. Una tienda de ropa necesita almacenar 4 productos que van a tener precio rebajado a partir del mes de enero. Sudadera con bolsillos Chaleco largo acolchado Chaqueta biker Pantal\u00f3n skinny</li> <li>c. Se necesita guardar las notas finales de la 1\u00aa evaluaci\u00f3n de un grupo peque\u00f1o de 5 alumnos. 7 8 4 5 9</li> <li>d. El sistema de acceso de una peque\u00f1a empresa requiere almacenar en un array la letra del dni sus 10 empleados para controlar la entrada a cierta zona restringida. G T B R A K S U E H</li> </ul> </li> </ul>"},{"location":"uutt/ut05/052_Operaciones.html","title":"Operaciones est\u00e1ndar con arrays","text":""},{"location":"uutt/ut05/052_Operaciones.html#insercion-posibles-soluciones-con-java","title":"Inserci\u00f3n. Posibles soluciones con Java","text":"<p>Para acceder a cada elemento del array se utiliza el nombre del array y un \u00edndice entre corchetes que indica la posici\u00f3n que ocupa el elemento dentro del array. Se puede utilizar como \u00edndice un valor entero, una variable de tipo entero o una expresi\u00f3n de tipo entero. Un elemento de un array se puede utilizar igual que cualquier otra variable. Se puede hacer con ellos las mismas operaciones que se pueden hacer con el resto de variables (incremento, decremento, operaciones aritm\u00e9ticas, comparaciones, etc).</p> <p>Si se intenta acceder a un elemento que est\u00e1 fuera de los l\u00edmites del array (un elemento con \u00edndice negativo o con \u00edndice mayor que el que corresponden al \u00faltimo elemento del array), el compilador no avisa del error. El error se producir\u00e1 durante la ejecuci\u00f3n. En ese caso se lanza una excepci\u00f3n <code>java.lang.ArrayIndexOutOfBoundsException</code>. Se puede saber el n\u00famero de elementos del array mediante el atributo <code>length</code>. Podemos utilizar <code>length</code> para comprobar el rango del array y evitar errores de acceso.</p> <p>Por ejemplo, para asignar un valor a un elemento del array que se lee por teclado:</p> <pre><code>import java.util.Scanner;\n\npublic class ejemploOperaciones {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int i, valor;\n        int a[]= new int[10];\n        System.out.print(\"Posici\u00f3n:\");\n        i = sc.nextInt(); // Pedimos la posici\u00f3n del array al que vamos a acceder\n        if(i &gt;= 0 &amp;&amp; i &lt; a.length){ // Si la posici\u00f3n est\u00e1 dentro del array\n            System.out.println(\"Valor:\"); // Pedimos el valor\n            valor = sc.nextInt();\n            a[i]= valor;\n        }else{\n            System.out.println(\"Posici\u00f3n no v\u00e1lida\");\n        }\n    }\n}\n</code></pre> <p>Para recorrer un array se utiliza una instrucci\u00f3n iterativa (normalmente una instrucci\u00f3n <code>for</code>, aunque tambi\u00e9n puede hacerse con <code>while</code> o <code>do\u2026while</code>) utilizando una variable entera como \u00edndice que tomar\u00e1 valores desde el primer elemento al \u00faltimo o desde el \u00faltimo al primero. Por ejemplo, el siguiente fragmento de programa Java declara un array de 7 elementos de tipo <code>double</code> y le asigna valores iniciales. A continuaci\u00f3n recorre el array, , utilizando la instrucci\u00f3n <code>for</code>, para mostrar por pantalla el contenido del array.</p> <pre><code>double[] notas = {2.3, 8.5, 3.2, 9.5, 4, 5.5, 7.0}; //array de 7 elementos\nfor (int i = 0; i &lt; 7; i++) {\n    System.out.print(notas[i] + \" \"); //se muestra cada elemento del array\n}\n</code></pre> <p>Para evitar errores de acceso al array es recomendable utilizar length para recorrer el array completo.</p> <pre><code>double[] notas = {2.3, 8.5, 3.2, 9.5, 4, 5.5, 7.0}; //array de 7 elementos\nfor (int i = 0; i &lt; notas.length; i++) {\n    System.out.print(notas[i] + \" \"); //se muestra cada elemento del array\n}\n</code></pre> <p>A partir de Java versi\u00f3n 5 se incorpora una instrucci\u00f3n <code>for</code> mejorada para recorrer arrays y contenedores en general. Permite acceder secuencialmente a cada elemento del array. La sintaxis general es:</p> <pre><code>for(tipo nombreDeVariable : nombreArray){\n    \u2026\n}\n</code></pre> <ul> <li>tipo: indica el tipo de datos que contiene el array.</li> <li>nombreDeVariable: variable a la que cada iteraci\u00f3n se le asigna el valor de cada elemento del array. Est\u00e1 definida dentro del for por lo que solo es accesible dentro de \u00e9l.</li> <li>nombreArray: es el nombre del array que vamos a recorrer.</li> </ul>"},{"location":"uutt/ut05/052_Operaciones.html#borrado-posibles-soluciones-con-java","title":"Borrado. Posibles soluciones con Java","text":"<p>Las arrays en Java tienen longitudes fijas. Esto significa que tienen un n\u00famero fijo de valores de un solo tipo. La longitud de una arrays se decide en el momento de su creaci\u00f3n. Despu\u00e9s de la creaci\u00f3n, su duraci\u00f3n es fija.</p> <p>Dado que la longitud de la array es fija, no existe una forma est\u00e1ndar de eliminar elementos de ella. Sin embargo, puede crear una nueva array que contenga todos los elementos originales de la array excepto el que desea eliminar. Hay varias formas de lograr eso en Java.</p>"},{"location":"uutt/ut05/052_Operaciones.html#a-partir-de-java-8","title":"A partir de Java 8","text":"<p>Tambi\u00e9n puede aprovechar Stream API para eliminar un elemento de una array. La idea es convertir la array en una secuencia secuencial, filtrar la secuencia para eliminar el elemento dado y acumular los elementos restantes en una nueva array utilizando un colector.</p> <pre><code>import java.util.Arrays;\npublic class Main {\n    public static int[] removeElement(int[] arr, int item) {\n            return Arrays.stream(arr).filter(i -&gt; i != item).toArray();\n        }\n    public static void main(String[] args) {\n        int[] arr = {2, 5, 7, 3, 4, 8, 9};\n        int item = 4;\n        arr = removeElement(arr, item);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n</code></pre>"},{"location":"uutt/ut05/052_Operaciones.html#eliminar-por-indice","title":"Eliminar por \u00edndice","text":"<p>Si tiene el \u00edndice del elemento a eliminar, puede usar el <code>System.arraycopy()</code> m\u00e9todo para garantizar un mejor rendimiento. La idea es asignar una nueva array de tama\u00f1o uno menos que la array original. A continuaci\u00f3n, puede realizar dos llamadas al <code>System.arraycopy()</code> para copiar los elementos de la array en la nueva array antes y despu\u00e9s de ese \u00edndice.</p> <pre><code>import java.util.Arrays;\npublic class Main {\n    public static String[] removeElement(String[] arr, int index) {\n        String[] result = new String[arr.length - 1];\n        System.arraycopy(arr, 0, result, 0, index);\n        if (arr.length != index) {\n            System.arraycopy(arr, index + 1, result, index, arr.length - index - 1);\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n        String[] arr = {\"A\", \"C\", \"B\", \"C\", \"D\"};\n        int index = 1;\n        arr = removeElement(arr, index);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n</code></pre> <p>\u00bfC\u00f3mo \"borramos\"?</p> <p>Como se ha visto, en Java el tama\u00f1o de los arrays es fijo y se define en memoria, por lo que si queremos borrar un elemento debemos rehacer el array. Si no se quiere instanciar un nuevo array, para eliminar el valor, se puede igualar al valor por defecto que se decida. De este modo, el valor se podr\u00eda, mediante programaci\u00f3n, no tener en cuenta y no supondr\u00eda el tener que rehacer el array.</p>"},{"location":"uutt/ut05/052_Operaciones.html#ordenacion-burbuja-e-insercion-directa","title":"Ordenaci\u00f3n: Burbuja e inserci\u00f3n directa","text":"<p>Uno de los procedimientos m\u00e1s comunes y \u00fatiles en el procesamiento de datos, es la ordenaci\u00f3n de los mismos. Se considera ordenar el proceso de reorganizar un conjunto dado de objetos en una secuencia determinada. El objetivo de este proceso generalmente es facilitar la b\u00fasqueda de uno o m\u00e1s elementos pertenecientes a un conjunto. Son ejemplos de datos ordenados las listas de alumnos matriculados en una cierta asignatura, las listas del censo, los \u00edndices alfab\u00e9ticos de los libros, las gu\u00edas telef\u00f3nicas, etc. Esto quiere decir que muchos problemas est\u00e1n relacionados de alguna forma con el proceso de ordenaci\u00f3n. Es por lo que la ordenaci\u00f3n es un problema a considerar. </p> <p>La ordenaci\u00f3n, tanto num\u00e9rica como alfanum\u00e9rica, sigue las mismas reglas que empleamos nosotros en la vida normal. Esto es, un dato es mayor que otro cuando su valor es m\u00e1s grande, y una cadena es mayor que otra cuando est\u00e1 despu\u00e9s por orden alfab\u00e9tico.</p> <p>En esta unidad no trataremos de analizar exhaustivamente todos los m\u00e9todos de ordenaci\u00f3n y ver sus prestaciones de eficiencia, rapidez, etc. sino que simplemente analizaremos desde el punto de vista pr\u00e1ctico los m\u00e9todos m\u00e1s comunes para la ordenaci\u00f3n de arrays.</p>"},{"location":"uutt/ut05/052_Operaciones.html#metodo-de-la-burbuja-bubble-sort","title":"M\u00e9todo de la burbuja (Bubble sort)","text":"<p>Hay muchas formas de ordenar datos, pero una de las m\u00e1s conocidas es la ordenaci\u00f3n por el m\u00e9todo de la burbuja. Consiste en comparar pares de elementos adyacentes en un array y si est\u00e1n desordenados intercambiarlos hasta que est\u00e9n todos ordenados. Si a es el array a ordenar, se realizan <code>a.length-1</code> vueltas o pasadas. Si los elementos adyacentes est\u00e1n desordenados se intercambian.</p> <p>El c\u00f3digo en Java correspondiente al algoritmo de ordenaci\u00f3n por el m\u00e9todo burbuja ser\u00eda el siguiente:</p> <p>No es un buen algoritmo de ordenaci\u00f3n por su elevado tiempo de ejecuci\u00f3n, solamente es recomendable su uso para ordenar listas con un n\u00famero peque\u00f1o de elementos.</p>"},{"location":"uutt/ut05/052_Operaciones.html#metodo-de-insercion-insertion-sort","title":"M\u00e9todo de inserci\u00f3n (Insertion Sort)","text":"<p>El m\u00e9todo de ordenaci\u00f3n por inserci\u00f3n consiste en recorrer todo el array comenzando desde el segundo elemento hasta el final. Para cada elemento, se trata de colocarlo en el lugar correcto entre todos los elementos anteriores a \u00e9l o sea entre los elementos a su izquierda en el array. Dada una posici\u00f3n actual p, el algoritmo se basa en que los elementos <code>a[0], a[1]</code>, ..., <code>a[p-1]</code> ya est\u00e1n ordenados.</p> <p>Este m\u00e9todo tambi\u00e9n puede ser optimizado: en lugar de intercambiar el elemento analizado con cada uno de los mayores hallados a su izquierda, puede modificarse el algoritmo para que el elemento analizado solo se inserte en su posici\u00f3n final de forma que se evitan las asignaciones intermedias innecesarias. Se trata del m\u00e9todo de ordenaci\u00f3n conocido como Inserci\u00f3n Directa (Direct Insertion Sort). El c\u00f3digo es el siguiente:</p>"},{"location":"uutt/ut05/052_Operaciones.html#metodo-de-seleccion-selection-sort","title":"M\u00e9todo de selecci\u00f3n (Selection Sort)","text":"<p>El m\u00e9todo de ordenaci\u00f3n por selecci\u00f3n consiste en realizar los siguientes pasos:</p> <ul> <li>Se busca el elemento m\u00e1s peque\u00f1o del array y se coloca en la primera posici\u00f3n.</li> <li>Entre los restantes, se busca el elemento m\u00e1s peque\u00f1o y se coloca en la segunda posici\u00f3n.</li> <li>Entre los restantes, se busca el elemento m\u00e1s peque\u00f1o y se coloca en la tercera posici\u00f3n.</li> <li>\u2026</li> <li>Este proceso se repite hasta colocar el \u00faltimo elemento.</li> </ul> <p>El c\u00f3digo en Java para este algoritmo de ordenaci\u00f3n es el siguiente:</p>"},{"location":"uutt/ut05/052_Operaciones.html#busqueda-secuencial-y-binaria","title":"B\u00fasqueda: Secuencial y binaria","text":"<p>Java define la clase Arrays con m\u00e9todos que permiten realizar operaciones de ordenaci\u00f3n y b\u00fasqueda en objetos de tipo array. Estos m\u00e9todos se pueden utilizar con todos los tipos primitivos, <code>String</code> y con cualquier otro tipo de objeto. Para ordenar arrays de cualquier tipo Java dispone del m\u00e9todo <code>sort</code> de la clase <code>Arrays</code>.</p> <p>Para utilizarlo es necesario incluir el <code>import</code>: <pre><code>import java.util.Arrays;\n</code></pre> Por ejemplo, dado el siguiente array de Strings: <pre><code>String [] nombres = {\"juan\", \"pedro\", \"ana\", \"maria\", \"felipe\", \"luis\", \"miguel\"}; \n</code></pre> para ordenarlo de forma ascendente escribiremos la instrucci\u00f3n: <code>Arrays.sort(nombres)</code>;</p> <p>Otros m\u00e9todos de la clase Arrays son:</p> <ul> <li><code>Arrays.binarySearch(array-de-datos, clave)</code>. Busca la clave indicada en el array de n\u00fameros enteros. <code>Arrays.binarySearch(numeros, 1991)</code> busca el n\u00famero 1991 en el array n\u00fameros.</li> <li><code>Arrays.fill(array-de-datos, dato)</code>. Rellena el array con el valor dado. Se puede utilizar con todo los tipos primitivos, String y con cualquier otro tipo de objeto. <code>Arrays.fill(numeros, 5)</code> rellena con el valor 5 todo el array n\u00fameros.</li> <li><code>Arrays.fill(array-de-datos, dato, inicio, fin)</code>. Rellena el array con el valor dado, indicando la posici\u00f3n inicial y final. <code>Arrays.fill(numeros, 5, 0, 5)</code> rellena con el valor 5 desde la posici\u00f3n 0 hasta la posici\u00f3n 5 del array numeros.</li> <li><code>Arrays.copyOf(array-origen, longitud)</code>. Construye y devuelve una copia de <code>array-origen</code> con la longitud especificada. Si la longitud del nuevo array es menor que la del original, solo se copian los elementos que caben. En caso contrario, los elementos extras se inicializan por defecto.     <pre><code>int[] t = {1, 2, 1, 6, 23}; //array origen\nint[] a, b; //arrays destino\na = Arrays.copyOf(t, 3); //a = [1, 2, 1]\nb = Arrays.copyOf(t, 10); //b = [1, 2, 1, 6, 23, 0, 0, 0, 0, 0]\n</code></pre></li> <li><code>Arrays.copyOfRange(array-origen, desde, hasta)</code>. Crea y devuelve un array donde se han copiado los elementos de array-origen comprendidos entre los \u00edndices desde y hasta, sin incluir este \u00faltimo.     <pre><code>int[] t = {7, 5, 3, 1, 0, -2};\nint[] a = Arrays.copyOfRange(t, 1, 4); //a = [5, 3, 1]\n</code></pre></li> </ul> <p><code>Arrays.sort</code> ordena de forma ascendente (de menor a mayor). Para ordenar un array de forma descendente (de mayor a menor) hay que indicarlo utilizando el m\u00e9todo <code>reverseOrder()</code> de la clase <code>Collections</code>. Como en este tema no se trabaja con colecciones, este m\u00e9todo lo deber\u00edas de programar y tenerlo en vuestro fichero de m\u00e9todos de utilidad.    </p>"},{"location":"uutt/ut05/052_Operaciones.html#actividades","title":"Actividades","text":"<p>A tener en cuenta en las actividades</p> <p>No est\u00e1 permitido el uso de los m\u00e9todos de la clase <code>Arrays</code>. En caso de que se use el m\u00e9todo <code>sort()</code>se anular\u00e1 el ejercicio; cualquier otro m\u00e9todo ser\u00e1 penalizado pero el ejercicio ser\u00e1 puntuado.</p> <ul> <li> <p>AC 503 (RA6 /CE6a / IC1 / 3p) Crea un programa que guarde en un array 10 n\u00fameros enteros le\u00eddos desde el teclado. A continuaci\u00f3n se deber\u00e1 recorrer el array y calcular cu\u00e1ntos n\u00fameros son positivos y cu\u00e1ntos negativos y as\u00ed como sus respectivos promedios (medias).</p> </li> <li> <p>AC 504 (RA6 /CE6a / IC1 / 3p) Genera un programa que lea 5 n\u00fameros por entrada est\u00e1ndar y los muestre por pantalla en orden inverso al introducido.</p> </li> <li> <p>AC 505 (RA6 /CE6a / IC1 / 3p) Realiza un programa que lea por teclado la nota de los alumnos de una clase y calcule la nota media del grupo. Tambi\u00e9n debe mostrar los alumnos con notas superiores a la media. El n\u00famero de alumnos se lee por teclado. El array debe terminar ordenado de menor a mayor nota.</p> </li> <li> <p>AC 506 (RA6 /CE6a / IC1 / 3p) En nuestro pa\u00eds cada persona est\u00e1 identificada con un DNI en el que figura un n\u00famero y una letra, por ejemplo 56999545-W. Crea un programa que calcule la letra de un DNI a partir del n\u00famero que introduzca el usuario. Es decir, se debe pedir el DNI sin la letra por teclado y el programa nos devolver\u00e1 el DNI completo (con la letra). Para calcular la letra, se debe tomar el resto de dividir nuestro n\u00famero de DNI entre 23. El resultado debe estar por tanto entre 0 y 22.</p> </li> <li> <p>AC 507 (RA6 /CE6a / IC1 / 3p) En teor\u00eda hemos visto el m\u00e9todo Array.equals. Imagina que la clase Arrays no existe. Implementa t\u00fa el m\u00e9todo equals que compare si dos arrays pasados por par\u00e1metro son iguales (mismos elementos en el mismo orden).</p> </li> <li> <p>AC 508 (RA6 /CE6a / IC1 / 3p) Implementa otra versi\u00f3n del m\u00e9todo equals que compare si dos arrays son iguales, pero ahora teniendo en cuenta que dos arrays son iguales si tienen los mismos elementos, sin importar el orden.</p> <p>Ayuda</p> <p>Puedes hacerlo ordenando primero los arrays y luego compar\u00e1ndolos elemento a elemento como hicimos en el ejercicio 9 o puedes hacerlo creando en el m\u00e9todo un nuevo array que realice un seguimiento de las posiciones que ya han sido comprobadas y no las tenga en cuenta.</p> </li> <li> <p>AC 509 (RA6 /CE6a / IC1 / 3p) Crea un m\u00e9todo para comprobar si un array contiene otro. El m\u00e9todo devuelve true si el array fuente est\u00e1 contenido en el array destino, es decir, si todos sus elementos est\u00e1n en el array destino.     <pre><code>public static boolean isArrayOn(int[] src, int [] dst) {}\n</code></pre></p> </li> <li>AC 510 (RA6 /CE6a / IC1 / 3p) Crea un programa que dado un array insertado por el usuario, lea los valores, los inserte en un array, ordene el array en orden ascendente y muestre por pantalla el array ordenado. Para ordenar el array, deber\u00e1s copiar el array que se pasa por par\u00e1metro en un nuevo array, ordenar ese nuevo array y devolverlo.     <pre><code>public static int[] ordenarArray(int[] array) {}\n</code></pre></li> <li> <p>PR 511 (RA6 /CE6a / IC2 / 5p) Vamos a crear una clase \u00faltil, como las que encontramos dentro del paquete java.util relacionadas con arrays. Llama a esta clase <code>ArrayOperations.java</code>. Dentro crearemos m\u00e9todos est\u00e1ticos, por tanto, aseg\u00farate que sea una clase est\u00e1tica y nadie pueda llamar al constructor. Al ser est\u00e1ticos los m\u00e9todos, se utilizar\u00e1n de la forma <code>ArrayOperations.reverse(array)</code>. La clase debe incluir los siguientes m\u00e9todos (algunos realizados en pr\u00e1cticas anteriores):</p> <ul> <li>a. M\u00e9todo print que imprima el array con formato [1, 2, 3]. No utilices el m\u00e9todo <code>Arrays.toString</code>, se trata de que lo programes t\u00fa.</li> <li>b. El m\u00e9todo reverse. Invierto un array.</li> <li>c. Un m\u00e9todo que devuelva el m\u00e1ximo elemento del array, llamado max. public static int max(int[] array)</li> <li>d. Un m\u00e9todo que devuelve el m\u00ednimo elemento del array, llamado min. public static int min(int[] array)</li> <li>e. M\u00e9todo que realice la suma del array. public static int sum(int[] array)</li> <li>f. El m\u00e9todo equals que devuelva un booleano si dos arrays son iguales.</li> <li>g. El m\u00e9todo equals, llamado equalsWithoutOrder. Que comprueba si dos arrays son iguales sin importar el orden. [1,2,4,3] es igual a [1,2,3,4]</li> <li>h. M\u00e9todo isArrayOn (AC509).</li> <li>i. M\u00e9todo sort (AC 510). Este m\u00e9todo se modifica ligeramente, ya que no hay que crear un nuevo array y devolverlo. Se ordena el array pasado por par\u00e1metro. <code>public static void sort(int[] array)</code></li> <li>j. M\u00e9todo copy, que copie el array fuente en el destino. En este m\u00e9todo cada array apunta a una referencia distinta. <code>public static void copy(int[] src, int[] dst)</code></li> <li>k. M\u00e9todo removeOddNumbers que elimine del array los n\u00fameros impares. Es decir, cuando encuentre un n\u00famero impar establezca un 0 en la celda. <code>public static void removeOddNumbers(int[] array)</code> Por ejemplo: [1,2,3] \u2192 [0,2,0]</li> </ul> </li> <li> <p>PR 512 (RA6 /CE6a / IC2 / 5p) Se solicita crear un programa que haga las veces de una libreta de profesor. Para ello se deber\u00e1 trabajar con Arrays y m\u00e9todos. El programa ha de realizar las siguientes funciones:</p> <ul> <li>Poder poner notas</li> <li>Sacar la nota m\u00e1s alta y la posici\u00f3n.</li> <li>Calcular la media de la clase quitando la nota m\u00e1s alta y m\u00e1s baja.</li> <li>Borrar notas pero no la posici\u00f3n</li> <li>Actualizar una nota en concreto</li> </ul> <p>Se ha de usar todo lo aprendido en Arrays y en el manejo de funciones.</p> </li> </ul>"},{"location":"uutt/ut05/053_ArrayCaracteres.html","title":"Array de caracteres","text":"<p>Un array de caracteres es un array que contiene datos de tipo char. Los arrays de caracteres en Java se crean de forma similar a un array unidimensional de cualquier otro tipo de datos. A diferencia de los dem\u00e1s arrays, se puede mostrar el contenido completo de un array de caracteres mediante una sola instrucci\u00f3n <code>print</code> o <code>printf</code>.</p> <p>Mostrar\u00e1: <code>aeiou</code></p> <p>El resto de operaciones son las mismas que las vistas para el resto de arrays. A esto hay que sumarle todas las funciones propias que vimos en temas pasados para el manejo de <code>Strings</code>, siendo de especial relevancia los de comparaci\u00f3n.</p>"},{"location":"uutt/ut05/054_ArrayMultidimensional.html","title":"Arrays multidimensionales","text":""},{"location":"uutt/ut05/054_ArrayMultidimensional.html#concepto-de-matriz","title":"Concepto de matriz","text":"<p>Un array en Java puede tener m\u00e1s de una dimensi\u00f3n. El caso m\u00e1s general son los arrays bidimensionales tambi\u00e9n llamados matrices o tablas. La dimensi\u00f3n de un array la determina el n\u00famero de \u00edndices necesarios para acceder a sus elementos. Los vectores que hemos visto hasta ahora son arrays unidimensionales porque solo utilizan un \u00edndice para acceder a cada elemento. Pero una matriz necesita dos \u00edndices para el acceso a sus elementos. </p> <p>Gr\u00e1ficamente podemos representar una matriz como una tabla de n filas y m columnas cuyos elementos son todos del mismo tipo. La siguiente figura representa un array denominado M de 3 filas y 5 columnas:</p> <p>Pero en realidad una matriz en Java es un array de arrays. Gr\u00e1ficamente podemos representar la disposici\u00f3n real en memoria del array anterior as\u00ed:</p> <p>La longitud del array M (<code>M.lentgh</code>) es 3. La longitud de cada fila del array (<code>M[i].length</code>) es 5. Para acceder a cada elemento de la matriz se utilizan dos \u00edndices. El primero indica la fila y el segundo la columna. De esta forma vemos que el elemento <code>M[1][3]</code> tiene valor 8. Se crean de forma similar a los arrays unidimensionales, a\u00f1adiendo un \u00edndice. Por ejemplo, para declarar una matriz de datos de tipo int llamada ventas de 4 filas y 6 columnas:</p> <pre><code>int [][] ventas = new int[4][6];\n</code></pre>"},{"location":"uutt/ut05/054_ArrayMultidimensional.html#inicializacion-de-matrices","title":"Inicializaci\u00f3n de matrices","text":"<p>Un array es un objeto, por lo tanto, cuando se crea, a sus elementos se les asigna autom\u00e1ticamente un valor inicial. Tambi\u00e9n podemos dar otros valores iniciales al array cuando se crea. Los valores iniciales se escriben entre llaves separados por comas. Los valores que se le asignen a cada fila aparecer\u00e1n a su vez entre llaves separados por comas. El n\u00famero de valores determina el tama\u00f1o de la matriz.</p> <p>Por ejemplo: <code>int [][] n\u00fameros = {{6,7,5}, {3, 8, 4}, {1,0,2}, {9,5,2}};</code></p> <p>se crea la matriz n\u00fameros de tipo int, de 4 filas y 3 columnas, y se le asignan esos valores iniciales.</p> <p>Recorriendo matrices</p> <p>Para recorrer una matriz se anidan dos bucles <code>for</code>. En general, para recorrer un array multidimensional se anidan tantas instrucciones <code>for</code> como dimensiones tenga el array.</p> Recorriendo matriz 4x4<pre><code>  int[][] matrix = new int[4][4];\n  for (int i = 0; i &lt; matrix.length; i++){\n    System.out.print(\"row \" + i + \" : \");\n    for (int j = 0; j &lt; matrix[i].length; j++){\n      System.out.print(\"col \" + j + \"  \");\n    }\n    System.out.println();\n  }\n</code></pre>"},{"location":"uutt/ut05/054_ArrayMultidimensional.html#actividad","title":"Actividad","text":"<ul> <li>PR 513 (RA6 /CE6a / IC2 / 5p) Se solicita crear la APP de los GymBros. Para ello vamos a usar una matriz en la que almacenaremos el progreso de una semana. La APP nos permitir\u00e1 realizar las siguientes funciones:<ul> <li>Introducir peso diario, el d\u00eda que se introduzca ser\u00e1 la posici\u00f3n del array menos 1. Todos los d\u00edas se introducir\u00e1n todos los pesos de:<ul> <li>Back Squat</li> <li>Front Squat</li> <li>Bench Press</li> <li>Dead Lift</li> </ul> </li> <li>La opci\u00f3n de ordenar los pesos por ejercicio, de menor a mayor de cada uno de los ejercicios y mostrarlo por pantalla.</li> <li>Calcular el RM de todos los ejercicios y mostrar el n\u00famero del d\u00eda de la semana original.</li> <li>Mostrar los d\u00edas que has entrenado el ejercicio.</li> </ul> </li> </ul>"},{"location":"uutt/ut05/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 05","text":""},{"location":"uutt/ut05/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA6.CE <ul> <li>Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos.</li> </ul> <ul> <li>a. Se han escrito programas que utilicen matrices (arrays).</li> </ul>"},{"location":"uutt/ut05/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li>Arrays    <ol> <li>Arrays de tipo nativo y de objetos</li> <li>Declaraci\u00f3n</li> <li>Instancia</li> <li>Inicializaci\u00f3n </li> </ol> </li> <li>Operaciones est\u00e1ndar con arrays<ol> <li>Inserci\u00f3n. Posibles soluciones con Java</li> <li>Borrado. Posibles soluciones con Java</li> <li>Ordenaci\u00f3n: Burbuja e inserci\u00f3n directa</li> <li>B\u00fasqueda: Secuencial y binaria</li> </ol> </li> <li>Array de caracteres</li> <li>Arrays multidimensionales<ol> <li>Concepto de matriz</li> <li>Inicializaci\u00f3n de matrices</li> </ol> </li> </ol>"},{"location":"uutt/ut05/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>31/10/2024</p> <p>Arrays</p> <p>AC 501AC 502</p> <p>02</p> <p>31/10/2024</p> <p>Operaciones est\u00e1ndar con arrays</p> <p>AC 503</p> <p>03</p> <p>4/11/2024</p> <p></p> <p>AC 504AC 505</p> <p>04</p> <p>4/11/2024</p> <p></p> <p>AC 506AC 507</p> <p>05</p> <p>5/11/2024</p> <p></p> <p>AC 508AC 509</p> <p>06</p> <p>6/11/2024</p> <p></p> <p>AC 510</p> <p>07</p> <p>6/11/2024</p> <p></p> <p>Trabajo en clase</p> <p>08</p> <p>7/11/2024</p> <p></p> <p>PR 511</p> <p>09</p> <p>7/11/2024</p> <p></p> <p>PR 512</p> <p>10</p> <p>8/11/2024</p> <p>Array multidimensional</p> <p></p> <p>11</p> <p>11/11/2024</p> <p></p> <p>PR 513</p> <p>12</p> <p>11/11/2024</p> <p></p> <p>Trabajo en clase</p> <p>13</p> <p>12/11/2024</p> <p></p> <p>Trabajo en clase</p> <p>14</p> <p>13/11/2024</p> <p></p> <p>PO UT 05</p> <p>15</p> <p>13/11/2024</p> <p></p> <p>PO UT 05</p> <p>16</p> <p>14/11/2024</p> <p></p> <p>Trabajo en clase</p>"},{"location":"uutt/ut05/ResumenUT.html#referencias","title":"Referencias","text":"<ul> <li>Web: Arrays Java</li> <li>Web: Tutorial Java</li> <li>Web: Documentaci\u00f3n Oficial</li> </ul>"},{"location":"uutt/ut05/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":"<ul> <li>Web: Resumen arrays</li> <li>Web: Repaso Java</li> <li>Web: Arrays est\u00e1ticos</li> <li>V\u00eddeo: Arrays en Java: todo lo que necesitas saber para empezar </li> <li>V\u00eddeo: Curso Java Arrays I.</li> </ul>"},{"location":"uutt/ut06/0610_SetterGetter.html","title":"Setters y Getters","text":"<p>Cuando queremos exponer un atributo como si fuera p\u00fablico deber\u00edamos hacerlo a trav\u00e9s de m\u00e9todos <code>getter</code> (lectura) y <code>setter</code> (escritura). Existe la convenci\u00f3n de nombrar a estos m\u00e9todos utilizando los prefijos <code>get</code> y <code>set</code> seguido del atributo. En general es una buena idea seguir cada una de las convenciones adoptadas por una comunidad, en este caso utilizar los <code>getters</code> y los <code>setters</code> para acceder a atributos privados.</p> <pre><code>public class Automovil {\n    private String marca;\n    public String getMarca(){\n        return marca;\n    }\n\n    public void setMarca(String marca){\n        this.marca = marca;\n    }\n}\n</code></pre> <p>Esta es la manera correcta de trabajar con objetos y sus par\u00e1metros si no conocemos los valores exactos necesarios a la hora de instanciar un objeto o bien para trabajar con ellos de una manera m\u00e1s \u00f3ptima.</p> <p>Pide el comod\u00edn de tu IDE</p> <p>Los IDE tienen un generador de estos m\u00e9todos, investiga la manera de hacerlo pues te ahorrar\u00e1 mucho tiempo.</p>"},{"location":"uutt/ut06/0610_SetterGetter.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 611 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC1 / 3p).Crea una clase COrdenador con los siguientes atributos: marca (Mitac, Toshiba, Ast), procesador (Intel, AMD) y pantalla (TFT, DSTN, STN). </p> <p>Los atributos tambi\u00e9n pueden incluir informaci\u00f3n sobre el estado del objeto:</p> <ul> <li>Estado del dispositivo: encendido, apagado (ordenadorEncendido) </li> </ul> <p>La clase tendr\u00e1 una serie de m\u00e9todos para realizar ciertas acciones:</p> <ul> <li>Encender ordenador (<code>encenderOrdenador()</code> )</li> <li>Apagar ordenador (<code>apagarOrdenador()</code> )</li> <li>Ver estado (<code>estado()</code> )</li> </ul> <p>La clase va a emplear su constructor por defecto por lo que no hay que codificar ninguno. Tampoco es necesario utilizar m\u00e9todos setters y getters puesto que no se acceder\u00e1 a los atributos desde otra clase.</p> <p>En el <code>main</code> realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AC 612 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC1 / 3p). Sup\u00f3n que deseamos modificar el programa de la AC 611:</p> <ul> <li>a. Primero debes utilizar otra clase distinta <code>COrdenadorApp</code> para el m\u00e9todo <code>main</code>. Es decir, tendremos dos clases <code>COrdenador</code> y <code>COrdenadorApp</code>.</li> <li>b. A continuaci\u00f3n, cambia los especificadores de acceso de los atributos a privado y codifica los m\u00e9todos <code>getters</code> y <code>setters</code>.</li> <li>c. Codifica un constructor de la clase al cual se le pasar\u00e1 como par\u00e1metros los atributos de cada objeto de la clase <code>COrdenador</code>.</li> <li>d. Finalmente realiza un cambio en la marca del objeto <code>ord1</code> y vuelve a mostrar el estado.</li> </ul> <p>En el <code>main</code> realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AC 613 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC1 / 3p). Codifica un programa siguiendo estas instrucciones:</p> <ul> <li>Genera un nuevo proyecto llamado <code>PeliculaApp</code>. Este albergar\u00e1 la clase <code>PeliculaApp</code> que contendr\u00e1 el m\u00e9todo <code>main</code>.</li> <li>Crea una segunda clase <code>Pelicula</code> dentro del mismo proyecto. Esta clase contendr\u00e1 los siguientes atributos: T\u00edtulo, Director, G\u00e9nero y Duraci\u00f3n.</li> <li>Genera los m\u00e9todos <code>get</code> y <code>set</code> necesarios para cada atributo.</li> <li> <p>Crea el m\u00e9todo <code>toTexto()</code> para mostrar la informaci\u00f3n relativa a la pel\u00edcula con el siguiente formato: </p> <ul> <li>\u201cLa pel\u00edcula titulada [Titulo] de g\u00e9nero [G\u00e9nero] dirigida por [Director] tiene una duraci\u00f3n de [Duraci\u00f3n] minutos\u201d.</li> </ul> </li> <li> <p>Crea 2 objetos Pel\u00edcula (los valores que se quieran) y mu\u00e9stralos por pantalla.</p> </li> <li>Indica cu\u00e1l de los 2 tiene mayor duraci\u00f3n.</li> </ul> <p>En el main realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AC 614 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC1 / 3p). Se quiere calcular el \u00e1rea de un terreno a partir de sus coordenadas. Para ello:</p> <ul> <li>Crea una clase llamada <code>Posicion</code> con los atributos x, y (coordenadas) y una clase principal <code>PosicionMain</code> que contenga el m\u00e9todo <code>main</code>.</li> <li>Crea un m\u00e9todo que calcule el \u00e1rea del terreno de la siguiente figura, teniendo en cuenta que: \u00c1rea = a * b.</li> </ul> <p>En el main realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AR 615 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC1 / 3p). Escribe una clase <code>Fraccion</code> para representar fracciones. La clase tendr\u00e1 dos atributos de tipo entero: <code>num</code> (numerador) y <code>den</code> (denominador) solo accesibles desde su propia clase. La clase debe contener los constructores y m\u00e9todos adecuados para que este m\u00e9todo <code>main</code> de la clase <code>AppMain</code> funcione de forma correcta:</p> <ul> <li>Se debe controlar que el denominador de una fracci\u00f3n no pueda valer cero. Si el valor del segundo par\u00e1metro es cero en el constructor, se asignar\u00e1 el valor 1 al denominador.</li> <li>Para que una instrucci\u00f3n <code>println</code> como la siguiente: <code>System.out.println(f1 + \" + \" + f2 + \" = \" + suma);</code> muestre por pantalla: <code>1/4 + 1/2 = 3/4</code>, la clase debe tener un m\u00e9todo <code>toTexto()</code> que devuelva un String con el contenido de la fracci\u00f3n de la forma: numerador/denominador.</li> </ul> <p>En el main realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>PR 616 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC2 / 5p). Escribe una clase con el nombre <code>Calculadora</code>. La clase debe tener dos campos o atributos (variable miembro) con los nombres <code>primerNumero</code> y <code>segundoNumero</code>, ambos de tipo <code>double</code>. Codifica los siguientes m\u00e9todos:</p> <ol> <li> <p>Getters:</p> <ul> <li>M\u00e9todo llamado <code>getPrimerNumero</code> sin ning\u00fan par\u00e1metro, debe devolver el valor del campo <code>primerNumero</code>.</li> <li>M\u00e9todo llamado <code>getSegundoNumero</code> sin ning\u00fan par\u00e1metro, debe devolver el valor del campo <code>segundoNumero</code>.</li> </ul> </li> <li> <p>Setters:</p> <ul> <li>M\u00e9todo llamado <code>setPrimerNumero</code> con un par\u00e1metro de tipo <code>double</code>, debe establecer el valor del campo <code>primerNumero</code>.</li> <li>M\u00e9todo llamado <code>setSegundoNumero</code> con un par\u00e1metro de tipo <code>double</code>, debe establecer el valor del campo <code>segundoNumero</code>.</li> </ul> </li> <li> <p>Otros m\u00e9todos:</p> <ul> <li>M\u00e9todo llamado <code>getResultadoSuma</code> sin ning\u00fan par\u00e1metro, debe devolver el resultado de sumar los valores de campo de <code>primerNumero</code> y <code>segundoNumero</code>.</li> <li>M\u00e9todo llamado <code>getResultadoResta</code> sin ning\u00fan par\u00e1metro, debe devolver el resultado de restar los valores de campo de <code>segundoNumero</code> del <code>primerNumero</code>.</li> <li>M\u00e9todo llamado <code>getMultiplicationResult</code> sin ning\u00fan par\u00e1metro, debe devolver el resultado de multiplicar los valores de campo de <code>primerNumero</code> y <code>segundoNumero</code>.</li> <li>M\u00e9todo llamado <code>getDivisionResult</code> sin ning\u00fan par\u00e1metro, debe devolver el resultado de dividir los valores de campo de <code>primerNumero</code> por <code>segundoNumero</code>. En caso de  que el valor de <code>segundoNumero</code> sea 0, devuelve 0.</li> </ul> </li> </ol> <p>Test, c\u00f3digo para probar la clase <code>Calculadora</code>. Escribe este c\u00f3digo en una clase <code>Main</code>, dentro del m\u00e9todo <code>main</code>. Comprueba que realiza correctamente todas las operaciones.</p> <p>Ayuda</p> <p>En total debes tener 8 m\u00e9todos en la clase Calculadora. Los m\u00e9todos NO deben ser public static, solo public.</p> <p>Genera un m\u00e9todo <code>main</code> donde pruebes todos los m\u00e9todos. Recuerda que siempre que se puedan pedir datos por teclado, se han de pedir</p> </li> <li> <p>PR 617 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC2 / 5p). Codifica una clase <code>Persona</code>. La clase debe tener tres campos con los nombres nombre, apellido de tipo String y edad de tipo entero. Escribe los siguientes m\u00e9todos:</p> <ol> <li> <p>Getters:</p> <ul> <li>M\u00e9todo llamado <code>getNombre</code> sin ning\u00fan par\u00e1metro, debe devolver el valor del campo nombre.</li> <li>M\u00e9todo llamado <code>getApellido</code> sin ning\u00fan par\u00e1metro, debe devolver el valor del campo apellido.</li> <li>M\u00e9todo llamado <code>getEdad</code> sin ning\u00fan par\u00e1metro, debe devolver el valor del campo de edad.</li> </ul> </li> <li> <p>Setters:</p> <ul> <li>M\u00e9todo llamado <code>setNombre</code> con un par\u00e1metro de tipo <code>String</code>, debe establecer el valor del campo nombre.</li> <li>M\u00e9todo llamado <code>setApellido</code> con un par\u00e1metro de tipo <code>String</code>, debe establecer el valor del campo apellido.</li> <li>M\u00e9todo llamado <code>setEdad</code> con un par\u00e1metro de tipo <code>int</code>, debe establecer el valor del campo de edad. Si el par\u00e1metro es menor que 0 o mayor que 100, establece el valor del campo de edad en 0.</li> </ul> </li> <li> <p>Otros m\u00e9todos:</p> </li> </ol> <ul> <li>El m\u00e9todo llamado <code>esAdolescente</code> sin ning\u00fan par\u00e1metro, debe devolver verdadero si el valor del campo de edad es mayor que 12 y menor que 20; de lo contrario, devuelve falso.</li> <li>M\u00e9todo llamado <code>getFullName</code> sin ning\u00fan par\u00e1metro, debe devolver el nombre completo de la persona. En caso de que los campos nombre y apellido est\u00e9n vac\u00edos, las cadenas devuelven una cadena vac\u00eda. En caso de que apellido sea una cadena vac\u00eda, devuelva nombre. En caso de que nombre sea una cadena vac\u00eda, devuelve apellido.</li> </ul> <p>isEmpty</p> <p>Para verificar si un String est\u00e1 vac\u00edo, usa el m\u00e9todo <code>isEmpty</code> de la clase <code>String</code>. Por ejemplo, <code>nombre.isEmpty()</code> devuelve verdadero si el String est\u00e1 vac\u00edo o en otras palabras, cuando el String no contiene ning\u00fan car\u00e1cter.</p> <p>Recuerda que siempre que se puedan pedir datos por teclado, se han de pedir.</p> </li> <li> <p>PR 618 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC2 / 5p). Codifica una clase con el nombre <code>Muro</code>. La clase necesita dos campos (variables de instancia) con nombre ancho y alto de tipo double. La clase debe tener dos constructores. El primer constructor (constructor por defecto sin par\u00e1metros). El segundo constructor tiene los par\u00e1metros de ancho y alto de tipo <code>double</code> y debe inicializar los campos. En caso de que el ancho sea menor que 0, debe establecer el valor del campo de ancho en 0, en caso de que el par\u00e1metro de altura sea menor que 0, debe establezca el valor del campo de altura en 0.</p> <p>Escribe los siguientes m\u00e9todos (m\u00e9todos de instancia):</p> <ul> <li>M\u00e9todo llamado <code>getAncho</code> sin ning\u00fan par\u00e1metro, devuelve el valor del campo ancho.</li> <li>M\u00e9todo llamado <code>getAlto</code> sin ning\u00fan par\u00e1metro, devuelve el valor del campo alto.</li> <li>M\u00e9todo llamado <code>setAncho</code> con un par\u00e1metro de tipo <code>double</code>, establece el valor del campo ancho. Si el par\u00e1metro es menor que 0, establece el valor del campo ancho en 0.</li> <li>M\u00e9todo llamado <code>setAlto</code> con un par\u00e1metro de tipo <code>double</code>, establece el valor del campo  alto. Si el par\u00e1metro es menor que 0, establece el valor del campo alto en 0.</li> <li>M\u00e9todo llamado <code>getArea</code> sin ning\u00fan par\u00e1metro, devuelve el \u00e1rea del muro.</li> </ul> <p>Genera un m\u00e9todo <code>main</code> donde pruebes todos los m\u00e9todos. Recuerda que siempre que se puedan pedir datos por teclado, se han de pedir.</p> </li> <li> <p>PR 619 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC2 / 5p). La compa\u00f1\u00eda Mundo Alfombra te ha pedido que escribas una aplicaci\u00f3n que calcule el precio de las alfombras para habitaciones rectangulares. Para calcular el precio, se multiplica el \u00e1rea del piso (ancho por largo) por el precio por metro cuadrado de alfombra. </p> <p>Ejemplo</p> <p>El \u00e1rea de un piso que mide 12 metros de largo y 10 metros de ancho es 120 metros cuadrados, cubrir el piso con una alfombra que cuesta 8\u20ac por metro cuadrado costar\u00eda 960\u20ac.</p> <p>Vamos a crear las siguientes clases con sus constructores y m\u00e9todos:</p> <ul> <li> <p>Codifica una clase con el nombre <code>Suelo</code>. La clase necesita dos campos (variables de instancia) con nombre ancho y largo de tipo <code>double</code>. La clase debe tener un constructor con par\u00e1metros ancho y largo de tipo double y debe inicializar los campos. En caso de que el par\u00e1metro de ancho sea menor que 0, se establecer\u00e1 el valor del campo ancho en 0, en caso de que el par\u00e1metro largo sea menor que 0, se establecer\u00e1 el valor del campo largo en 0. Escribe los siguientes m\u00e9todos (m\u00e9todos de instancia):</p> <ul> <li>M\u00e9todo llamado <code>getArea</code> sin ning\u00fan par\u00e1metro, devuelve el \u00e1rea calculada (ancho * largo).</li> <li>M\u00e9todo llamado <code>getArea</code> con un par\u00e1metro, devuelve el \u00e1rea calculada (ancho * ancho). Es cuadrada.</li> </ul> </li> <li> <p>Desarrolla una clase llamada <code>Alfombra</code> con un campo llamado coste de tipo <code>double</code>. Incluye el constructor de la clase con un par\u00e1metro para inicializar el campo coste. En caso de que el par\u00e1metro coste sea menor que 0, se establecer\u00e1 el valor del campo coste en 0. A\u00f1ade el siguiente m\u00e9todo:</p> <ul> <li>M\u00e9todo llamado <code>getCoste</code> sin ning\u00fan par\u00e1metro, devuelve el valor del campo coste.</li> </ul> </li> <li> <p>Escribe una clase con el nombre <code>Calculadora</code> con dos campos (variables de instancia) suelo de tipo <code>Suelo</code> y alfombra de tipo <code>Alfombra</code>. Codifica el constructor parametrizado con los par\u00e1metros de suelo de tipo <code>Suelo</code> y alfombra de tipo <code>Alfombra</code> e inicializa los campos. A\u00f1ade el siguiente m\u00e9todo en la clase:</p> <ul> <li>M\u00e9todo <code>getCosteTotal</code> sin ning\u00fan par\u00e1metro, devuelve el coste total calculado para cubrir el piso con una alfombra.</li> </ul> </li> </ul> <p>Genera un m\u00e9todo <code>main</code> donde pruebes todos los m\u00e9todos. Recuerda que siempre que se puedan pedir datos por teclado, se han de pedir. Juega con el c\u00f3digo y crea situaciones de prueba cuando tenemos ancho y largo con valores negativos. Y cuando nos dan un precio de coste negativo. Muestra las salidas por pantalla.</p> </li> <li> <p>PR 620 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC2 / 5p). Crear una clase <code>Figura.java</code>. Escribe un m\u00e9todo llamado area con un par\u00e1metro <code>double</code> llamado radio. El m\u00e9todo debe devolver un valor <code>double</code> que represente el \u00e1rea de un c\u00edrculo, calculada a partir del radio. Si el radio del par\u00e1metro es negativo, devuelve -1.0 para representar un valor no v\u00e1lido.</p> <p>Escribe otro m\u00e9todo sobrecargado con 2 par\u00e1metros x e y (ambos <code>double</code>), donde x e y representan los lados de un rect\u00e1ngulo. El m\u00e9todo debe devolver el \u00e1rea del rect\u00e1ngulo. Si uno o ambos par\u00e1metros es/son negativos, devuelve -1.0 para indicar un valor no v\u00e1lido.</p> <p>Salida</p> <p>INPUT / OUTPUT</p> <ul> <li>area (5.0); devuelve 78.53975</li> <li>area (-1); devuelve -1.0</li> <li>area (5.0, 4.0); devuelve 20.0 (5 * 4 = 20)</li> <li>area (-1.0, 4.0); devuelve -1.0</li> </ul> <p>Ayuda</p> <p>La f\u00f3rmula para calcular el \u00e1rea de un rect\u00e1ngulo es x * y. La f\u00f3rmula para calcular el \u00e1rea de un c\u00edrculo es radio * radio * PI. Para PI, use una constante de la clase de matem\u00e1ticas, por ejemplo, <code>Math.PI</code>;</p> <p>Genera un m\u00e9todo main donde pruebes todos los m\u00e9todos. Recuerda que siempre que se puedan pedir datos por teclado, se han de pedir.</p> </li> <li> <p>AP 621 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC2 / 5p). En un restaurante se requiere de un sistema de clasificaci\u00f3n de pedidos de comida en funci\u00f3n de la dieta a la que pertenezcan. Para ello se deber\u00e1n desarrollar las dos clases que se proponen a continuaci\u00f3n:</p> <ul> <li><code>PedidosComida</code>: con atributos tipoDieta, <code>tiempoCoccion</code> y calor\u00edas y m\u00e9todos <code>caloriasHora</code>, que recibe dos enteros (tiempo y calor\u00edas de la receta) y devuelve las calor\u00edas en una hora, <code>rebajarCalorias</code>, que recibe las calor\u00edas que se le rebajan a la receta, y <code>aumentarCalorias</code>, que recibe las calor\u00edas que se aumentan.</li> <li><code>MainComida</code>: tiene dos m\u00e9todos, main y menu.</li> </ul> <p>El men\u00fa dar\u00e1 las siguientes opciones:</p> <ul> <li>Solicitar n\u00famero de pedidos a llenar.</li> <li>Llenar todos los pedidos</li> <li>Seleccionar el pedido que se quiere modificar.</li> <li>Contar los pedidos de m\u00e1s de 500 calor\u00edas.</li> <li>Borrar todos los pedidos.</li> </ul> <p>C\u00e1lculos</p> <p>En los c\u00e1lculos, una comida, por ejemplo, tiene 100 calor\u00edas y se tarda en hacer 100 minutos, si aumento en 10 calor\u00edas aumentar\u00e9 en 10 minutos. Por lo que pasar\u00e1 a tener 110 calor\u00edas y un tiempo de cocci\u00f3n de 110 minutos. Si tras esto, decido bajarle 20 calor\u00edas, que ser\u00eda un 18% de las 110, el tiempo bajar\u00eda tambi\u00e9n un 18%, qued\u00e1ndose en 90,2 minutos de cocci\u00f3n. </p> </li> <li> <p>AP 622 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC2 / 5p). Escribe una clase con el nombre Calculadora. La clase debe tener dos Atributos con los nombres <code>primerNumero</code> y <code>segundoNumero</code>, ambos de tipo double y privados. Codifica los siguientes m\u00e9todos:</p> <ul> <li>M\u00e9todo llamado <code>getResultadoSuma</code> sin ning\u00fan par\u00e1metro, debe devolver el resultado de sumar los valores de campo de <code>primerNumero</code> y <code>segundoNumero</code>.</li> <li>M\u00e9todo llamado <code>getResultadoResta</code> sin ning\u00fan par\u00e1metro, debe devolver el resultado de restar los valores de campo de <code>segundoNumero</code> del <code>primerNumero</code>.</li> <li>M\u00e9todo llamado <code>getMultiplicationResult</code> sin ning\u00fan par\u00e1metro, debe devolver el resultado de multiplicar los valores de campo de <code>primerNumero</code> y <code>segundoNumero</code>.</li> <li>M\u00e9todo llamado <code>getDivisionResult</code> sin ning\u00fan par\u00e1metro, debe devolver el resultado de dividir los valores de campo de <code>primerNumero</code> por <code>segundoNumero</code>. En caso de  que el valor de <code>segundoNumero</code> sea 0, devuelve 0.</li> </ul> <p>Escribe este c\u00f3digo en una clase <code>MainCalculadora</code> en la que tengas al menos dos m\u00e9todos: el propio main y dos m\u00e9todos men\u00fa. El men\u00fa principal:</p> <ul> <li>Indique cuantas calculadoras vas a crear</li> <li>Seleccionas y rellenes una calculadora en concreto.</li> <li>Operar con una calculadora en concreto. Se lanzar\u00e1 el segundo men\u00fa que permitir\u00e1 escoger las operaciones a realizar. Si el objeto no est\u00e1 inicializado por el usuario, se deber\u00e1 inicializar.</li> <li>Salir del programa</li> </ul> </li> </ul>"},{"location":"uutt/ut06/061_ConceptosPrevio.html","title":"Conceptos previos","text":"<p>Java es un lenguaje orientado a objetos, es decir su paradigma principal (modelo o estilo de programaci\u00f3n) es la POO (Programaci\u00f3n Orientada a Objetos). La POO permite abstraernos un nivel m\u00e1s y construir sistemas de mayor complejidad de una forma sencilla y organizada dividiendo el problema en subproblemas m\u00e1s simples. </p> <p>Est\u00e1 divisi\u00f3n se realiza en objetos, de forma que cada objeto funcione de forma totalmente independiente. Un objeto es un elemento del programa que posee sus propios datos y su propio funcionamiento. Es decir, un objeto est\u00e1 formado por datos (propiedades) y funciones que es capaz de realizar (m\u00e9todos). Antes de poder utilizar un objeto, se debe definir su clase. La clase es la definici\u00f3n de un tipo de objeto. Al definir una clase lo que se hace es indicar c\u00f3mo funciona un determinado tipo de objetos. Luego, a partir de la clase, podremos crear objetos de ella.</p>"},{"location":"uutt/ut06/061_ConceptosPrevio.html#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":"<p>Encapsulaci\u00f3n o encapsulamiento. Una clase es una encapsulaci\u00f3n porque constituye una caja negra que encierra tanto los datos que almacena cada objeto como los m\u00e9todos que permiten manipularlos. De hecho, no se pueden definir variables (ni funciones) fuera de una clase (es decir no hay variables globales).</p> <p>Abstracci\u00f3n u ocultaci\u00f3n. Por medio de la abstracci\u00f3n conseguimos no detenernos en los detalles concretos de las cosas que no interesen en cada momento, sino generalizar y centrarse en los aspectos que permitan tener una visi\u00f3n global del problema.</p>"},{"location":"uutt/ut06/061_ConceptosPrevio.html#concepto-de-objeto","title":"Concepto de objeto","text":"<p>Un objeto es cualquier entidad representable en un programa inform\u00e1tico, bien sea f\u00edsico (mesa, coche) o bien sea un concepto (transferencia, educaci\u00f3n). Un objeto en un sistema posee: una identidad, un estado y un comportamiento.</p> <p>La identidad determina que cada objeto es \u00fanico, aunque tengan el mismo valor. No existen dos objetos iguales. Lo que s\u00ed puede existir es dos referencias al mismo objeto.</p> <p>El estado marca las condiciones de existencia del objeto dentro del programa. L\u00f3gicamente este estado puede cambiar. Un coche puede estar parado, en marcha, estropeado, funcionando, sin gasolina, etc.</p> <p>El comportamiento determina c\u00f3mo responde el objeto ante peticiones de otros objetos. Por ejemplo, un objeto conductor puede lanzar el mensaje arrancar a un coche. El comportamiento determina qu\u00e9 es lo que har\u00e1 el objeto.</p> <p>Los objetos se manejan por referencias, existir\u00e1 una referencia a un objeto. De modo que esa referencia permitir\u00e1 cambiar los atributos del objeto. Incluso puede haber varias referencias al mismo objeto, de modo que, si una referencia cambia el estado del objeto, el resto (l\u00f3gicamente) mostrar\u00e1 esos cambios. </p> <p>Los objetos pasados por valor no emplean referencias, sino que usan copias de valores concretos. En Java estos objetos son los tipos simples o primitivos: <code>int</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code>, <code>double</code> y <code>boolean</code>. El resto son todos objetos pasados por referencia (incluidos los <code>arrays</code> y <code>Strings</code>).</p>"},{"location":"uutt/ut06/062_Clases.html","title":"Clases","text":"<p>La clase es la unidad fundamental de programaci\u00f3n en Java. Un programa en Java orientado a objetos est\u00e1 formado por un conjunto de clases. La clase es la plantilla para hacer un objeto. Una clase sirve para definir una serie de objetos con propiedades (atributos), comportamientos (operaciones o m\u00e9todos) y sem\u00e1ntica comunes. Hay que pensar en una clase como un molde. A trav\u00e9s de las clases se obtienen los objetos en s\u00ed.</p> <p>Es decir, antes de poder utilizar un objeto se debe definir la clase a la que pertenece, esa definici\u00f3n incluye:</p> <ul> <li>Sus atributos. Es decir, los datos miembros de esa clase. Los datos pueden ser p\u00fablicos (accesibles desde otra clase), privados (solo accesibles desde su propia clase), etc, es decir tener distintos modificadores de acceso. A los atributos tambi\u00e9n se les llama campos.</li> <li>Sus m\u00e9todos. Las funciones miembro de la clase. Son las acciones (u operaciones) que puede realizar la clase. Tambi\u00e9n pueden tener distintos modificadores de acceso.</li> <li>C\u00f3digo de inicializaci\u00f3n. Para crear una clase normalmente hace falta realizar operaciones previas (es lo que se conoce como constructor de la clase).</li> <li>Otras clases. Dentro de una clase se pueden definir otras.</li> </ul> <p>El formato general para crear una clase en Java es:</p> <pre><code>[acceso] class NombreClase {\n    [acceso] [static] tipo atributo1;\n    [acceso] [static] tipo atributo2;\n    [acceso] [static] tipo atributo3;\n    ...\n    [acceso] [static] tipo metodo1(listaDeArgumentos){\n        ...\n    }\n    ...\n}\n</code></pre> <p>Recordad que la palabra opcional static sirve para hacer que el m\u00e9todo o la propiedad a la que precede se pueda utilizar de manera gen\u00e9rica; los m\u00e9todos o propiedades as\u00ed definidos se llaman atributos de clase y m\u00e9todos de clase respectivamente.</p>"},{"location":"uutt/ut06/063_Objetos.html","title":"Objetos","text":"<p>Se les llama instancias de clase, son un elemento en s\u00ed de la clase. Un objeto se crea utilizando el llamado constructor de la clase. El constructor es el m\u00e9todo que permite iniciar el objeto. El objeto se representa mediante una variable. Esta variable contiene la direcci\u00f3n de memoria del objeto.</p> <p>Al contrario de lo que sucede en otros lenguajes como C/C++, en el lenguaje Java no se trabaja con punteros que podamos ver y manejar, pero debemos saber que todas las referencias a un objeto son, de hecho, punteros, es decir, son variables que contienen la direcci\u00f3n de memoria del objeto que representan.</p>"},{"location":"uutt/ut06/063_Objetos.html#datos-propiedades-o-atributos","title":"Datos (propiedades o atributos)","text":"<p>Para poder acceder a los atributos de un objeto, se utiliza esta sintaxis:</p> <pre><code>objeto.atributo;\n</code></pre> <p>Los atributos toman el valor inicial por defecto:</p> <ul> <li>0 para tipos num\u00e9ricos.</li> <li>'\\0' para el tipo <code>char</code>.</li> <li>null para String y resto de referencias a objetos.</li> </ul> <p>Tambi\u00e9n se les puede asignar un valor inicial en la declaraci\u00f3n, aunque lo normal es hacerlo en el constructor. El valor de los atributos en cada momento determina el estado del objeto.</p>"},{"location":"uutt/ut06/063_Objetos.html#metodos","title":"M\u00e9todos","text":"<p>Los m\u00e9todos se utilizan de la misma forma que los atributos, excepto porque los m\u00e9todos poseen siempre par\u00e9ntesis, dentro de los cuales pueden ir valores necesarios para la ejecuci\u00f3n del m\u00e9todo (par\u00e1metros).</p> <p>Una clase puede contener cero o m\u00e1s m\u00e9todos. Definen el comportamiento de los objetos de la clase. A trav\u00e9s de los m\u00e9todos se accede a los datos de la clase. Desde el punto de vista de la POO el conjunto de m\u00e9todos de la clase se corresponde con el conjunto de mensajes a los que los objetos de esa clase pueden responder.</p> <p>Al conjunto de m\u00e9todos de una clase se le llama interfaz de la clase. Es conveniente que todas las clases implementen los m\u00e9todos de acceso o m\u00e9todos setters/getters para cada atributo. El concepto de interfaz se desarrollar\u00e1 en profundidad en temas futuros, pero es interesante que se vaya conociendo lo qu\u00e9 es.</p>"},{"location":"uutt/ut06/063_Objetos.html#creacion-de-objetos-de-una-clase","title":"Creaci\u00f3n de objetos de una clase","text":"<p>Una vez definida la clase, se pueden utilizar objetos de la clase. Normalmente consta de dos pasos. Su declaraci\u00f3n y su creaci\u00f3n (instanciaci\u00f3n).</p>"},{"location":"uutt/ut06/063_Objetos.html#declaracion-de-un-objeto","title":"Declaraci\u00f3n de un objeto","text":"<p>La declaraci\u00f3n consiste en indicar que se va a utilizar un objeto de una clase determinada, y se hace igual que cuando se declara una variable simple o de tipo primitivo, es decir, se crea la referencia al objeto.</p> <pre><code>Vehiculo patinete;\n</code></pre> <p>Esto declara el objeto patinete como objeto de tipo Vehiculo; se supone que previamente se ha definido la clase Vehiculo. La referencia tiene como misi\u00f3n almacenar la direcci\u00f3n de memoria del objeto. En este momento la referencia patinete almacena una direcci\u00f3n de memoria nula (<code>null</code>).</p>"},{"location":"uutt/ut06/063_Objetos.html#instanciacion-de-un-objeto","title":"Instanciaci\u00f3n de un objeto","text":"<p>Mediante la instanciaci\u00f3n o definici\u00f3n de un objeto se reserva un bloque de memoria para almacenar todos los atributos del objeto. Al instanciar un objeto solo se reserva memoria para sus atributos. No se guardan los m\u00e9todos para cada objeto, pues son los mismos y los comparten todos los objetos de la clase. Se emplea el operador <code>new</code>. Mediante este operador se asigna la memoria necesaria para ubicar el objeto y devuelve la direcci\u00f3n de memoria donde empieza el bloque asignado al objeto.</p> <pre><code>patinete = new Vehiculo ();\n</code></pre> <p>Al hacer esta operaci\u00f3n el objeto reserva la memoria que necesita y se inicializa el objeto mediante su constructor. M\u00e1s adelante veremos c\u00f3mo definir el constructor. De este modo ya tenemos todo lo necesario para poder trabajar con nuestro objeto y poder realizar todo lo que nuestro programa necesita.</p>"},{"location":"uutt/ut06/063_Objetos.html#especificadores-de-acceso","title":"Especificadores de acceso","text":"<p>Como hemos visto antes, el concepto de clase incluye la idea de ocultaci\u00f3n de datos, que b\u00e1sicamente consiste en que no se puede acceder a los datos directamente (zona privada), sino que hay que hacerlo a trav\u00e9s de los m\u00e9todos de la clase. De esta forma se consiguen dos objetivos importantes:</p> <ul> <li>Que el usuario no tenga acceso directo a la estructura interna de la clase, para no poder generar c\u00f3digo basado en la estructura de los datos.</li> <li>Si en un momento dado alteramos la estructura de la clase todo el c\u00f3digo del usuario no tendr\u00e1 que ser retocado.</li> </ul> <p>El especificador o modificador de acceso es una palabra que antecede a la declaraci\u00f3n de una clase, m\u00e9todo o propiedad de clase. Se utiliza para definir el nivel de ocultaci\u00f3n o visibilidad de los miembros de la clase (atributos y m\u00e9todos) y de la propia clase. Hay tres posibilidades: <code>public</code>, <code>protected</code> y <code>private</code>. Una cuarta posibilidad es no utilizar ninguna de estas tres palabras; entonces se dice que se ha utilizado el modificador por defecto (<code>package-private</code>).</p> <p>Los especificadores determinan el alcance de la visibilidad del elemento al que se refieren. Referidos por ejemplo a un m\u00e9todo, pueden hacer que el m\u00e9todo sea visible solo para la clase que lo utiliza (<code>private</code>), para esta y las heredadas (<code>protected</code>), para todas las clases del mismo paquete (sin modificador o <code>package-private</code>) o para cualquier clase del tipo que sea (<code>public</code>).</p> <p>La utilizaci\u00f3n del modificador <code>private</code> sirve para implementar una de las caracter\u00edsticas de la programaci\u00f3n orientada a objetos: el ocultamiento de la informaci\u00f3n o encapsulaci\u00f3n. La declaraci\u00f3n como p\u00fablico de un atributo de una clase no respeta este principio de ocultaci\u00f3n de informaci\u00f3n. Declar\u00e1ndolos como privados, no se tiene acceso directo a los atributos del objeto fuera del c\u00f3digo de la clase correspondiente y solo puede accederse a ellos de forma indirecta a trav\u00e9s de los m\u00e9todos proporcionados por la propia clase.</p> <pre><code>Pirata p = new Pirata();\n// con modificador privado\np.setEdad(20);\np.setNombre(\u201cLuffy\u201d);\n// con modificador public\np.banda=\u201dPiratas Sombrero de Paja\u201d;\n// errores frecuentes\np.edad=20;\n\n// El compilador nos avisar\u00e1 del error ya que intentamos acceder de forma directa a un atributo privado.\n</code></pre> <p>Una de las ventajas pr\u00e1cticas de obligar al empleo de un m\u00e9todo para modificar el valor de un atributo es asegurar la consistencia de la operaci\u00f3n, es decir, siempre tendremos un control directo sobre los diferentes estados o valores de los atributos del objeto.</p>"},{"location":"uutt/ut06/064_CrearClases.html","title":"Creaci\u00f3n de clases","text":"<p>Cuando se definen los datos de una determinada clase, se debe indicar el tipo de propiedad o atributo que es (<code>String</code>, <code>int</code>, <code>double</code>, <code>char</code>, ...) y el especificador de acceso (<code>public</code>, <code>private</code>, ...).</p> <p><pre><code>class Persona {\npublic String nombre; //Se puede acceder desde cualquier clase\nprivate int contrasenya; //Solo se puede acceder desde la clase Persona\nprotected String direccion; //A esta propiedad acceden tanto esta clase como sus descendientes\n...... }\n</code></pre> Por lo general, las propiedades de una clase suelen ser privadas o protegidas, a no ser que se trate de un valor constante, en cuyo caso se declarar\u00e1n como p\u00fablicos.</p>"},{"location":"uutt/ut06/064_CrearClases.html#definicion-de-metodos-de-clase","title":"Definici\u00f3n de m\u00e9todos de clase","text":"<p>Un m\u00e9todo es una llamada a una operaci\u00f3n de un determinado objeto. Al realizar esta llamada (tambi\u00e9n se le llama enviar un mensaje), el control del programa pasa a ese m\u00e9todo y lo mantendr\u00e1 hasta que el m\u00e9todo finalice o se haga uso de <code>return</code>.</p> <p>Para que un m\u00e9todo pueda trabajar, normalmente hay que pasarle unos datos en forma de argumentos o par\u00e1metros, cada uno de los cuales se separa por comas. Al definir el m\u00e9todo hay que indicar qu\u00e9 argumento se necesitan y de qu\u00e9 tipo son.</p> <pre><code>balon.botar(); //sin argumentos\nmiCoche.acelerar(10);\nficha.comer(posicion15);\npartida.empezarPartida(\"18:15\",colores);\n</code></pre> <p>Los m\u00e9todos de la clase se definen dentro de ella. Hay que indicar un modificador de acceso (<code>public</code>, <code>private</code>, <code>protected</code> o ninguno, al igual que ocurre con las variables y con la propia clase) y un tipo de datos, que indica qu\u00e9 tipo de valores devuelve el m\u00e9todo.</p> <p>Esto \u00faltimo se debe a que los m\u00e9todos son funciones que pueden devolver un determinado valor (un entero, una cadena de texto, un valor l\u00f3gico, ...) mediante el comando <code>return</code>. Si el m\u00e9todo no devuelve ning\u00fan valor, entonces se utiliza el tipo <code>void</code> que significa que no devuelve valores (en ese caso el m\u00e9todo no tendr\u00e1 instrucci\u00f3n <code>return</code>).</p> <pre><code>public class Coche {\n    int ruedas;\n    private double velocidad; // por defecto vale 0\n    String nombre;\n    protected String direccion;\n    /* Aumenta la velocidad*/\n    public void acelerar(double cantidad) {\n        velocidad += cantidad; // velocidad = velocidad + cantidad\n    }\n    /* Disminuye la velocidad*/\n    public void frenar(double cantidad) {\n        velocidad -= cantidad; // velocidad = velocidad - cantidad\n    }\n    /* Devuelve la velocidad*/\n    public double obtenerVelocidad(){\n        return velocidad;\n    }\n    public static void main(String[] args){\n        Coche miCoche = new Coche();\n        miCoche.acelerar(12);\n        miCoche.frenar(5);\n        System.out.println(miCoche.obtenerVelocidad()); //Da 7.0\n    }\n}\n</code></pre>"},{"location":"uutt/ut06/064_CrearClases.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 601 (RA2/ CE2c CE2g CE2h/ IC1 / 3p). Genera una clase <code>Noria</code> que tenga como atributo radio de tipo <code>double</code> y como m\u00e9todos <code>parar</code> al cual no se le pasan argumentos y <code>girar</code> al que se le pasa una variable de tipo entero. Todos los miembros de la clase pueden ser accedidos desde clases que se encuentren en su mismo paquete. Si la noria est\u00e1 parada el m\u00e9todo parar devolver\u00e1 \u201cLa noria est\u00e1 parada\u201d, de lo contrario mostrar\u00e1 \u201cIniciando frenado\u201d hacer un delay de 1000ms y mostrar \u201cParada\u201d. </p> <p>Pod\u00e9is a\u00f1adir tantos atributos a la clase como consider\u00e9is. En el <code>main</code> realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AC 602 (RA2/ CE2c CE2g CE2h/ IC1 / 3p). Genera una clase <code>Cuenta</code> que tenga como atributos nombre y n\u00famero de cuenta de tipo <code>String</code>, y tipo de inter\u00e9s y saldo de tipo <code>double</code>. Por otro lado, tiene el m\u00e9todo <code>ingreso</code> al que se le pasa un valor tipo <code>double</code> y devolver\u00e1 un mensaje en funci\u00f3n de una comprobaci\u00f3n: que se ingresen m\u00ednimo 99,99 y m\u00e1ximo 999,99. Adem\u00e1s deber\u00e1 tener otro m\u00e9todo que nos muestre el saldo de la cuenta. Ning\u00fan miembro de la clase puede ser accedido desde fuera de esta. </p> <p>Pod\u00e9is a\u00f1adir tantos atributos a la clase como consider\u00e9is. En el <code>main</code> realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AR 603 (RA2/ CE2c CE2g CE2h/ IC1 / 3p). Genera una clase <code>Coche</code> que tenga como atributos <code>ruedas</code> (con modificador packageprivate), <code>velocidad</code> (de tipo double y accesible solo desde clase <code>Coche</code>), <code>nombre</code> (con acceso desde cualquier clase), y <code>direcci\u00f3n</code> (accesible desde cualquier clase dentro de su paquete y por cualquier subclase independientemente del paquete). </p> <p>Los m\u00e9todos de esta clase son <code>acelerar</code> (el cual requerir\u00e1 de una variable tipo <code>double</code> y no devolver\u00e1 ning\u00fan valor), <code>frenar</code> (que requiere tambi\u00e9n un <code>double</code> como par\u00e1metro de entrada y tampoco devuelve nada) y <code>obtenerVelocidad</code> (sin par\u00e1metros y devolver\u00e1 una variable de tipo <code>double</code>). Los tres m\u00e9todos pueden ser accedidos desde cualquier clase. <code>obtenerVelocidad</code> ser\u00e1 la que nos muestre la velocidad. No puede haber velocidades negativas. </p> <p>Pod\u00e9is a\u00f1adir tantos atributos a la clase como consider\u00e9is. En el <code>main</code> realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AC 604 (RA2/ CE2c CE2g CE2h/ IC1 / 3p). Desarrolla un programa que sirva para tener registrada la entrada y salida de empleados en la sede de una empresa.</p> <ul> <li>Constar\u00e1 de una clase <code>EmpleadoMain</code> que contendr\u00e1 el m\u00e9todo <code>main</code> y una clase <code>Empleado</code> con los atributos nombre (de empleado), departamento y sala accesibles desde cualquier clase, y tambi\u00e9n los atributos dni, hora_ent (hora entrada) y hora_sal (hora salida) que ser\u00e1n privados.</li> <li>La clase <code>Empleado</code> tiene adem\u00e1s todos sus m\u00e9todos p\u00fablicos: el m\u00e9todo <code>identificacion</code> que devolver\u00e1 el dni, el m\u00e9todo <code>entrada</code> que devolver\u00e1 la hora de entrada y el m\u00e9todo <code>salida</code> que devolver\u00e1 la hora de salida.</li> <li>En la clase <code>EmpleadoMain</code> se debe construir o instanciar un objeto <code>emp1</code> con los siguientes atributos: <ul> <li>nombre: \u201cAntonio L\u00f3pez\u201d, departamento: \"Investigaci\u00f3n\", sala: \u2018A\u2019, dni: \u201c12345678A\u201d, hora_ent: 9 y hora_sal: 15. </li> </ul> </li> <li>Tambi\u00e9n en la clase principal se debe instanciar un nuevo objeto <code>emp2</code> con los atributos: <ul> <li>nombre: \u201cMar\u00eda Ruiz\u201d, departamento: \"Desarrollo\", sala: \u2018C\u2019, dni: \u201c23456781B\u201d, hora_ent: 15 y hora_sal: 21. </li> </ul> </li> <li>Finalmente el programa debe imprimir los atributos de los objetos por pantalla.</li> </ul> <p>Pod\u00e9is a\u00f1adir tantos atributos a la clase como consider\u00e9is. En el <code>main</code> realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AC 605 (RA2/ CE2c CE2g CE2h/ IC1 / 3p). Genera una clase <code>Gato</code> que tenga como atributos edad (de tipo entero y sin modificador), peso (de tipo double y accesible solo desde clase Gato), nombre (con acceso desde cualquier clase), y raza (de tipo <code>String</code> y accesible desde cualquier clase dentro de su paquete y por cualquier subclase independientemente del paquete). Los m\u00e9todos de esta clase son <code>correr</code> (el cual requerir\u00e1 de una variable tipo <code>double</code> y no devolver\u00e1 ning\u00fan valor) y <code>saltar</code> (sin par\u00e1metros de entrada y que devuelve un <code>double</code> con la altura alcanzada). Ning\u00fan m\u00e9todo de la clase puede ser accedido desde fuera de esta.</p> <p>Pod\u00e9is a\u00f1adir tantos atributos a la clase como consider\u00e9is. En el main realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> <li> <p>AC 606 (RA2/ CE2c CE2g CE2h/ IC1 / 3p). Escribe un programa que disponga de una clase para representar los m\u00f3dulos de un ciclo superior.</p> <ul> <li>Un m\u00f3dulo tiene un nombre, un c\u00f3digo de 4 d\u00edgitos, el n\u00famero del curso en el cual se imparte y el n\u00famero de horas. Los valores iniciales de estos atributos han de proporcionarse en un constructor parametrizado.</li> <li>Se debe construir o instanciar un objeto <code>mod1</code> con los siguientes atributos: <ul> <li>nombre: \"Bases de Datos\", c\u00f3digo: \"0484\", curso: 1 y horas: 160.</li> </ul> </li> <li>Tambi\u00e9n se debe instanciar un nuevo objeto <code>mod2</code> sin indicar atributos. Estos deben ser introducidos despu\u00e9s: <ul> <li>nombre: \"Programaci\u00f3n\", c\u00f3digo: \"0485\", curso: 1 y horas: 192. </li> </ul> </li> <li>Para ello la clase ha de tener m\u00e9todos para escribir (set) los valores de los atributos.</li> <li>Finalmente, el programa debe imprimir los atributos de los objetos por pantalla.</li> </ul> </li> <li> <p>PR 607 (RA2/ CE2c CE2g CE2h/ IC2 / 5p). Escribe un programa que sirva para tener registradas las ventas de zapatos en una zapater\u00eda. Se requiere:</p> <ul> <li>Una clase <code>ZapatoMain</code> en un fichero .java que contendr\u00e1 el m\u00e9todo <code>main</code>.</li> <li>Una clase <code>Zapato</code> en otro fichero .java distinto, con los atributos tipo, color, n\u00famero y liquidaci\u00f3n de acceso p\u00fablico, y los atributos cantidad (pares de ese tipo almacenados) y precio, ambos de acceso privado.</li> <li>La clase <code>Zapato</code> tiene adem\u00e1s todos sus m\u00e9todos p\u00fablicos: el m\u00e9todo <code>almacenado</code> que devolver\u00e1 la cantidad de pares disponibles de ese tipo y el m\u00e9todo <code>precioVenta</code> que devolver\u00e1 el precio de un par concreto.</li> <li>En la clase <code>ZapatoMain</code> se debe construir o instanciar un objeto <code>par1</code> con los siguientes atributos: <ul> <li>tipo: \"N\u00e1utico\", color: \"Azul\", n\u00famero: 42, liquidaci\u00f3n: false, cantidad: 10 y precio: 40, </li> </ul> </li> <li>Otro objeto <code>par2</code> con los atributos: <ul> <li>nombre: \"De sal\u00f3n\", color: \"Rojo\", n\u00famero: 38, liquidaci\u00f3n: true, cantidad: 3 y precio: 25.</li> </ul> </li> <li>Finalmente, el programa debe imprimir los atributos de los objetos por pantalla.</li> </ul> <p>Genera un m\u00e9todo <code>main</code> donde pruebes todos los m\u00e9todos. Recuerda que siempre que se puedan pedir datos por teclado, se han de pedir.</p> </li> <li> <p>PR 608 (RA2/ CE2c CE2g CE2h/ IC2 / 5p). Se necesita crear un programa que solicite, almacene y presente informaci\u00f3n sobre los alumnos de un Instituto. Para ello:</p> <ul> <li>Crea tanto la clase <code>AlumnoMain</code> con el m\u00e9todo <code>main</code>, como la clase <code>Alumno</code> cuyos atributos ser\u00e1n privados. Ambas clases deben estar en ficheros diferentes.</li> <li>La informaci\u00f3n que interesa almacenar de cada estudiante es el nombre del alumno, su NIA (ej: \u201c123\u201d), el nombre del ciclo y su curso.</li> <li>El programa deber\u00e1 solicitar al usuario la inserci\u00f3n de los datos de al menos 2 alumnos, y al finalizar deber\u00e1 mostrarlos por pantalla.</li> </ul> <p>Genera un m\u00e9todo <code>main</code> donde pruebes todos los m\u00e9todos. Recuerda que siempre que se puedan pedir datos por teclado, se han de pedir.</p> </li> </ul>"},{"location":"uutt/ut06/065_Scope.html","title":"Scope","text":"<p>En todos los lenguajes este es un tema muy importante. Los argumentos son los datos que recibe un m\u00e9todo y que necesita para funcionar. Existen dos tipos de argumentos o par\u00e1metros: por valor y por referencia. En el primero, los valores que recibe el m\u00e9todo son copias de los valores originales pasados al mismo, por tanto, cualquier modificaci\u00f3n que se realice sobre ellos solo ser\u00e1 visible en el \u00e1mbito del m\u00e9todo (dentro del m\u00e9todo). En el segundo, se recibe la referencia de la posici\u00f3n en memoria donde se encuentra el dato, esto hace que dentro del m\u00e9todo se trabaje con el dato verdadero, no con una copia y las modificaciones no se refieran \u00fanicamente al \u00e1mbito del m\u00e9todo, sino que afecten directamente al dato.</p> <p>En Java, todos los tipos b\u00e1sicos pasan por valor y todos los objetos pasan por referencia. Si pasamos un dato primitivo como par\u00e1metro, lo estamos pasando por valor y si este par\u00e1metro es modificado dentro del m\u00e9todo, esa modificaci\u00f3n solo se ha producido en la copia creada en el m\u00e9todo. La copia desaparece al salir del m\u00e9todo.</p> <p>A tener en cuenta</p> <p>Los tipos b\u00e1sicos (<code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code>, <code>float</code>, <code>short</code> y <code>byte</code>) se pasan por valor. La inmensa mayor\u00eda de objetos se pasan por referencia, aunque los objetos pertenecientes a clases de tipo inmutable se pasan por valor. Las clases <code>String</code>, <code>Integer</code>, <code>Double</code> son ejemplos de clases inmutables. Los arrays se pasan por referencia.</p> <p>Los m\u00e9todos pueden devolver valores de tipos primitivos (<code>int</code>, <code>short</code>, <code>double</code>, etc.), <code>String</code>, arrays e incluso objetos. En todos los casos es el comando <code>return</code> el que realiza esta labor. En el caso de arrays y objetos, devuelve una referencia a ese array u objeto. </p>"},{"location":"uutt/ut06/066_Sobrecarga.html","title":"Sobrecarga de m\u00e9todos","text":"<p>La sobrecarga de m\u00e9todos es una caracter\u00edstica que nos permite tener m\u00e1s de un m\u00e9todo con el mismo nombre, siempre que usemos diferentes par\u00e1metros. Es la capacidad de crear m\u00faltiples m\u00e9todos con el mismo nombre pero diferentes implementaciones. Se permite que una clase declare m\u00e1s de un m\u00e9todo con el mismo identificador, pero para ello debe declarar diferentes par\u00e1metros (tanto en n\u00famero como en el tipo de estos). Esta caracter\u00edstica se denomina sobrecarga de m\u00e9todos u <code>overloading</code>. Los m\u00e9todos sobrecargados son diferenciados seg\u00fan el n\u00famero y el tipo de los argumentos pasados en la invocaci\u00f3n.</p> <p><pre><code>public class Matematicas{\n    public int suma(int x, int y) {\n        return x + y;\n    }\n    public double suma(double x, double y) {\n        return x + y;\n    }\n    public double suma(double x, double y, double z){\n        return x + y + z;\n    }\n}\n</code></pre> Aunque ahora no tenga mucha utilidad, cuando se trabajen conceptos m\u00e1s complejos veremos que son de gran utilidad. No hay l\u00edmite en la cantidad de sobrecarga que se puede hacer al dise\u00f1ar constructores y m\u00e9todos, la \u00fanica restricci\u00f3n es que cada m\u00e9todo debe tener una <code>signature</code> distinta con el mismo nombre.</p> <p>A tener en cuenta</p> <p>Una buena pr\u00e1ctica es sobrecargar m\u00e9todos que hagan funciones que se llamen igual pero que el n\u00famero de par\u00e1metros sea diferente.</p>"},{"location":"uutt/ut06/066_Sobrecarga.html#actividad","title":"Actividad","text":"<ul> <li> <p>AC 609 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC1 / 3p). Crea una clase <code>MinutosSegundos.java</code>, crea un m\u00e9todo llamado <code>obtenerMensajeDuracion</code>con dos par\u00e1metros enteros: minutos y segundos. El m\u00e9todo devuelve un String. Valida que minutos sea mayor o igual a 0. Valida que segundos sea mayor o igual a 0 o menor o igual que 59.  El m\u00e9todo debe devolver \u201cValor inv\u00e1lido\u201d si alguna de las validaciones anteriores no se cumple.</p> <p>Si los par\u00e1metros son v\u00e1lidos entonces calcula cuantas horas, minutos y segundos es igual a los minutos y segundos pasados por par\u00e1metro y devuelve \u201cXXh YYm ZZs\u201d, donde XX son las horas (calculadas a partir de los minutos), YY son los minutos (restantes) y ZZ son los segundos que nos pasan.</p> <p>Crea un segundo m\u00e9todo con el mismo nombre (sobrecargado) pero solo con el par\u00e1metro de segundos. Valida que los segundos sea mayor o igual a 0. Si no devuelve \u201cValor inv\u00e1lido\u201d. Si los segundos son v\u00e1lidos, calcula a partir de los segundos calcula cu\u00e1ntos minutos hay en los segundos pasados y luego llama al m\u00e9todo con los dos par\u00e1metros (minutos y segundos) calculados.</p> <p>Crea el m\u00e9todo <code>main</code> y llama a ambos m\u00e9todo y prueba que funciona correctamente. </p> <p>Recuerda</p> <ul> <li>1 minuto son 60 segundos. </li> <li>1 hora son 60 minutos o 3600 segundos.</li> </ul> <p>Por ejemplo, para la entrada de 61 minutos la salida debe ser: 1h 1m 0s.</p> </li> </ul>"},{"location":"uutt/ut06/067_Constructores.html","title":"Los constructores","text":"<p>Un constructor es un m\u00e9todo que es llamado autom\u00e1ticamente al crear un objeto de una clase, es decir al usar la instrucci\u00f3n <code>new</code>. Son m\u00e9todos especiales que sirven para inicializar las instancias de una clase. Su funci\u00f3n es inicializar el objeto y sirve para asegurarnos que los objetos siempre contengan valores v\u00e1lidos. Sin embargo, los constructores no tienen un tipo de devoluci\u00f3n explicito. Normalmente, se usa un constructor para dar valores iniciales a las variables de instancia definidas por la clase, o para realizar cualquier otro procedimiento de inicio requerido para crear un objeto completamente formado.</p> <p>Todas las clases tienen constructores, definido expl\u00edcitamente en el c\u00f3digo o no, porque Java proporciona autom\u00e1ticamente un constructor predeterminado o por defecto. En este caso, las variables de miembro no inicializadas tienen sus valores predeterminados, que son cero, <code>null</code> y <code>false</code>, para tipos num\u00e9ricos, tipos de referencia y booleanos, respectivamente. Una vez que defines tu propio constructor, el constructor predeterminado ya no se usa.</p> <p>Los constructores tambi\u00e9n se pueden sobrecargar, como cualquier m\u00e9todo, variando la cantidad de par\u00e1metros que reciben.</p> <p>Cuando se crea un objeto de Java se realizan las siguientes operaciones de forma autom\u00e1tica:</p> <ol> <li>Se asigna memoria para el objeto.</li> <li>Se inicializan los atributos de ese objeto con los valores predeterminados por el sistema.</li> <li>Se llama al constructor de la clase que puede ser uno entre varios.</li> </ol> <p>El constructor de una clase tiene las siguientes caracter\u00edsticas:</p> <ul> <li>Tiene el mismo nombre que la clase a la que pertenece.</li> <li>En una clase puede haber varios constructores con el mismo nombre y distinto n\u00famero de argumentos (se puede sobrecargar).</li> <li>No se hereda.</li> <li>No puede devolver ning\u00fan valor (tampoco void).</li> <li>Habitualmente se declara p\u00fablico para que pueda ser invocado incluso desde fuera del paquete donde se desee crear un objeto de esa clase.</li> </ul> MiClase.javaApp.java <pre><code>public class MiClase {\n    private int x;\n    public MiClase(){ //constructor\n        x = 10; // Inicializo a 10\n    }\n}\n</code></pre> <pre><code>public class App {\n    public static void main(String[] args) {\n        MiClase obj1 = new MiClase();\n        MiClase obj2 = new MiClase();\n        System.out.println(obj1.x + \", \" + obj2.x); //Da 10, 10\n    }\n}\n</code></pre>"},{"location":"uutt/ut06/067_Constructores.html#sobrecarga-del-constructor","title":"Sobrecarga del constructor","text":"<p>En el ejemplo anterior, se utiliz\u00f3 un constructor sin par\u00e1metros. Aunque esto est\u00e1 bien para algunas situaciones, la mayor\u00eda de las veces necesitar\u00e1 un constructor que acepte uno o m\u00e1s par\u00e1metros. Los par\u00e1metros se agregan a un constructor de la misma manera que se agregan a un m\u00e9todo: simplemente declararlos dentro del par\u00e9ntesis despu\u00e9s del nombre del constructor. Por ejemplo, aqu\u00ed, <code>MiClase</code> tiene un constructor parametrizado:</p> MiClase.javaApp.java <pre><code>public class MiClase {\n    private int x;\n    public MiClase(int i){ //constructor parametrizado\n        x = i;\n    }\n}\n</code></pre> <pre><code>public class App {\n    public static void main(String[] args) {\n        MiClase obj1 = new MiClase(15);\n        MiClase obj2 = new MiClase(28); System.out.println(obj1.x + \", \" + obj2.x); //Da 15, 28\n    }\n}\n</code></pre> <p>Hay que tener en cuenta que puede haber m\u00e1s de un constructor para la misma clase. Al igual que ocurr\u00eda con los m\u00e9todos, los constructores se pueden sobrecargar. Cuando se sobrecargan los constructores (se utilizan varias posibilidades de constructor), se pueden hacer llamadas a constructores mediante la palabra clave <code>this</code> como veremos m\u00e1s adelante.</p>"},{"location":"uutt/ut06/067_Constructores.html#constructor-copia","title":"Constructor copia","text":"<p>Se puede crear un objeto a partir de otro de su misma clase escribiendo un constructor llamado constructor copia. Este constructor copia los atributos de un objeto existente al objeto que se est\u00e1 creando. Los constructores copia tienen un solo argumento, el cual es una referencia a un objeto de la misma clase que ser\u00e1 desde el que queremos copiar. Por ejemplo, para una clase Fecha podemos escribir un constructor copia que permita crear objetos con los valores de otro ya existente:</p> <pre><code>Fecha fecha = new Fecha(1,1,2011); //se invoca al constructor con par\u00e1metros\nFecha fecha1 = new Fecha(fecha); //se invoca al constructor copia\n\n//constructor copia de la clase Fecha\npublic Fecha(final Fecha f) {\ndia = f.dia;\nmes = f.mes;\nanyo = f.anyo;\n}\n</code></pre>"},{"location":"uutt/ut06/067_Constructores.html#actividad","title":"Actividad","text":"<ul> <li> <p>AC 610 (RA4/ CE4a CE4b CE4d CE4e CE4f / IC1 / 3p). En una f\u00e1brica se requiere de un sistema de clasificaci\u00f3n de piezas en funci\u00f3n del color. Para ello:</p> <ul> <li>Crea una clase llamada <code>Pieza</code> con los siguientes atributos: c\u00f3digo de tipo entero y color de tipo char.</li> <li>El programa primero deber\u00e1 preguntar por el color de 5 piezas (\u2018v\u2019 verde o \u2018a\u2019 azul), contar la cantidad de piezas de cada color y presentar los resultados por pantalla.</li> <li>Posteriormente deber\u00e1 instanciar una nueva pieza copia de la primera y presentar de nuevo el recuento por pantalla.</li> </ul> <p>En el main realizar la simulaci\u00f3n y comprobaci\u00f3n que consider\u00e9is.</p> </li> </ul>"},{"location":"uutt/ut06/068_Destructores.html","title":"Destructores","text":"<p>En C++ los objetos se crean con new y para eliminarlos de la memoria se emplea la instrucci\u00f3n <code>delete</code>. Es decir, es responsabilidad del programador eliminar la memoria que ocupaban los objetos que se van a dejar de usar. La instrucci\u00f3n <code>delete</code> de C++ llama al destructor de la clase, que es una funci\u00f3n que se encarga de eliminar adecuadamente el objeto.</p> <p>La sorpresa de los programadores de C++ que empiezan a trabajar en Java es que no hay instrucci\u00f3n <code>delete</code> en Java. La duda est\u00e1 entonces en determinar cu\u00e1ndo se libera la memoria que ocupa un objeto.</p> <p>En Java hay un recolector de basura (<code>garbage collector</code>) que se encarga de gestionar los objetos que se dejan de usar y de eliminarlos de memoria. Por lo general este proceso de recolecci\u00f3n de basura trabaja cuando detecta que un objeto hace demasiado tiempo que no se utiliza en un programa. Se trata de una destrucci\u00f3n por defecto.</p> <p>Se puede forzar la eliminaci\u00f3n de un objeto asign\u00e1ndole el valor <code>null</code>, pero eso no equivale al <code>delete</code> de C++ que eliminaba el objeto a la vez que liberaba la memoria. Con <code>null</code> la memoria no queda libre inmediatamente, sino que pasa un cierto tiempo impredecible hasta su vaciado.</p>"},{"location":"uutt/ut06/068_Destructores.html#finalizadores","title":"Finalizadores","text":"<p><code>finalize()</code> es equivalente a los destructores en C++. Es un m\u00e9todo que es llamado antes de eliminar definitivamente el objeto para hacer limpieza final.</p> <p>Este m\u00e9todo de finalizaci\u00f3n puede generar problemas de rendimiento y no garantizan que su ejecuci\u00f3n se produzca de forma inmediata. Su uso est\u00e1 totalmente desaconsejado (la versi\u00f3n 9 del JDK ha marcado el m\u00e9todo <code>finalize()</code> como <code>Deprecated</code><sup>1</sup>).</p> <ol> <li> <p>La directiva <code>deprecated</code> permite indicar que una funci\u00f3n, tipo o cualquier otro identificador puede que deje de admitirse en una versi\u00f3n futura o que no se deba seguir utilizando.\u00a0\u21a9</p> </li> </ol>"},{"location":"uutt/ut06/069_This.html","title":"Introducci\u00f3n a la referencia this","text":"<p>Cuando se llama a un m\u00e9todo, se pasa autom\u00e1ticamente un argumento impl\u00edcito que es una referencia al objeto invocado (es decir, el objeto sobre el que se llama el m\u00e9todo). Esta referencia se llama <code>this</code>. </p> Potencia.javaPotencia.java <pre><code>public class Potencia {\n    private double b;\n    private int e;\n    private double valor;\n    public Potencia(double b, int e) {\n        //constructor con par\u00e1metros\n        this.b = b;\n        this.e = e;\n        valor = 1;\n        if(e != 0) {\n            for( ; e &gt; 0; e--)\n                this.valor = this.valor * b;\n        }\n    }\n\n    public double getPotencia(){\n        return this.valor;\n    }\n}\n</code></pre> <pre><code>public class PotenciaApp {\n    public static void main(String[] args) {\n        Potencia x = new Potencia(4.0, 2);\n        Potencia y = new Potencia(2.5, 1);\n        Potencia z = new Potencia(2.7, 2);\n        System.out.println(x.b + \" elevado a la potencia de \" + x.e + \", es igual a: \" + x.getPotencia());\n        System.out.println(y.b + \" elevado a la potencia de \" + y.e + \", es igual a: \" + y.getPotencia());\n        System.out.println(z.b + \" elevado a la potencia de \" + z.e + \", es igual a: \" + z.getPotencia());\n    }\n}\n</code></pre> <p><code>this</code> se refiere al objeto sobre el que se llam\u00f3 <code>getPotencia()</code>. Por lo tanto, <code>this.valor</code> se refiere a la copia del valor de ese objeto. Por ejemplo, si <code>getPotencia()</code> se hubiera invocado en <code>x</code>, <code>this</code> en la declaraci\u00f3n anterior se habr\u00eda estado refiriendo a <code>x</code>. Escribir la declaraci\u00f3n sin usar <code>this</code> es solo una abreviatura.</p>"},{"location":"uutt/ut06/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 06","text":""},{"location":"uutt/ut06/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA2.CERA4.CE <ul> <li>Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos.</li> </ul> <ul> <li>a. Se han escrito programas que utilicen matrices (arrays).</li> <li>c. Se han instanciado objetos a partir de clases predefinidas. </li> <li>g. Se han incorporado y utilizado librer\u00edas de objetos.</li> <li>h. Se han utilizado constructores.</li> </ul> <ul> <li>Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos.</li> </ul> <ul> <li>a. Se ha reconocido la sintaxis, estructura y componentes t\u00edpicos de una clase.</li> <li>b. Se han definido clases.</li> <li>d. Se han creado constructores.</li> <li>e. Se han desarrollado programas que instancien y utilicen objetos de las clases creadas anteriormente.</li> <li>f Se han utilizado mecanismos para controlar la visibilidad de las clases y de sus miembros.</li> </ul>"},{"location":"uutt/ut06/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li>Clases</li> <li>Objetos<ul> <li> <ol> <li>Datos (propiedades o atributos)</li> </ol> </li> <li> <ol> <li>M\u00e9todos </li> </ol> </li> <li> <ol> <li>Creaci\u00f3n de objetos de una clase</li> </ol> </li> <li> <ol> <li>Especificadores de acceso </li> </ol> </li> </ul> </li> <li>Creaci\u00f3n de clases<ul> <li> <ol> <li>Definici\u00f3n de m\u00e9todos de clase</li> </ol> </li> </ul> </li> <li>\u00c1mbito de las variables locales y de los argumentos</li> <li>Sobrecarga de m\u00e9todos</li> <li>Los constructores<ul> <li> <ol> <li>Sobrecarga del constructor</li> </ol> </li> <li> <ol> <li>Constructor copia</li> </ol> </li> </ul> </li> <li>Destructores<ul> <li> <ol> <li>Finalizadores</li> </ol> </li> </ul> </li> <li>Introducci\u00f3n a la referencia <code>this</code></li> <li>Setters y getters</li> </ol>"},{"location":"uutt/ut06/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>14/11/2024</p> <p>Conceptos b\u00e1sicosClasesObjetos</p> <p></p> <p>02</p> <p>14/11/2024</p> <p>Creaci\u00f3n de clases</p> <p>AC 601AC 602</p> <p>03</p> <p>15/11/2024</p> <p></p> <p>AC 604</p> <p>04</p> <p>18/11/2024</p> <p></p> <p>AC 605</p> <p>05</p> <p>18/11/2024</p> <p></p> <p>AC 606PR 607</p> <p>06</p> <p>19/11/2024</p> <p></p> <p>Trabajo en clase</p> <p>07</p> <p>20/11/2024</p> <p></p> <p>PR 608</p> <p>08</p> <p>20/11/2024</p> <p>Scope  Sobrecarga de m\u00e9todos</p> <p>AC 609</p> <p>09</p> <p>21/11/2024</p> <p>Constructores</p> <p>AC 610</p> <p>10</p> <p>21/11/2024</p> <p>Destructores</p> <p>Trabajo en clase</p> <p>11</p> <p>22/11/2024</p> <p></p> <p>Trabajo en el reto</p> <p>12</p> <p>25/11/2024</p> <p>Referencia <code>this</code>Setters y Getters</p> <p>AC 611</p> <p>13</p> <p>25/11/2024</p> <p></p> <p>AC 612</p> <p>14</p> <p>26/11/2024</p> <p></p> <p>Trabajo en clase</p> <p>15</p> <p>27/11/2024</p> <p></p> <p>AC 613</p> <p>16</p> <p>27/11/2024</p> <p></p> <p>Trabajo en el reto</p> <p>17</p> <p>28/11/2024</p> <p></p> <p>Trabajo en el reto</p> <p>18</p> <p>28/11/2024</p> <p></p> <p>Trabajo en el reto</p> <p>19</p> <p>29/11/2024</p> <p></p> <p>AC 614</p> <p>20</p> <p>2/12/2024</p> <p></p> <p>PR 616</p> <p>21</p> <p>2/12/2024</p> <p></p> <p>Trabajo en clase</p> <p>22</p> <p>3/12/2024</p> <p></p> <p>PR 617</p> <p>23</p> <p>4/12/2024</p> <p></p> <p>Trabajo en el reto</p> <p>24</p> <p>4/12/2024</p> <p></p> <p>Trabajo en el reto</p> <p>25</p> <p>5/12/2024</p> <p></p> <p>Trabajo en clase</p> <p>26</p> <p>5/12/2024</p> <p></p> <p>Trabajo en clase</p> <p>27</p> <p>9/12/2024</p> <p></p> <p>PR 619</p> <p>28</p> <p>9/12/2024</p> <p></p> <p>Trabajo en clase</p> <p>29</p> <p>10/12/2024</p> <p></p> <p>Trabajo en el reto</p> <p>30</p> <p>11/12/2024</p> <p></p> <p>Trabajo en el reto</p> <p>31</p> <p>11/12/2024</p> <p></p> <p>Trabajo en el reto</p> <p>32</p> <p>13/12/2024</p> <p></p> <p>Presentaci\u00f3n del reto</p>"},{"location":"uutt/ut06/ResumenUT.html#referencias","title":"Referencias","text":"<ul> <li>Web: Programaci\u00f3n Orientada a Objetos con Java por UPM</li> <li>Presentaci\u00f3n: Programaci\u00f3n Orientada a Objetos por UC3M</li> <li>Web: Introducci\u00f3n a POO en Java: Objetos y clases</li> </ul>"},{"location":"uutt/ut06/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":"<ul> <li>Web: Objetos, clases y constructores en Java. Crear una clase y un objeto. Class y new en Java</li> <li>Web: Ejemplo sencillo aplicando la POO Java</li> <li>Web: Conceptos de programaci\u00f3n orientada a objetos JAVA</li> <li>Web: PARADIGMA ORIENTADO A OBJETOS. FUNDAMENTOS Y ORIGEN DE JAVA por UM</li> <li>Web:  Curso POO (Programaci\u00f3n Orientada a Objetos)</li> <li>V\u00eddeo: Curso Programaci\u00f3n Orientada a Objetos con Java</li> <li>V\u00eddeo: MEGA Curso JAVA Programaci\u00f3n Orientada a Objetos</li> </ul>"},{"location":"uutt/ut06/Reto.html","title":"Reto UT 06","text":"<p>Los negocios locales de nuestra zona est\u00e1n buscando modernizar sus sistemas de gesti\u00f3n. Como equipo de desarrolladores junior, ten\u00e9is la oportunidad de crear una soluci\u00f3n b\u00e1sica que ayude a estos negocios a gestionar mejor sus operaciones diarias utilizando la programaci\u00f3n orientada a objetos.</p>"},{"location":"uutt/ut06/Reto.html#reto","title":"Reto","text":"<p>Desarrollar, en equipos de 2 personas o individualmente, un sistema de gesti\u00f3n b\u00e1sico para un negocio local de vuestra elecci\u00f3n (restaurante, tienda, peluquer\u00eda, etc.) utilizando Java y los principios fundamentales de la Programaci\u00f3n Orientada a Objetos.</p>"},{"location":"uutt/ut06/Reto.html#condicionantes-del-desarrollo","title":"Condicionantes del desarrollo","text":"<p>Los negocios han solicitado que se empleen los siguientes conceptos de programaci\u00f3n:</p> <ul> <li>Aplicar los conceptos b\u00e1sicos de la programaci\u00f3n orientada a objetos.</li> <li>Implementar soluciones utilizando arrays.</li> <li>Desarrollar c\u00f3digo siguiendo principios de programaci\u00f3n modular.</li> <li>Practicar el trabajo en equipo y la colaboraci\u00f3n en proyectos de software.</li> <li>Documentar y presentar soluciones t\u00e9cnicas.</li> </ul>"},{"location":"uutt/ut06/Reto.html#funcionalidades-esenciales","title":"Funcionalidades esenciales","text":"<p>Todo negocio ha de tener al menos las siguiente funcionalidades:</p> <ul> <li>Gesti\u00f3n de productos o servicios.</li> <li>Sistema b\u00e1sico de interacci\u00f3n.</li> <li>Generaci\u00f3n de informes simples (totales num\u00e9ricos).</li> </ul>"},{"location":"uutt/ut06/Reto.html#elementos-evaluables","title":"Elementos evaluables","text":"<ul> <li> <p>Documentaci\u00f3n breve explicando:</p> <ul> <li>Decisiones de dise\u00f1o.</li> <li>Decisiones de programaci\u00f3n</li> <li>Manual de uso</li> </ul> </li> <li> <p>C\u00f3digo fuente en un archivo comprimido. Para acotar el proyecto, como m\u00ednimo, ha de contener:</p> <ul> <li>El modelo de clases para productos/servicios debe estar comprendido entre 3 y 5 clases.</li> <li>La gesti\u00f3n de productos/servicio se centrar\u00e1 en 2 o 3 clases del modelo del dominio.</li> </ul> </li> </ul>"},{"location":"uutt/ut06/Reto.html#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Adem\u00e1s de los los criterios de evaluaci\u00f3n que se trabajan en las UT 6, se valorar\u00e1:</p> <ul> <li>Funcionalidad: El prototipo debe ser operativo, permitiendo la interacci\u00f3n b\u00e1sica del usuario con el programa.</li> <li>Adherencia a Est\u00e1ndares: El c\u00f3digo debe seguir buenas pr\u00e1cticas de programaci\u00f3n y estar bien organizado.</li> </ul>"},{"location":"uutt/ut06/Reto.html#fecha-de-entrega","title":"Fecha de entrega","text":"<p>La entrega ser\u00e1 a trav\u00e9s de Aules antes de la sesi\u00f3n de presentaci\u00f3n del reto.</p>"},{"location":"uutt/ut07/071_CreacionPaquetes.html","title":"Creaci\u00f3n de paquetes","text":"<p>Los paquetes en Java (<code>packages</code>) son la forma en la que Java nos permite agrupar de alguna manera l\u00f3gica los componentes de nuestra aplicaci\u00f3n que est\u00e9n relacionados entre s\u00ed.</p> <p>Los paquetes permiten poner en su interior casi cualquier cosa como: clases, interfaces, archivos de texto, entre otros. De este modo, los paquetes en Java ayudan a darle una buena organizaci\u00f3n a la aplicaci\u00f3n ya que permiten modularizar o categorizar las diferentes estructuras que componen nuestro software.</p> <p>Para declarar un paquete en Java se hace uso de la palabra reservada <code>package</code> seguido de la \"ruta\" del paquete, como se muestra a continuaci\u00f3n.</p> <pre><code>package ruta.del.paquete;\n</code></pre> <p>A tener en cuenta</p> <ul> <li>La declaraci\u00f3n del paquete debe estar al principio del archivo Java, es decir, es la primera l\u00ednea que se debe ver en nuestro c\u00f3digo o archivo <code>.java</code>. Primero se declara el paquete, y luego podremos poner los imports y luego las clases, interfaces, m\u00e9todos, etc.</li> <li>Cada punto en la ruta del paquete es una nueva carpeta. Cuando se escribe la ruta del paquete en Java, se pueden especificar una ruta compleja usando el punto <code>.</code>.</li> <li>Tambi\u00e9n hay varias buenas pr\u00e1cticas y recomendaciones para crear y declarar paquetes en Java. En general, los paquetes en java se declaran siempre en min\u00fasculas y en caso de ser necesario las palabras se separan usando un guion bajo <code>_</code>.</li> <li>Si decidimos no declarar un paquete para nuestra clase, \u00e9sta quedar\u00e1 en un paquete que se conoce como paquete por defecto (<code>default package</code>), en este paquete estar\u00e1n todas las clases que no tengan un paquete declarado. Aunque esto no genera errores de compilaci\u00f3n ni nada parecido, siempre es recomendable declarar un paquete a cada componente de nuestro programa Java para poder darle diferentes niveles de seguridad o acceso a dichos componentes y mantener todo ordenado.</li> <li>Es com\u00fan usar la primera letra en may\u00fascula cuando se declara una clase, pues bien, cuando se declaran paquetes es com\u00fan que todas la letras est\u00e9n en min\u00fascula y en caso de ser varias palabras separarlas por un guion bajo <code>_</code> por ejemplo \"mi_paquete\" es adecuado mientras que \"MiPaquete\" aunque no es incorrecto, no es una buena pr\u00e1ctica.</li> </ul>"},{"location":"uutt/ut07/071_CreacionPaquetes.html#ejemplo","title":"Ejemplo","text":"<p>Nos basaremos en la siguiente estructura:</p> <pre><code>src/\n\u251c\u2500\u2500 com/\n\u2502   \u251c\u2500\u2500 gestion/\n\u2502   \u2502   \u251c\u2500\u2500 Estudiante.java\n\u2502   \u2502   \u2514\u2500\u2500 Profesor.java\n\u2502   \u251c\u2500\u2500 util/\n\u2502       \u2514\u2500\u2500 Utilidades.java\n\u2514\u2500\u2500 Main.java\n</code></pre> <p>C\u00f3digo de cada clase:</p> EstudianteProfesorUtilidades <pre><code>package com.gestion;\n\npublic class Estudiante {\n    private String nombre;\n\n    public Estudiante(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void mostrarNombre() {\n        System.out.println(\"Estudiante: \" + nombre);\n    }\n}\n</code></pre> <pre><code>package com.gestion;\n\npublic class Profesor {\n    private String nombre;\n\n    public Profesor(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void mostrarNombre() {\n        System.out.println(\"Profesor: \" + nombre);\n    }\n}\n</code></pre> <pre><code>package com.util;\n\npublic class Utilidades {\n    public static void imprimirSeparador() {\n        System.out.println(\"---------------------\");\n    }\n}\n</code></pre> <p>Y si ahora escribimos el main:</p> <pre><code>import com.gestion.Estudiante;\nimport com.gestion.Profesor;\nimport com.util.Utilidades;\n\npublic class Main {\n    public static void main(String[] args) {\n        Estudiante estudiante = new Estudiante(\"Ana\");\n        Profesor profesor = new Profesor(\"Sr. L\u00f3pez\");\n\n        estudiante.mostrarNombre();\n        Utilidades.imprimirSeparador();\n        profesor.mostrarNombre();\n    }\n}\n</code></pre>"},{"location":"uutt/ut07/072_Herencia.html","title":"Herencia","text":"<p>La herencia es una de las caracter\u00edsticas fundamentales de la Programaci\u00f3n Orientada a Objetos (POO). Mediante la herencia podemos definir una clase a partir de otra ya existente. La clase nueva se llama clase derivada o subclase y la clase existente se llama clase base o superclase. La clase derivada hereda los miembros (atributos y m\u00e9todos) de la clase base.</p> <p>La finalidad de la herencia es:</p> <ul> <li>Extender la funcionalidad de la clase base: en la clase derivada se pueden a\u00f1adir atributos y m\u00e9todos nuevos.</li> <li>Especializar el comportamiento de la clase base: en la clase derivada se pueden modificar (sobrescribir, <code>override</code>) los m\u00e9todos heredados para adaptarlos a sus necesidades.</li> </ul> <p>La herencia permite la reutilizaci\u00f3n del c\u00f3digo, ya que evita tener que reescribir de nuevo una clase existente cuando necesitamos ampliarla en cualquier sentido. Todas las clases derivadas pueden utilizar el c\u00f3digo de la clase base sin tener que volver a definirlo en cada una de ellas.</p>"},{"location":"uutt/ut07/072_Herencia.html#tipos-de-herencia-en-los-lenguajes","title":"Tipos de herencia en los lenguajes","text":"<p>Existen dos tipos de herencias: simples y m\u00faltiples.</p> <p>La herencia m\u00faltiple es b\u00e1sicamente que una clase puede heredar de dos clases base. Aunque la t\u00edpica afirmaci\u00f3n de que Java no soporta herencia m\u00faltiple no es del todo exacta (se simula mediante interfaces), no es recomendable su uso, ya que, a pesar de su potencia, nos puede llevar a complicaciones en la estructura como es la temida herencia con estructura diamante.</p> <p>Es por ello que, salvo que sea realmente estricto nos quedaremos con la herencia simple. Una clase base puede serlo de tantas derivadas como se desee: Un solo padre, varios hijos.</p>"},{"location":"uutt/ut07/072_Herencia.html#herencia-en-java","title":"Herencia en Java","text":"<p>Un objeto de una clase derivada es, a su vez, un objeto de su clase base, por lo tanto, se puede sustituir en cualquier lugar donde aparezca un objeto de la clase base. Si esto no fuese posible entonces la herencia no est\u00e1 bien planteada.</p> <p>Ejemplo de planteamiento de herencia</p> <p>A partir de la clase <code>Persona</code>, que tiene como atributos el nif y el nombre, podemos obtener una clase derivada <code>Alumno</code>. Un <code>Alumno</code> es una <code>Persona</code> que tendr\u00e1 como atributos nif, nombre y curso. Su uso es correcto ya que un <code>Alumno</code> es una <code>Persona</code>.</p> <p>A la hora de visualizar la herencia de nuestro programa se puede llegar a complicar con conceptos como generalizaciones o especializaciones. Siguiendo con el ejemplo de <code>Persona</code>, se podr\u00eda llegar a algo como a lo de la imagen:</p> <p>Las clases m\u00e1s generales se sit\u00faan en lo m\u00e1s alto de la jerarqu\u00eda. Cu\u00e1nto m\u00e1s arriba en la jerarqu\u00eda, menor nivel de detalle. Cada clase derivada debe implementar \u00fanicamente lo que la distingue de su clase base. En Java todas las clases derivan directa o indirectamente de la clase <code>Object</code>. Esta es la clase base de toda la jerarqu\u00eda de clases Java. Todos los objetos en un programa Java son <code>Object</code>.</p> <p>Las clases derivadas cumplen una serie de propiedades:</p> <ul> <li>Una clase derivada hereda de la clase base sus componentes (atributos y m\u00e9todos).</li> <li>Los constructores no se heredan. Las clases derivadas deber\u00e1n implementar sus propios constructores.</li> <li>Una clase derivada puede acceder a los miembros p\u00fablicos y protegidos de la clase base como si fuesen miembros propios.</li> <li>Una clase derivada no tiene acceso a los miembros privados de la clase base. Deber\u00e1 acceder a trav\u00e9s de m\u00e9todos heredados de la clase base.</li> <li>Si se necesita tener acceso directo a los miembros privados de la clase base se deben declarar <code>protected</code> en lugar de <code>private</code> en la clase base.</li> <li>Una clase derivada puede a\u00f1adir a los miembros heredados, sus propios atributos y m\u00e9todos (extender la funcionalidad de la clase).</li> <li>Tambi\u00e9n puede modificar los m\u00e9todos heredados (especializar el comportamiento de la clase base).</li> <li>Una clase derivada puede, a su vez, ser una clase base, dando lugar a una jerarqu\u00eda de clases.</li> </ul>"},{"location":"uutt/ut07/072_Herencia.html#extension-de-una-clase","title":"Extensi\u00f3n de una clase","text":"<p>La herencia en Java se expresa mediante la palabra extends, es decir se extiende la clase base a la clase derivada. Por ejemplo, para declarar una clase B que hereda de una clase A:</p> <pre><code>public class B extends A { \u2026 }\n</code></pre> <p>Si lo vemos con un ejemplo </p> Clase padreClase hija Persona.java<pre><code>public class Persona {\n    private String dni;\n    private String nombre;\n    public String getDni() { return dni;}\n    public void setDni(String dni) { this.dni = dni;}\n    public String getNombre() { return nombre;}\n    public void setNombre(String nombre) { this.nombre = nombre;}\n}\n</code></pre> Alumno.java<pre><code>public class Alumno extends Persona {\n    private String curso;\n    public String getCurso() { return curso; }\n    public void setCurso(String curso) { this.curso = curso; }\n}\n</code></pre> <p>La clase <code>Alumno</code> hereda los atributos nombre y dni de la clase <code>Persona</code>, y a\u00f1ade el atributo curso. Por lo tanto:</p> <ul> <li>Los atributos de la clase Alumno son dni, nombre y curso.</li> <li>Los m\u00e9todos de la clase Alumno son: <code>getDni()</code>, <code>setDni(String dni)</code>, <code>getNombre()</code>, <code>setNombre(String nombre)</code>, <code>getCurso()</code>, <code>setCurso(String curso)</code>.</li> </ul> <p>La clase <code>Alumno</code>, aunque hereda los atributos dni y nombre, no puede acceder a ellos de forma directa ya que son privados a la clase <code>Persona</code>. Se acceden a trav\u00e9s de los m\u00e9todos heredados de la clase base. La clase <code>Alumno</code> puede utilizar los miembros public y protected de la clase <code>Persona</code> como si fueran propios.</p> <p>Jerarqu\u00eda de clases</p> <p>En una jerarqu\u00eda de clases, cuando un objeto invoca a un m\u00e9todo:</p> <ol> <li>Se busca en su clase el m\u00e9todo correspondiente.</li> <li>Si no se encuentra, se busca en su clase base.</li> <li>Si no se encuentra, se sigue buscando hacia arriba en la jerarqu\u00eda de clases hasta que el m\u00e9todo se encuentra.</li> <li>Si al llegar a la clase ra\u00edz el m\u00e9todo no se ha encontrado se producir\u00e1 un error.</li> </ol>"},{"location":"uutt/ut07/072_Herencia.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 701 (RA4/ CE4g CE4h CE4i / IC1 / 3p). Realiza la implementaci\u00f3n de la siguiente imagen:</p> <p> </p> <ul> <li><code>Persona</code> tiene como atributos: <code>dni</code>, <code>sexo</code> y <code>anyoNacimiento</code>. Adem\u00e1s de los m\u00e9todos que accedan y modifiquen las propiedades, se ha de programar un m\u00e9todo que calcule la edad (solo el a\u00f1o).</li> <li><code>Alumno</code> tiene como atributo <code>etapaEducativa</code> y <code>provinciaVive</code>.</li> <li><code>Ingeniero</code> tiene como atributo <code>colegioAdscrito</code>. Y un m\u00e9todo que es <code>calculoCuota</code> que si es industrial es gratuito, si es otro son 50\u20ac.</li> <li><code>Tecnico</code> tiene como atributo <code>gradoProfesional</code> y <code>anyoComienzo</code>. Adem\u00e1s tiene un m\u00e9todo que es <code>anyoExperiencia</code> que nos calcula cuantos a\u00f1os lleva trabajados desde su comienzo.</li> <li><code>Administrativo</code> tiene el atributo <code>administraci\u00f3n</code>.</li> <li><code>Profesor</code> tiene el atributo <code>especialidad</code> y <code>anyoInicioTrabajo</code>. Tiene un m\u00e9todo que es <code>anyosComoDocente</code> que calcula los a\u00f1os que lleva en el cuerpo.</li> <li><code>Interino</code> tiene como atributo bolsa, que indica el n\u00famero de bolsas en las que est\u00e1. En el constructor por defecto deber\u00e1 marcar 1, pero en el sobrecargado s\u00f3lo si se introduce 0.</li> <li><code>Plantilla</code> tiene <code>anyoOposicion</code> y el m\u00e9todo <code>anyosFuncionarioCarrera</code>.</li> <li><code>Catedr\u00e1tico</code> un boolean que sea <code>esCatedratico</code>.</li> </ul> <p>Adem\u00e1s hay que generar un main en el que se comprueben todos los objetos y m\u00e9todos que se programen.</p> </li> <li> <p>AC 702 (RA4/ CE4g CE4h CE4i / IC1 / 3p). Implementa una clase base llamada <code>Vehiculo</code>, luego desarrolla una clase <code>Coche</code> que herede de la clase base. Por \u00faltimo, crea una nueva clase que t\u00fa quieras y sea espec\u00edfica de <code>Coche</code>, es decir, que herede de la clase <code>Coche</code>. Habr\u00e1 que almacenar informaci\u00f3n sobre su estado y comportamiento (atributos y m\u00e9todos) como, por ejemplo, nombre, velocidad, marcha, mover, ruedas, etc. </p> <p>Incluye los m\u00e9todos cambiar de marchas, acelerar/desacelerar velocidad. Tendr\u00e1s que decidir en qu\u00e9 clase se almacena qu\u00e9 informaci\u00f3n. Para el tipo m\u00e1s concreto de coche que has definido tendr\u00e1s que a\u00f1adir algo espec\u00edfico para ese tipo de coche. No olvides los constructores con todos los par\u00e1metros.</p> <p>Crea un m\u00e9todo main de prueba</p> </li> <li> <p>AC 703 (RA4/ CE4g CE4h CE4i / IC1 / 3p). Escribe una clase con el nombre <code>Circulo</code>. La clase necesita un campo (variable de instancia) con radio de nombre de tipo doble. La clase debe tener un constructor con un par\u00e1metro de radio de tipo doble y debe inicializar los campos. En caso de que el par\u00e1metro de radio sea menor que 0, debe establecer el valor del campo de radio en 0.</p> <p>Escribe los siguientes m\u00e9todos (m\u00e9todos de instancia):</p> <ul> <li><code>getRadio</code> sin ning\u00fan par\u00e1metro, debe devolver el valor del campo de radio.</li> <li><code>getArea</code> sin ning\u00fan par\u00e1metro, debe devolver el \u00e1rea calculada (radio * radio * PI). Para PI use la constante Math.PI.</li> </ul> <p>Escriba una clase con el nombre <code>Cilindro</code> que extienda la clase <code>Circulo</code>. La clase necesita un campo (variable de instancia) de nombre altura de tipo doble. La clase necesita tener un constructor con dos par\u00e1metros radio y altura, ambos de tipo doble. En caso de que el par\u00e1metro de altura sea inferior a 0, debe establecer el valor del campo de altura en 0. Crea los siguientes m\u00e9todos (m\u00e9todos de instancia):</p> <ul> <li><code>getAltura</code> sin ning\u00fan par\u00e1metro, debe devolver el valor del campo de altura.</li> <li><code>getVolume</code> sin ning\u00fan par\u00e1metro, debe devolver el volumen calculado. Para calcular el volumen multiplica el \u00e1rea por la altura.</li> </ul> <p>Crea un m\u00e9todo main con c\u00f3digo de prueba</p> </li> <li> <p>AC 704 (RA4/ CE4g CE4h CE4i / IC1 / 3p).Escribe una clase <code>Herencia1</code> que contendr\u00e1 el <code>main()</code> y una clase <code>Multimedia</code> para almacenar informaci\u00f3n de objetos de tipo multimedia (pel\u00edculas, discos, \u2026). La clase <code>Multimedia</code>: </p> <ul> <li>Contendr\u00e1 t\u00edtulo, autor, formato y duraci\u00f3n como atributos privados.</li> <li>El formato puede ser uno de los siguientes: wav, mp3, midi, avi, mov, mpg, cdaudio y dvd.</li> <li>El valor de todos esos atributos se pasa como par\u00e1metros al constructor al crear el objeto.</li> <li>Esta clase tiene, adem\u00e1s, un m\u00e9todo para devolver cada uno de los atributos y un m\u00e9todo <code>toString</code> que devuelve la informaci\u00f3n del objeto.</li> </ul> <p>En la clase <code>Herencia1</code> se generar\u00e1n los siguientes objetos:</p> <ul> <li>obj1 Blade Runner Ridley Scott DVD 117</li> <li>obj2 Le\u00f3n, el profesional Luc Besson AVI 110</li> </ul> <p>La informaci\u00f3n de estos objetos se mostrar\u00e1 por pantalla mediante el m\u00e9todo <code>toString</code></p> </li> <li> <p>AC 705 (RA4/ CE4g CE4h CE4i / IC1 / 3p). Escribe una clase <code>Pel\u00edcula</code> que herede de la clase <code>Multimedia</code> anterior (AC 704):</p> <ul> <li>Esta clase tiene, adem\u00e1s de los atributos heredados, los atributos privados actor principal y actriz principal.</li> <li>Se permite que uno de los dos sea nulo (no exista o se desconozca), pero no los dos.</li> <li>La clase debe tener dos m\u00e9todos para obtener los nuevos atributos y debe sobrescribir el m\u00e9todo toString para que devuelva, adem\u00e1s de la informaci\u00f3n que hereda, la nueva informaci\u00f3n.</li> <li>Modifica la clase principal <code>Herencia1</code> para que los objetos instanciados tengan la siguiente informaci\u00f3n:<ul> <li>Objeto T\u00edtulo Autor Formato Duraci\u00f3n Actor princ. Actriz princ.</li> <li>obj1 Blade Runner Ridley Scott DVD 117 Harrison Ford</li> <li>obj2 Le\u00f3n, el profesional Luc Besson AVI 110 Jean Reno Natalie Portman</li> </ul> </li> <li>La informaci\u00f3n de estos objetos se mostrar\u00e1 por pantalla mediante el m\u00e9todo <code>toString()</code>.</li> </ul> </li> <li> <p>AR 706 (RA4/ CE4g CE4h CE4i / IC1 / 3p). Escribe una clase <code>Disco</code> que herede de la clase <code>Multimedia</code>:</p> <ul> <li>Esta clase tiene, adem\u00e1s de los atributos heredados, un atributo privado para almacenar el g\u00e9nero al que pertenece (rock, pop, funk, etc).</li> <li>La clase debe tener un m\u00e9todo para obtener el nuevo atributo y debe sobrescribir el m\u00e9todo <code>toString</code> para que devuelva, adem\u00e1s de la informaci\u00f3n que hereda, la nueva informaci\u00f3n.</li> <li>Modifica la clase principal <code>Herencia1</code> para que los objetos instanciados tengan la siguiente informaci\u00f3n:<ul> <li>Objeto T\u00edtulo Autor Formato Duraci\u00f3n G\u00e9nero</li> <li>obj1 Live at Wembley Queen MP3 40 Rock</li> <li>obj2 Aidalai Mecano CDAUDIO 50 Pop</li> </ul> </li> <li>La informaci\u00f3n de estos objetos se mostrar\u00e1 por pantalla mediante el m\u00e9todo <code>toString()</code>.</li> </ul> </li> <li> <p>PR 707 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7j / IC2 / 5p). Dise\u00f1a y programa las clases necesarias para implementar los pedidos de un restaurante de comida r\u00e1pida. El restaurante tiene una carta dividida en distintas categor\u00edas: entradas, bocadillos, hamburguesas y postres.</p> <p>Todos los productos pertenecen a una sola categor\u00eda y tienen un nombre, descripci\u00f3n y precio. Cuando un cliente quiere hacer un pedido, navega por la carta y selecciona los productos que desea. Al elegir un producto, podr\u00e1 elegir la cantidad y opcionalmente hacer un comentario sobre el producto. Se pueden hacer dos tipos de pedidos, para recoger y para llevar. </p> <p>Si el pedido es para recoger, solo se requiere el nombre del cliente. Si es para llevar, adem\u00e1s se requiere la direcci\u00f3n y el tel\u00e9fono. Cuando se finaliza el pedido, el restaurante lo almacena para procesarlo, e informa al cliente del coste total de su pedido, a\u00f1adiendo 2\u20ac de coste si el pedido es para llevar, y le informar\u00e1 aproximadamente del tiempo que tardar\u00e1, siendo 10 minutos por producto distinto que incluya el pedido m\u00e1s 15 minutos de llevarlo en caso de servicio a domicilio.</p> </li> <li> <p>PR 708 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7j / IC2 / 5p). Dise\u00f1a y programa las clases necesarias para implementar el sistema de reservas de un restaurante.</p> <p>El restaurante est\u00e1 formado por gran sal\u00f3n con una capacidad m\u00e1xima de 50 personas que no se puede superar en ning\u00fan caso. </p> <p>El sal\u00f3n lo podemos configurar con distintos tipos de mesas, cuadradas para 4 comensales, mesas redondas peque\u00f1as para 8 y mesas redondas grandes para 12 comensales. Tenemos un n.\u00ba limitado de cada tipo de mesa, a definir por el programador.</p> <p>Cuando se hace una reserva, hay que asignarle el n\u00famero adecuado de mesas, teniendo en cuenta que las mesas redondas no se pueden juntar, y que cuando juntamos las cuadradas perdemos capacidad, las de las esquinas solo admitir\u00e1n 3 comensales y las del centro 2. Adem\u00e1s del sal\u00f3n, el restaurante dispone de 2 reservados con un capacidad m\u00e1xima de 8 y de 15 comensales.</p> <p>Los reservados solo admiten una \u00fanica reserva, mientras que en el sal\u00f3n puede haber un n\u00famero indefinido siempre que no se supere su capacidad m\u00e1xima.</p> <p>Cuando se realiza una reserva, el cliente indicar\u00e1 su nombre, tel\u00e9fono, n\u00famero de comensales y si desea reservado. El restaurante, procesar\u00e1 la reserva y la almacenar\u00e1 si es posible indicando el n.\u00ba y tipo de mesas que requiere e informar\u00e1 al cliente de que su reserva ha sido guardada. En caso de que la reserva no sea posible, tambi\u00e9n informar\u00e1 al cliente.</p> </li> </ul>"},{"location":"uutt/ut07/073_AccesoSuperclase.html","title":"Acceso a la superclase","text":"<p>Las dudas con los constructores aparecen ligadas a las jerarqu\u00edas de clases y a la palabra <code>super()</code>. Supongamos que tenemos la jerarqu\u00eda de la derecha. </p> <p>Como podemos ver todos los constructores llaman por defecto al constructor de la clase superior a trav\u00e9s de una llamada a <code>super()</code> (en este caso al constructor por defecto). Esto es debido a que los constructores no se heredan entre jerarqu\u00edas de clases. Por lo tanto la palabra <code>super()</code> siempre es la primera l\u00ednea de un constructor e invoca al constructor de la clase superior que comparta el mismo tipo de parametrizaci\u00f3n.</p> <p>Aunque nosotros no pongamos la palabra <code>super()</code> esta siempre ser\u00e1 a\u00f1adida salvo que nosotros la a\u00f1adamos. Por ejemplo si nuestros constructores tienen par\u00e1metros las clausulas <code>super</code> que deberemos construir ser\u00e1n las siguientes entre <code>Persona</code> y <code>Deportista</code> para que el c\u00f3digo compile:</p> PersonaDeportista <pre><code>public class Persona {\n    private String nombre;\n\n    public Persona(String nombre) {\n        super();\n        this.nombre = nombre;\n    }\n    public String getNombre() {\n        return nombre;\n    }\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n}\n</code></pre> <pre><code>public class Deportista extends Persona{\n    public Deportista(String nombre) {\n        super(nombre);\n    }\n}\n</code></pre> <p>Ya que sino el compilador a\u00f1adir\u00e1 <code>super()</code> por defecto y el c\u00f3digo no compilar\u00e1 al carecer la clase <code>Persona</code> de un constructor por defecto( ya que tiene el constructror parametrizado).</p>"},{"location":"uutt/ut07/074_Polimorfismo.html","title":"Polimorfismo","text":"<p>El polimorfismo es una de las caracter\u00edsticas fundamentales de la Programaci\u00f3n Orientada a Objetos y est\u00e1 estrechamente relacionado con la herencia. Una jerarqu\u00eda de clases, los m\u00e9todos y clases abstractas, la sobreescritura de m\u00e9todos y las conversiones entre clases de la jerarqu\u00eda sientan las bases para el polimorfismo. Este se puede definir como la cualidad que tienen los objetos para responder de distinto modo a un mismo mensaje.</p> <p>Para conseguir un comportamiento polim\u00f3rfico en un programa Java se debe cumplir lo siguiente:</p> <ul> <li>Los m\u00e9todos deben estar declarados (m\u00e9todos abstractos) y a veces tambi\u00e9n pueden estar implementados (m\u00e9todos no abstractos) en la clase base.</li> <li>Los m\u00e9todos deben estar redefinidos en las clases derivadas.</li> <li>Los objetos deben ser manipulados utilizando referencias a la clase base.</li> </ul>"},{"location":"uutt/ut07/074_Polimorfismo.html#sobrescritura-de-metodos","title":"Sobrescritura de m\u00e9todos","text":"<p>Los m\u00e9todos heredados de la clase base pueden ser objeto de sobreescritura u override en las clases derivadas. El m\u00e9todo en la clase derivada se debe escribir con el mismo nombre, el mismo n\u00famero y tipo de par\u00e1metros y el mismo tipo de retorno que en la clase base. Si no fuese as\u00ed estar\u00edamos sobrecargando el m\u00e9todo, no redefini\u00e9ndolo.</p> SobrecargaSobreescritura <pre><code>    public void cambiarDatos (String m, String c){\n        marca = m;\n        color = c;\n    }\n    public void cambiarDatos (String m){\n        marca = m;\n    }\n</code></pre> <pre><code>    // m\u00e9todo en clase base\n    public void cambiarDatos (String m, String c){\n        marca = m;\n        color = c;\n    }\n\n    // m\u00e9todo en clase derivada\n    public void cambiarDatos (String m, String c){\n        marca = m;\n        if(m.equals(\"Peugeot\")){\n            color = \"Blanco\";\n        }else{\n            color = c;\n        }\n    }\n</code></pre> <p>Sobreescribiendo m\u00e9todos heredados</p> <p>El m\u00e9todo sobrescrito puede tener un modificador de acceso menos restrictivo que el de la clase base. Si por ejemplo el m\u00e9todo heredado es protected, se puede redefinir como public pero no como private porque ser\u00eda una acceso m\u00e1s restrictivo que el que tiene en la clase base. Cuando en una clase derivada se redefine un m\u00e9todo de una clase base, se oculta el m\u00e9todo de la clase base y todas las sobrecargas del mismo en la clase base. Para esto se hace uso de la palabra reservada <code>override</code>.</p> <pre><code>class Pelicula{\n    private String titulo;\n\n    public Pelicula (String titulo){\n        this. titulo = titulo;\n    }\n\n    public String trama (){\n        return \"No tiene trama\";\n    }\n}\n\nclass Spiderman extends Pelicula{\n    public Spiderman(){\n        super(\"Spiderman\");\n    }\n\n    @Override\n    public String trama(){\n        return \"Un hombre adquiere poderes tras ser mordido por una ara\u00f1a.\"\n    }\n}\n</code></pre> <p>Gracias al polimorfismo tenemos la capacidad de llamar al m\u00e9todo <code>trama</code> con el mismo tipo de objeto, en este caso de tipo <code>Pelicula</code> y obtener diferentes resultados, ya que Java autom\u00e1ticamente ve qu\u00e9 tipo de hijo es e imprime el correspondiente m\u00e9todo <code>trama</code>. Para el caso de que no se haya sobreescrito el m\u00e9todo llamar\u00e1 al de la clase padre.</p> <p>No podemos asignar un objeto de referencia de padre a una variable de clase hijo. Si queremos convertir un padre en hijo, la variable tiene que ser creada de tipo hijo. Si queremos convertir un hijo en padre tendremos que hacer un <code>Upcasting</code>, y al rev\u00e9s tendr\u00edamos un <code>Downcasting</code>.</p> No se puede hacerDowncastingUpcasting <pre><code>Perro pe = new Animal(); // No compila\nPerro p = (Perro) new Animal() // Compila pero da error de ejecuci\u00f3n\n</code></pre> <pre><code>Animal a = new Perro();\nPerro pe = (Perro) a;\n</code></pre> <pre><code>Animal a = (Animal) new Perro();\n</code></pre>"},{"location":"uutt/ut07/074_Polimorfismo.html#metodos-y-clases-abstractos-y-finales","title":"M\u00e9todos y clases abstractos y finales","text":"<p>La abstracci\u00f3n es un proceso de ocultar los detalles de implementaci\u00f3n y mostrar solo la funcionalidad al usuario. Una clase abstracta es una clase que no se puede instanciar pero que puede ser el padre de otras clases. Aunque no se puede instanciar, una clase abstracta define m\u00e9todos y variables que heredan las clases hijas.</p> <p>Clases abstractas</p> <p>Una clase abstracta es una clase que no se puede instanciar, es decir, no se pueden crear objetos de esa clase. Se dise\u00f1an solo para que otras clases hereden de ellas. La clase abstracta normalmente es la ra\u00edz de una jerarqu\u00eda de clases y contendr\u00e1 el comportamiento general que deben tener todas las subclases. Las clases abstractas pueden:</p> <ul> <li>Pueden contener cero o m\u00e1s m\u00e9todos abstractos.</li> <li>Pueden contener m\u00e9todos no abstractos.</li> <li>Pueden contener atributos.</li> </ul> <p>Todas las clases que hereden de una clase abstracta deben implementar todos los m\u00e9todos abstractos heredados. Si una clase derivada de una clase abstracta no implementa alg\u00fan m\u00e9todo abstracto se convierte en abstracta y tendr\u00e1 que declararse como tal (tanto la clase como los m\u00e9todos que siguen siendo abstractos).</p> <p>Las clases abstractas pueden opcionalmente contener m\u00e9todos abstractos. Tambi\u00e9n pueden contener m\u00e9todos no abstractos, que ser\u00e1n heredados por los hijos. Un m\u00e9todo abstracto no tiene cuerpo (No tiene c\u00f3digo). Solo se escribe la signatura del m\u00e9todo con la palabra reservada <code>abstract</code>.</p> Clase abstractaClase hija <pre><code>public abstract class Animal {\n\n    protected String nombre;\n\n    public Animal(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public abstract void alimentar();\n    public abstract void mover();\n\n    public String getNombre() {\n        return nombre;\n    }\n}\n</code></pre> <pre><code>public class Dog extends Animal {\n\n    public Dog(String nombre) {\n        super(nombre);\n    }\n\n    @Override\n    public void alimentar() {\n        System.out.println(\"El perro \" + getNombre() + \" est\u00e1 comiendo.\");\n    }\n\n    @Override\n    public void mover() {\n        System.out.println(\"Se est\u00e1 moviendo\");\n    }\n}\n</code></pre> <p>Un hijo abstracto de un padre abstracto no tiene que definir m\u00e9todos no abstractos para los m\u00e9todos abstractas que hereda. Esto significa que puede haber varios pasos entre una clase base abstracta y una clase secundaria que no es completamente abstracta. Es decir, el hijo solamente est\u00e1 obligado a implementar los m\u00e9todos abstractos que tenga el padre.</p> <p>No todo lo definido en una clase abstracta debe ser abstracto. Sin embargo, si una clase contiene incluso un m\u00e9todo abstracto, entonces la clase en s\u00ed debe declararse abstracta.</p> <p>\u00bfPara qu\u00e9 se usan las clases abstractas?</p> <p>Las clases abstractas se utilizan para organizar programas. Agrupar las clases es importante para mantener un programa organizado y comprensible. La ventaja de usar una clase abstracta es que puede agrupar varias clases relacionadas como hermanas.</p> <p>Aunque no se puedan instanciar las clases abstractas tambi\u00e9n poseen constructores. La mayor\u00eda de las veces se utilizan cuando quieres realizar alguna inicializaci\u00f3n de los campos de la clase abstracta antes de la instanciaci\u00f3n de una clase hija.</p>"},{"location":"uutt/ut07/074_Polimorfismo.html#actividad","title":"Actividad","text":"<ul> <li> <p>AC 709 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7j / IC1 / 3p). Escribe un programa con las siguientes clases:</p> <ul> <li>Una clase principal <code>Herencia2</code> que contendr\u00e1 el m\u00e9todo <code>main</code>.</li> <li>Un clase abstracta <code>Vehiculo</code> con los atributos no p\u00fablicos pero heredables de tipo entero <code>num_bastidor</code> y <code>velocidad</code>, y los m\u00e9todos abstractos p\u00fablicos <code>acelerar</code> y <code>frenar</code>.</li> <li>Las clases <code>Bicicleta</code> y <code>Patinete</code>. Estas clases heredar\u00e1n de <code>Vehiculo</code> <code>num_bastidor</code> y <code>velocidad</code> e implementar\u00e1n los m\u00e9todos <code>acelerar</code> y <code>frenar</code>.</li> <li>El programa deber\u00e1 presentar un men\u00fa con las siguientes acciones:<ol> <li>Crear un veh\u00edculo Bicicleta (b) o Patinete el\u00e9ctrico (p)</li> <li>Acelerar el veh\u00edculo incrementando la velocidad en cierta cantidad.</li> <li>Frenar el veh\u00edculo decrementando la velocidad en cierta cantidad.</li> <li>Salir del programa.</li> </ol> </li> <li>En a se debe solicitar el n\u00famero de bastidor y preguntar al usuario si se genera una bicicleta (b) o un patinete (p). Entonces mostrar\u00e1 el n\u00famero de bastidor y la velocidad.</li> <li>En b se debe preguntar al usuario por una cantidad. En caso de que se haya creado un patinete deber\u00e1 incrementarse la velocidad en el doble a lo indicado, y mostrar la nueva velocidad por pantalla.</li> <li>En c se debe solicitar por teclado una cantidad. Si se ha creado un patinete deber\u00e1 decrementar la velocidad a la mitad de lo indicado, y mostrar la nueva velocidad por pantalla.</li> </ul> </li> </ul>"},{"location":"uutt/ut07/075_Visibilidad.html","title":"Visibilidad","text":"<p>A lo largo del curso se ha ido hablando del concepto de scope o visibilidad, que si lo aplicamos a herencia nos quedar\u00eda tal y como se presenta en la siguiente figura:</p>"},{"location":"uutt/ut07/075_Visibilidad.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 710 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7j / IC1 / 3p). Usando composici\u00f3n has de crear un total de 5 clases de la siguiente forma:</p> <ul> <li> <p>a. Crea una clase llamada <code>Lampara</code> con tres variables de instancia: <code>estilo</code> de tipo <code>String</code>, <code>bater\u00eda</code> de tipo <code>booleano</code> y <code>calificaci\u00f3n</code> de tipo entero. Todas las variables deben ser privadas. La clase se debe construir con los tres par\u00e1metros. A\u00f1ade 4 m\u00e9todos:</p> </li> <li> <p><code>encender</code> sin tipo de retorno y debe imprimir el mensaje de que la l\u00e1mpara se ha encendido, </p> </li> <li><code>getEstilo</code> devuelve el estilo de la l\u00e1mpara, </li> <li><code>hayBateria</code> devuelve el booleano de bater\u00eda y </li> <li> <p><code>getCalificacion</code> que devuelve la calificaci\u00f3n de la l\u00e1mpara.</p> </li> <li> <p>b. Crea una clase llamada <code>Cama</code> con 5 atributos privados: <code>estilo</code> <code>String</code>, <code>almohadas</code>, <code>altura</code>, <code>sabanas</code> y <code>colcha</code> de tipo entero. El constructor debe ser implementado con esos 5 atributos. Agrega los m\u00e9todos: </p> </li> <li> <p><code>hacer</code> no devuelve nada e imprime que se ha hecho la cama, </p> </li> <li> <p>los <code>getters</code> de estilo, almohadas, altura, s\u00e1banas y colcha.</p> </li> <li> <p>c. A\u00f1ade una clase llamada <code>Techo</code> con dos variables: <code>altura</code> y <code>color</code> de tipo entero. Constructor con todos los par\u00e1metros. Y los dos m\u00e9todos <code>getter</code>.</p> </li> <li>d. Crea una clase llamada <code>Pared</code> con una variable <code>direcci\u00f3n</code> de tipo <code>String</code>, su constructor con una variable y el m\u00e9todo <code>getter</code>.</li> <li> <p>e. La \u00faltima clase ser\u00e1 <code>Habitaci\u00f3n</code> y contendr\u00e1 8 variables de instancia: <code>nombre</code> de tipo <code>String</code>, <code>pared1</code>, <code>pared2</code>, <code>pared3</code> y <code>pared4</code> de tipo Pared, <code>techo</code> de tipo <code>Techo</code>, <code>cama</code> de tipo <code>Cama</code> y <code>lampara</code> de tipo <code>Lampara</code>. El constructor debe contener las 8 variables. La clase debe tener dos m\u00e9todos: </p> </li> <li> <p><code>getLampara</code> que devuelve el objeto lampara </p> </li> <li> <p><code>hacerLaCama</code> que imprime el mensaje se est\u00e1 haciendo la cama y llama al m\u00e9todo <code>hacer</code> en la clase <code>Cama</code>.</p> </li> <li> <p>f. Crea una clase <code>Main</code> con un m\u00e9todo <code>main</code> que pruebe el c\u00f3digo.</p> </li> <li>g. A\u00f1ade c\u00f3digo y m\u00e9todos para probar el m\u00e9todo encender de la clase <code>lampara</code>.</li> </ul> </li> <li> <p>AC 711 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7j / IC1 / 3p). Teniendo en cuenta el principio de encapsulaci\u00f3n usado en POO crea una clase llamada <code>Impresora</code>, que simular\u00e1 una impresora real. Debe tener los campos de nivel de t\u00f3ner, n\u00famero de p\u00e1ginas impresas y si es una impresora con impresi\u00f3n a doble cara. A\u00f1ade:</p> <ul> <li>a. Un m\u00e9todo para a\u00f1adir una cantidad de t\u00f3ner al nivel actual, este m\u00e9todo actualizar\u00e1 el nivel de t\u00f3ner (hasta un m\u00e1ximo 100%), la cantidad de t\u00f3ner que se va a a\u00f1adir debe estar entre 0-100. Comprobar tambi\u00e9n que al a\u00f1adir la cantidad de t\u00f3ner no se supere el nivel de t\u00f3ner. Si cualquier condici\u00f3n falla debe devolver -1 en caso contrario se devuelve el nuevo nivel de t\u00f3ner.</li> <li>b. Otro m\u00e9todo que simule la impresi\u00f3n de p\u00e1ginas (el cu\u00e1l debe actualizar el n\u00famero de p\u00e1ginas impresas). Se le pasar\u00e1n las p\u00e1ginas a imprimir. Tambi\u00e9n se tendr\u00e1 en cuenta si la impresora es a doble cara, ya que entonces se habr\u00e1 de calcular cu\u00e1ntas p\u00e1ginas se imprimen. El m\u00e9todo debe devolver las p\u00e1ginas a imprimir y actualizar\u00e1 el valor del n\u00famero de p\u00e1ginas impresas.</li> <li>c. M\u00e9todo getter que devuelve el n\u00famero de p\u00e1ginas impresas.</li> <li>d. Decide que visibilidad van a tener los campos, si es necesario un constructor o no y cualquier cosa que creas necesaria.</li> <li>e. Crea una clase <code>MainEncapsulacion</code> con un <code>main</code> con c\u00f3digo de prueba.</li> </ul> </li> </ul>"},{"location":"uutt/ut07/076_Interfaces.html","title":"Interfaces","text":"<p>Una interfaz es un archivo <code>.java</code> formado por un conjunto de m\u00e9todos abstractos. Adem\u00e1s, puede contener un conjunto de constantes p\u00fablicas. Podemos considerar una interfaz como una clase abstracta pura: todos sus m\u00e9todos son abstractos y, si tiene atributos, son todos constantes. En Java una interfaz se crea de forma similar a como se crea una clase utilizando la palabra clave interface en lugar de <code>class</code>.</p> <pre><code>[public] interface NombreInterface{\n    declaraciones de m\u00e9todos abstractos;\n    [atributos constantes;]\n}\n</code></pre> <p>Lo que aparece entre corchetes es opcional. La interfaz puede definirse <code>public</code> o sin modificador de acceso, y tiene el mismo significado que para las clases. Si tiene el modificador <code>public</code> el archivo .java que la contiene debe tener el mismo nombre que la interfaz. Igual que las clases, al compilar el archivo .java de la interfaz se genera un archivo .class. Todos los m\u00e9todos de una interface son p\u00fablicos y abstractos, aunque no se indique expl\u00edcitamente. Por lo tanto, no es necesario escribir en cada momento <code>public abstract</code>. Una interfaz puede contener atributos constantes. Las constantes declaradas son p\u00fablicas y est\u00e1ticas, aunque no se indique expl\u00edcitamente. Por lo tanto, se pueden omitir los modificadores public static final cuando se declara el atributo. Las constantes se deben inicializar en la misma instrucci\u00f3n de declaraci\u00f3n.</p> <p>clase abstracta vs interfaz</p> <ul> <li>En la interfaz todo m\u00e9todo es abstracto y p\u00fablico sin necesidad de declararlo, mientras que una clase abstracta puede tener m\u00e9todos abstractos y no abstractos.</li> <li>Los atributos declarados en una interfaz son <code>public static final</code>. Por el contrario, una clase abstracta puede contener tambi\u00e9n atributos de otro tipo (de instancia, no constantes, private, etc).</li> <li>Las interfaces juegan un papel fundamental en la creaci\u00f3n de aplicaciones Java ya que permiten interactuar a objetos no relacionados entre s\u00ed. Utilizando interfaces es posible que clases no relacionadas, situadas en distintas jerarqu\u00edas de clases sin relaciones de herencia, tengan comportamientos comunes.</li> </ul> <p>Las interfaces definen un protocolo de comportamiento y proporcionan un formato com\u00fan para implementarlo en las clases. Los nombres de las interfaces suelen acabar en able aunque no es necesario: configurable, arrancable, dibujable, etc.</p> EjemploInterface.javaJugador.java <pre><code>import java.util.Arrays;\npublic class EjemploInterface {\n    public static void main(String[] args) {\n        Jugador [] jugadores= new Jugador[7]; //array de objetos Jugador\n        jugadores[0] = new Jugador(\"Gasol\", \"pivot\", 37);\n        jugadores[1] = new Jugador(\"Rubio\", \"base\", 32);\n        jugadores[2] = new Jugador(\"Rodriguez\", \"base\", 36);\n        jugadores[3] = new Jugador(\"Hernangomez\", \"pivot\", 28);\n        jugadores[4] = new Jugador(\"Abrines\", \"escolta/alero\", 29);\n        jugadores[5] = new Jugador(\"Aguilar\", \"ala-pivot\", 32);\n        jugadores[6] = new Jugador(\"Oriola\", \"ala-pivot\", 29);\n        Arrays.sort(jugadores);\n        for(Jugador j: jugadores){\n            System.out.println(j);\n        }\n    }\n}\n</code></pre> <pre><code>class Jugador implements Comparable{\n    private String apellido;\n    private String puesto;\n    private int edad;\n    public Jugador(String apellido, String puesto, int edad){\n        this.apellido = apellido;\n        this.puesto = puesto;\n        this.edad = edad;\n    }\n    public String getApellido() { return apellido; }\n    public String getPuesto() { return puesto; }\n    public int getEdad() { return edad; }\n    public void setApellido(String apellido) { this.apellido = apellido; }\n    public void setPuesto(String puesto) { this.puesto = puesto; }\n    public void setEdad(int edad) { this.edad = edad; }\n\n    @Override \n    public String toString(){\n        return \"Apellido: \" + apellido + \" Puesto: \" + puesto + \" Edad: \" + edad + \" a\u00f1os.\"; }\n\n    public int compareTo(Object o){\n        Jugador auxJugador = (Jugador) o; //se realiza downcasting\n        if(this.edadauxJugador.edad){ \n            return 1;\n        }else{\n            return 0;\n        }\n    }\n}\n</code></pre> <p>El m\u00e9todo <code>sort()</code> (seg\u00fan se expresa en la Documentaci\u00f3n API) requiere que todos los elementos del array implementen la interfaz <code>Comparable</code>. Esta interfaz tiene el m\u00e9todo abstracto <code>compareTo(Object o)</code> que deber\u00e1 ser implementado en la clase a la que pertenecen los objetos a comparar.</p> <p>El m\u00e9todo <code>compareTo(Object o)</code> deber\u00e1 devolver -1, 0 \u00f3 1 en funci\u00f3n de si la edad del primer jugador es menor, igual o mayor que la del segundo, respectivamente.</p>"},{"location":"uutt/ut07/076_Interfaces.html#implementando-una-interfaz","title":"Implementando una interfaz","text":"<p>Para indicar que una clase implementa los m\u00e9todos de una interfaz se utiliza la palabra clave <code>implements</code>. Las clases que implementan una interfaz deben implementar todos los m\u00e9todos abstractos contenidos en la interfaz. De lo contrario, ser\u00e1n clases abstractas y deber\u00e1n declararse como tal. </p> <p>A tener en cuenta</p> <p>Si una clase implementa una interfaz, todas sus clases derivadas heredan los m\u00e9todos implementados en la clase base y las constantes definidas en la interfaz.</p> <p>Una clase puede implementar m\u00e1s de una interfaz. En este caso, los nombres de las interfaces se escriben a continuaci\u00f3n de implements y separadas por comas:</p> <pre><code>public class UnaClase implements NombreInterface1, NombreInterface2, ...\n</code></pre> <p>Java y herencia m\u00faltiple</p> <p>El lenguaje Java no permite herencia m\u00faltiple, pero las interfaces proporcionan una alternativa para implementar algo parecido a la herencia m\u00faltiple de otros lenguajes. En Java una clase solo puede tener una clase base pero puede implementar m\u00faltiples interfaces.</p> <pre><code>public class ClaseDerivada extends ClaseBase implements Interface1, Interface2, Interface3, \u2026\n</code></pre> <p>Cuando hay una implementaci\u00f3n m\u00faltiple, es posible que dos interfaces tengan atributos o m\u00e9todos con el mismo nombre. La clase que implementa las interfaces recibir\u00e1 m\u00e9todos o atributos con el mismo nombre. A esto se le llama colisi\u00f3n. Java establece una serie de reglas para solucionar las colisiones. Para las colisiones de nombres de atributos se obliga a especificar el nombre de la interfaz base a la que pertenecen al utilizarlos:</p> <p><pre><code>NombreInterfaz.atributo;\n</code></pre> Para las colisiones de los nombres de m\u00e9todos:</p> <ul> <li>Si tiene el mismo nombre y diferentes par\u00e1metros se produce sobrecarga de m\u00e9todos, permiti\u00e9ndose que existan varias maneras de llamar al m\u00e9todo.</li> <li>Si solo cambia el valor devuelto, da un error de compilaci\u00f3n indicando que no se pueden implementar los dos.</li> <li>Si coinciden en sus declaraciones, se debe eliminar uno de los dos.</li> </ul> <p>Se puede establecer una jerarqu\u00eda de herencia entre interfaces, igual que con las clases.</p> <pre><code>public interface Interface2 extends Interface1{ \u2026}\npublic interface Interface3 extends Interface1{ \u2026}\n</code></pre> <p>La definici\u00f3n de una interfaz implica una definici\u00f3n de un nuevo tipo de referencia y por ello se puede usar el nombre de la interfaz como nombre de tipo. El nombre de una interfaz se puede utilizar en cualquier lugar donde pueda aparecer el nombre de un tipo de datos. Si se define una variable cuyo tipo es una interfaz, se le puede asignar un objeto que sea una instancia de una clase que implementa la interfaz.</p> <pre><code>Relacionable r1 = new Linea(2,2,4,1);\nRelacionable r2 = new Fraccion(4,7);\n\nSystem.out.println(r1); //ejecuta toString de L\u00ednea\nSystem.out.println(r2); //ejecuta toString de Fracci\u00f3n\n\nRelacionable [] array = new Relacionable[3];\narray[0] = new L\u00ednea(2,2,4,1);\narray[1] = new Fracci\u00f3n(4,7);\narray[2] = new L\u00ednea(14,3,22,1);\nfor(Relacionable r: array)\n    System.out.println(r);\n</code></pre> <p>En este caso dos clases no relacionadas, <code>Linea</code> y <code>Fraccion</code>, por implementar la misma interfaz <code>Relacionable</code> podemos manejarlas a trav\u00e9s de referencias a la interfaz y aplicar polimorfismo. Las interfaces proporcionan m\u00e1s polimorfismo que el que se puede obtener de una simple jerarqu\u00eda de clases.</p>"},{"location":"uutt/ut07/076_Interfaces.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 712 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7i CE7j / IC1 / 3p) Crea tres clases: <code>Circulo</code>, <code>Cuadrado</code> y <code>TrianguloEquilatero</code>, tendr\u00e1n un atributo cada clase que permite calcular el per\u00edmetro o \u00e1rea (ya sea lado o radio). Crea una interfaz llamada <code>ShapeOperable</code> que cada clase deber\u00e1 implementar para seguir una estandarizaci\u00f3n con m\u00e9todos de c\u00e1lculo de per\u00edmetro y \u00e1rea y la constante PI.</p> <p>Desarrolla un <code>main</code> que pida al usuario seleccionar la forma y luego una dimensi\u00f3n (lado o radio). Utilizando el polimorfismo, el programa usar\u00e1 la instancia correcta de la forma seleccionada e imprimir\u00e1 la forma seleccionada por el usuario y luego le preguntar\u00e1 que c\u00e1lculo desea realizar si per\u00edmetro o \u00e1rea e imprimir\u00e1 el resultado.</p> </li> <li> <p>AC 713 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7i CE7j / IC1 / 3p). Escribe un programa llamado <code>Herencia3</code> para una biblioteca que contenga libros y revistas. En primer lugar, para prevenir posibles cambios en el programa se tiene que implementar una interfaz <code>Prestable</code> con los m\u00e9todos <code>prestar</code> y <code>devolver</code>, sin valor de retorno, y prestado quien retorna un <code>booleano</code>. La clase <code>Libro</code> implementar\u00e1 esta interfaz.</p> <p>Ser\u00e1 necesario crear la clase base <code>Publicaci\u00f3n</code>, de la que heredar\u00e1n las clases <code>Libro</code> y <code>Revista</code>. Las caracter\u00edsticas comunes que se almacenan tanto para las revistas como para los libros son el c\u00f3digo, el titulo y el a\u00f1o de publicaci\u00f3n. Estas tres caracter\u00edsticas se pasan por par\u00e1metro en el momento de crear los objetos.</p> <p>Los libros tienen adem\u00e1s un atributo <code>prestado</code>. Los libros cuando se crean no est\u00e1n prestados.</p> <p>Las revistas tienen un n\u00famero. En el momento de crearlas se pasa el n\u00famero por par\u00e1metro.</p> <p>Tanto las revistas como los libros deben de tener (aparte de los constructores) un m\u00e9todo <code>toString</code> que devuelve el valor de todos los atributos en una cadena de caracteres. Tambi\u00e9n tienen un m\u00e9todo que devuelve el a\u00f1o de publicaci\u00f3n y otro para el c\u00f3digo.</p> </li> <li> <p>PR 714 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7i CE7j / IC2 / 10p). Se pretende realizar una aplicaci\u00f3n para una facultad que gestione la informaci\u00f3n sobre las personas vinculadas con la misma, que se pueden clasificar en tres tipos: estudiantes, profesores y personal de servicio. </p> <ul> <li> <p>1) A continuaci\u00f3n, se detalla qu\u00e9 tipo de informaci\u00f3n debe gestionar esta aplicaci\u00f3n:</p> <ul> <li>Por cada persona, se debe conocer, al menos, su nombre y apellidos, su n\u00famero de identificaci\u00f3n y su estado civil.</li> <li>Con respecto a los empleados, sean del tipo que sean, hay que saber su a\u00f1o de incorporaci\u00f3n a la facultad y qu\u00e9 n\u00famero de despacho tienen asignado.</li> <li>En cuanto a los estudiantes, se requiere almacenar el curso en el que est\u00e1n matriculados.</li> <li>Por lo que se refiere a los profesores, es necesario gestionar a qu\u00e9 departamento pertenecen (lenguajes, matem\u00e1ticas, arquitectura, ...).</li> <li>Sobre el personal de servicio, hay que conocer a qu\u00e9 secci\u00f3n est\u00e1n  asignados (biblioteca, decanato, secretar\u00eda, ...).</li> </ul> </li> <li> <p>2) Seguidamente se debe programar las clases definidas en las que, adem\u00e1s de los constructores, hay que desarrollar los m\u00e9todos correspondientes a las siguientes acciones:</p> <ul> <li>Cambio del estado civil de una persona.</li> <li>Reasignaci\u00f3n de despacho a un empleado.</li> <li>Matriculaci\u00f3n de un estudiante en un nuevo curso.</li> <li>Cambio de departamento de un profesor.</li> <li>Traslado de secci\u00f3n de un empleado del personal de servicio.</li> <li>Imprimir toda la informaci\u00f3n de cada tipo de individuo.</li> </ul> <p>Llegados a este punto, incluye un programa de prueba que instancie objetos de los distintos tipos y pruebe los m\u00e9todos desarrollados.</p> </li> <li> <p>3) Una vez comprobado lo anterior, se plantea extender el punto anterior incluyendo una clase que represente al centro docente. Esa clase incluir\u00e1 3 contenedores, uno por cada tipo de persona vinculada con el centro. En una primera fase deben incluirse los siguiente m\u00e9todos:</p> <ul> <li>Uno para dar de alta una persona, que incoporar\u00e1 a la persona en la lista correspondiente.</li> <li>Otro para dar de baja una persona, dado su DNI. A\u00f1ada un m\u00e9todo a la clase persona para poder obtener el DNI de un objeto de esa clase.</li> <li>Uno \u00faltimo para imprimir toda la informaci\u00f3n de las personas vinculadas con el centro.</li> </ul> <p>Piensa primero</p> <p>Dado que hay m\u00faltiples altenativas a la hora de afrontar este problema, a continuaci\u00f3n, se explican las caracter\u00edsticas de la soluci\u00f3n implementada, aunque el alumno podr\u00e1 realizar el dise\u00f1o que considere oportuno:</p> <ul> <li>El m\u00e9todo de alta recibe como par\u00e1metro un objeto del tipo persona correspondiente, existiendo, por tanto, tres versiones sobrecargadas del mismo.</li> <li>Se ha de usar array de objetos.</li> </ul> <p>El m\u00e9todo de baja busca, en primer lugar, un objeto en las listas que tenga el DNI recibido como par\u00e1metro. Una vez encontrado, lo inicializa a 0.</p> <p>Ten en cuenta</p> <p>Guarda la versi\u00f3n anterior y realiza este ejercicio sobre una copia de la misma, puesto que dicha versi\u00f3n previa ser\u00e1 utilizada en ejercicios posteriores.</p> </li> <li> <p>4) En la aplicaci\u00f3n anterior, se detecta que en el futuro se va a necesitar crear nuevos tipos de empleados (por ejemplo, investigadores) y distinguir entre distintos tipos de estudiantes. Por tanto, para que el dise\u00f1o se pueda adaptar a estas necesidades futuras, se plantea unificar todos los contenedores del tipo centro, de manera que s\u00f3lo haya un \u00fanico contenedor de personas, y usar polimorfismo para gestionar los distintos tipos de personas.</p> <p>Modifica el programa anterior para adaptarlo a este nuevo dise\u00f1o. Ten en cuenta que debe desaparecer cualquier referencia a profesores, personal de servicio y estudiantes en el c\u00f3digo de la clase que representa al centro. Asimismo, haz que las clases que corresponden a personas y empleados sean abstractas.</p> <p>Entrega</p> <p>Esta parte se diferenceciar\u00e1 del anterior con la nomenclatura <code>XXXXXXXAlt.java</code>, haciendo referencia a una versi\u00f3n alternativa.</p> </li> <li> <p>5) En la versi\u00f3n correspondiente al tercer punto, se va a a\u00f1adir un nuevo m\u00e9todo a las clases profesor y personal de servicio para calcular su salario. Se va a suponer que la forma de calcular el salario para estos dos tipos de empleados es totalmente distinta y que no se puede sacar ning\u00fan c\u00f3digo com\u00fan para incluirlo en la clase empleado. Haga la suposici\u00f3n que considere oportuna sobre c\u00f3mo calcular el sueldo de cada tipo de empleado, dado que no es importante para el ejemplo. </p> <p>Una propuesta</p> <p>Aqu\u00ed va una propuesta bastante rid\u00edcula: el personal de servicio cobra una cantidad fija m\u00e1s un 5% si est\u00e1n casados; el personal docente gana un fijo m\u00e1s un 8% si su fecha de incorporaci\u00f3n es anterior al 2000. Habilite los m\u00e9todos en la clase base que necesite para obtener los datos que requiera para el c\u00e1lculo del sueldo.</p> <p>Una vez a\u00f1adidos los m\u00e9todos para calcular el salario en cada una de las dos clases, debe a\u00f1adir un m\u00e9todo en la clase que representa el centro que imprima el salario de todos los empleados del centro (nombre y apellidos m\u00e1s el sueldo).</p> </li> <li> <p>6) Se plantea mejorar las clases dise\u00f1adas hasta ahora en los siguientes aspectos:</p> <ul> <li>A\u00f1adir una operaci\u00f3n leer en cada clase persona para leer los datos de la clase.</li> <li>Sobrecargar el operador constructor para que lea los datos de cada clase persona.</li> <li>Polimorfismo en el operador toString para que imprima los datos del centro.</li> </ul> </li> <li> <p>7) Hagamos algunas mejoras adicionales en la aplicaci\u00f3n desarrollada. Haz que el programa principal dialoge con el usuario pidi\u00e9ndolo qu\u00e9 tipo de operaci\u00f3n quiere llevar a cabo (alta, baja, imprimir listado o imprimir n\u00f3minas) y vaya pidiendo los datos que necesite para llevar a cabo la operaci\u00f3n.</p> </li> </ul> </li> <li> <p>PR 715 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7i CE7j / IC2 / 5p). Realiza un programa de nombre <code>AppAnimal</code> formado por los siguientes elementos:</p> <ul> <li>Clase <code>Animal</code>, con el atributo <code>protected</code> <code>nombre</code> de tipo <code>String</code>, y los m\u00e9todos abstractos <code>comer</code> sin valor de retorno y al que se le pasa como par\u00e1metro el <code>String</code> alimento mostrando la siguiente l\u00ednea \u201cEl [nombre_animal] come alimento.\u201d, y <code>nacer</code> que devuelve un <code>String</code> (viv\u00edparos u ov\u00edparos).</li> <li>Interfaz <code>Alimentable</code>, con un m\u00e9todo <code>segunAlimento</code> al que se le pasa el <code>String</code> alimento y devuelve un <code>String</code> indicando si el animal es carn\u00edvoro, omn\u00edvoro u herb\u00edvoro.</li> <li>Clase <code>Mamifero</code> que hereda de <code>Animal</code>, e implementa los m\u00e9todos <code>comer</code> y <code>nacer</code>, y la interfaz <code>Alimentable</code>.</li> <li>En el <code>main</code> de la clase <code>AppAnimal</code>:<ul> <li>Crea un objeto <code>Mamifero</code> m.</li> <li>Solicita al usuario el nombre del mam\u00edfero.</li> <li>Pide al usuario que indique la alimentaci\u00f3n del mam\u00edfero.</li> <li>Invoca al m\u00e9todo comer.</li> <li>Invoca al m\u00e9todo segunAlimento.</li> <li>Invoca al m\u00e9todo nacer.</li> </ul> </li> </ul> </li> </ul>"},{"location":"uutt/ut07/077_Casting.html","title":"Conversiones entre objetos (casting)","text":"<p>Java admite la conversi\u00f3n de tipos con ciertas limitaciones. Consideremos una jerarqu\u00eda de herencia como la que vemos en el siguiente diagrama de clases, sobre el que vamos a analizar las posibilidades de conversi\u00f3n de tipos de distintas formas.</p>"},{"location":"uutt/ut07/077_Casting.html#upcasting","title":"Upcasting","text":"<p>El upcasting es el proceso de convertir un objeto de una subclase en un objeto de su superclase. Este tipo de conversi\u00f3n es impl\u00edcito y seguro en Java porque cualquier instancia de una subclase es tambi\u00e9n una instancia de su superclase. Esto permite tratar a un objeto como una instancia de su clase padre</p>"},{"location":"uutt/ut07/077_Casting.html#downcasting","title":"Downcasting","text":"<p>El downcasting es el proceso inverso: convertir una referencia de superclase a una referencia de subclase. Este tipo de conversi\u00f3n debe ser expl\u00edcito en Java, y solo es seguro si el objeto que se est\u00e1 convirtiendo es realmente una instancia de la subclase. Si no lo es, se generar\u00e1 una excepci\u00f3n <code>ClassCastException</code>.</p>"},{"location":"uutt/ut07/077_Casting.html#casting-en-horizontal","title":"Casting en horizontal","text":"<p>Se tratar\u00eda de poner lo que est\u00e1 a un lado al otro lado, esto no es posible de ning\u00fan modo.</p>"},{"location":"uutt/ut07/077_Casting.html#implementacion-de-casting","title":"Implementaci\u00f3n de casting","text":"<pre><code>Profesor p1; //p1 es tipo Profesor. Admite ser Profesor, ProfesorTitular o ProfesorInterino\nProfesorInterino p44 = new ProfesorInterino(); //p44 es ProfesorInterino.\np1 = p44; // Conversi\u00f3n hacia arriba: sin problema. Ahora p1 que es tipo profesor, almacena un profesor interino\np44 = p1 // ERROR en la conversi\u00f3n hacia abajo.\n</code></pre> <p>Determinaci\u00f3n del tipo de variables</p> <p>La palabra clave <code>instanceof</code>, todo en min\u00fasculas, sirve para verificar el tipo de una variable. La sintaxis que emplearemos para <code>instanceof</code> y sus normas de uso ser\u00e1n las siguientes:</p> <ul> <li>a. S\u00f3lo se pueden comparar instancias que relacionen dentro de la jerarqu\u00eda de tipos (en cualquier direcci\u00f3n) pero no objetos que no relacionen en una jerarqu\u00eda. Es decir, no podemos comparar profesores con taxis por ejemplo, porque no relacionar\u00e1n dentro de una jerarqu\u00eda.</li> <li>b. Solo se puede usar <code>instanceof</code> asociado a un condicional. </li> </ul> <pre><code>if (profesor43 instanceof ProfesorInterino) {\n    \u2026\n} else { \n    \u2026\n}\n</code></pre>"},{"location":"uutt/ut07/077_Casting.html#actividad","title":"Actividad","text":"<ul> <li> <p>PR 716 (RA7/ CE7a CE7b CE7c CE7d CE7e CE7f CE7g CE7h CE7i CE7j / IC2 / 5p) Realiza un programa de nombre <code>AppCompra</code> formado por las siguientes clases:</p> <ul> <li>Clase abstracta llamada <code>Producto</code> con el atributo <code>protected</code> <code>gasto</code> de tipo <code>double</code> y el m\u00e9todo abstracto <code>gastoConIva()</code> que no recibir\u00e1 par\u00e1metros pero devolver\u00e1 un tipo <code>double</code>.</li> <li>Clase <code>Leche</code>, que hereda de <code>Producto</code>, con el atributo privado <code>litros_leche</code> de tipo entero, que implementa el m\u00e9todo <code>gastoConIva()</code>, el cual devolver\u00e1 <code>gasto</code> de tipo <code>double</code>.</li> <li>Clase <code>Salm\u00f3n</code>, que hereda de <code>Producto</code>, con el atributo privado <code>kilos_salmon</code> de tipo <code>double</code>, que implementa el m\u00e9todo <code>gastoConIva()</code>, el cual devolver\u00e1 <code>gasto</code> de tipo <code>double</code>.</li> <li>Clase <code>Whisky</code>, que hereda de <code>Producto</code>, con el atributo privado <code>litros_whisky</code> de tipo entero, que implementa el m\u00e9todo <code>gastoConIva()</code>, el cual devolver\u00e1 <code>gasto</code> de tipo <code>double</code>.</li> <li> <p>Existe polimorfismo en el m\u00e9todo <code>gastoConIva()</code>, pues realizar\u00e1 las siguientes operaciones en funci\u00f3n del producto:</p> <ul> <li>Producto Precio unidad IVA Operaci\u00f3n realizada en el m\u00e9todo gastoConIva()</li> <li>Leche 1.95/litro Superreducido (4%) gasto = (double) litros_leche1.951.04</li> <li>Salm\u00f3n 11.85/kilo Reducido (8%) gasto = kilos_salmon11.85 1.08</li> <li>Whisky 11.90/litro Normal (21%) gasto = (doubl\u00e9) litros_whisky11.901.21</li> </ul> </li> <li> <p>En el <code>main</code> de la clase <code>AppCompra</code>:</p> <ul> <li>Crea, mediante upcasting, un objeto <code>p1</code> de <code>Producto</code> instanciando al constructor <code>Leche</code>, otro objeto <code>p2</code> de <code>Producto</code> instanciando al constructor <code>Salm\u00f3n</code> y un tercero <code>p3</code> de <code>Producto</code> instanciando al constructor <code>Whisky</code>.</li> <li>A continuaci\u00f3n, debe invocarse el m\u00e9todo <code>gastoConIva</code> aplicado a <code>p1</code> y mostrar por pantalla su gasto.</li> <li>Seguidamente debe invocarse el m\u00e9todo <code>gastoConIva</code> aplicado a <code>p2</code> y mostrar su gasto.</li> <li>Finalmente debe invocarse el m\u00e9todo <code>gastoConIva</code> aplicado a <code>p3</code> y mostrar su gasto</li> </ul> </li> </ul> </li> </ul>"},{"location":"uutt/ut07/078_ClasesAnidadas.html","title":"Clases anidadas","text":"<p>Decimos que una clase es anidada si est\u00e1 contenida en otra clase. Hay varios tipos de clases anidadas en Java:</p> <ul> <li>Clase anidada interna.</li> <li>Clase anidada est\u00e1tica.</li> <li>Clase local.</li> <li>Clase an\u00f3nima.</li> </ul>"},{"location":"uutt/ut07/078_ClasesAnidadas.html#clase-anidada-interna","title":"Clase anidada interna.","text":"<p>El anidamiento de una clase tiene por objetivo favorecer el encapsulamiento. Una clase anidada se dice que es interna si se la declara dentro de otra clase pero fuera de cualquier m\u00e9todo de la clase contenedora. Puede declararse con cualquiera de los modificadores: <code>private</code>, <code>protected</code> o <code>public</code>.</p> <p>Una caracter\u00edstica fundamental es que una clase interna tiene acceso a todos los atributos de la clase que la contiene, luego para que exista una clase anidada interna es necesario que exista un objeto de la clase contenedora.</p> Clase anidada internaEjemplo de uso <pre><code>import java.util.ArrayList;\npublic class Coordenadas {\n    private class Punto {\n        private int x, y;\n        public Punto(int x, int y) {\n            fijarX(x);\n            fijarY(y);\n        }\n        public void fijarX(int x) {\n            this.x = x;\n        }\n        public void fijarY(int y) {\n            this.y = y;\n        }\n        public int retornarCuadrante() {\n            if (x &gt; 0 &amp;&amp; y &gt; 0)\n                return 1;\n            else if (x &lt; 0 &amp;&amp; y &gt; 0)\n                return 2;\n            else if (x &lt; 0 &amp;&amp; y &lt; 0)\n                return 3;\n            else if (x &gt; 0 &amp;&amp; y &lt; 0)\n                return 4;\n            else\n                return -1;\n        }\n    }\n    private ArrayList&lt;Punto&gt; puntos;\n    public Coordenadas() {\n        puntos = new ArrayList&lt;Punto&gt;();\n    }\n    public void agregarPunto(int x, int y) {\n        puntos.add(new Punto(x, y));\n    }\n    public int cantidadPuntosCuadrante(int cuadrante) {\n        int cant = 0;\n        for (Punto pun : puntos)\n            if (pun.retornarCuadrante() == cuadrante)\n                cant++;\n        return cant;\n    }\n}\n</code></pre> <pre><code>public class PruebaCoordenadas {\n    public static void main(String[] args) {\n        Coordenadas coordenadas = new Coordenadas();\n        coordenadas.agregarPunto(30, 30);\n        coordenadas.agregarPunto(2, 7);\n        coordenadas.agregarPunto(-3, 2);\n        coordenadas.agregarPunto(-5, -4);\n        coordenadas.agregarPunto(-9, -2);\n        System.out.println(\"Cantidad de puntos en el primer cuadrante:\" + coordenadas.cantidadPuntosCuadrante(1));\n        System.out.println(\"Cantidad de puntos en el segundo cuadrante:\" + coordenadas.cantidadPuntosCuadrante(2));\n        System.out.println(\"Cantidad de puntos en el tercer cuadrante:\" + coordenadas.cantidadPuntosCuadrante(3));\n        System.out.println(\"Cantidad de puntos en el cuarto cuadrante:\" + coordenadas.cantidadPuntosCuadrante(4));\n    }\n}\n</code></pre>"},{"location":"uutt/ut07/078_ClasesAnidadas.html#clase-anidada-estatica","title":"Clase anidada est\u00e1tica.","text":"<p>En Java podemos definir clases internas con el modificador <code>static</code>. Luego la clase interna se comporta como una clase normal de Java con la salvedad que se encuentra dentro de otra.</p> <p>Para crear un objeto de la clase interna tenemos que utilizar la siguiente sintaxis</p> Clase anidada est\u00e1ticaEjemplo de uso <pre><code>public class Externa {\n    public static class Interna {\n        public void imprimir() {\n            System.out.println(\"Clase interna est\u00e1tica\");\n        }\n    }\n    public void imprimir() {\n        System.out.println(\"Clase externa\");\n    }\n}\n</code></pre> <pre><code>public class PruebaClaseInterna {\n    public static void main(String[] args) {\n        Externa.Interna interna = new Externa.Interna();\n        interna.imprimir();\n    }\n}\n</code></pre>"},{"location":"uutt/ut07/078_ClasesAnidadas.html#clase-local","title":"Clase local.","text":"<p>El lenguaje Java permite declarar una clase local a un m\u00e9todo o inclusive a un bloque dentro de un m\u00e9todo.</p> Clase local <pre><code>public class Externa {\n    public void imprimir() {\n        System.out.println(\"Comienzo del m\u00e9todo imprimir de la clase Externa.\");\n        class Local {\n            public void imprimir() {\n                System.out.println(\"M\u00e9todo imprimir de la clase Local.\");\n            }\n        }\n        Local local1 = new Local();\n        local1.imprimir();\n        System.out.println(\"Fin del m\u00e9todo imprimir de la clase Externa.\");\n    }\n    public static void main(String[] args) {\n        Externa externa1 = new Externa();\n        externa1.imprimir();\n    }\n}\n</code></pre>"},{"location":"uutt/ut07/078_ClasesAnidadas.html#clase-anonima","title":"Clase an\u00f3nima.","text":"<p>Las clases an\u00f3nimas en Java son clases anidadas sin un nombre de clase. Normalmente se declaran como una subclase de una clase existente o como la implementaci\u00f3n de una interfaz:</p> Clase an\u00f3nima <pre><code>public class PruebaClaseAnonima {\n    abstract class A {\n        public abstract void imprimir();\n    }\n    interface B {\n        void imprimir();\n    }\n    public void probar() {\n        (new A() {\n            public void imprimir() {\n                System.out.println(\"Clase\");\n            }\n        }).imprimir();\n        (new B() {\n            public void imprimir() {\n                System.out.println(\"Interface\");\n            }\n        }).imprimir();\n    }\n\n    public static void main(String[] args) {\n        PruebaClaseAnonima p = new PruebaClaseAnonima();\n        p.probar();\n    }\n}\n</code></pre>"},{"location":"uutt/ut07/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 07","text":""},{"location":"uutt/ut07/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA4.CERA7.CE <ul> <li>Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos.</li> </ul> <ul> <li>g. Se han definido y utilizado clases heredadas.</li> <li>h. Se han creado y utilizado m\u00e9todos est\u00e1ticos.</li> <li>i. Se han creado y utilizado conjuntos y librer\u00edas de clases.</li> </ul> <ul> <li>Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n</li> </ul> <ul> <li>a. Se han identificado los conceptos de herencia, superclase y subclase.</li> <li>b. Se han utilizado modificadores para bloquear y forzar la herencia de clases y m\u00e9todos.</li> <li>c. Se ha reconocido la incidencia de los constructores en la herencia.</li> <li>d. Se han creado clases heredadas que sobrescriben la implementaci\u00f3n de m\u00e9todos de la superclase.</li> <li>e. Se han dise\u00f1ado y aplicado jerarqu\u00edas de clases.</li> <li>f. Se han probado y depurado las jerarqu\u00edas de clases.</li> <li>g. Se han realizado programas que implementen y utilicen jerarqu\u00edas de clases.</li> <li>h. Se ha comentado y documentado el c\u00f3digo. </li> <li>i. Se han identificado y evaluado los escenarios de uso de interfaces. </li> <li>j. Se han identificado y evaluado los escenarios de utilizaci\u00f3n de la herencia y la composici\u00f3n.</li> </ul>"},{"location":"uutt/ut07/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li>Creaci\u00f3n de paquetes</li> <li>Concepto de Herencia<ol> <li>Tipos de herencia en los lenguajes</li> <li>Herencia en Java</li> </ol> </li> <li>Polimorfismo<ol> <li>Sobrescritura de m\u00e9todos</li> <li>M\u00e9todos y clases abstractos y finales</li> </ol> </li> <li>Acceso a la superclase</li> <li>Visibilidad de miembros y m\u00e9todos</li> <li>Interfaces<ol> <li>Implementaci\u00f3n de una interfaz</li> </ol> </li> <li>Conversiones entre objetos (casting)</li> <li>Clases anidadas</li> </ol>"},{"location":"uutt/ut07/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>07/01/2025</p> <p>Creaci\u00f3n de paquetes</p> <p></p> <p>02</p> <p>08/01/2025</p> <p>Herencia</p> <p>AC 701</p> <p>03</p> <p>08/01/2025</p> <p></p> <p>AC 702</p> <p>04</p> <p>09/01/2025</p> <p></p> <p>AC 703</p> <p>05</p> <p>09/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>06</p> <p>10/01/2025</p> <p>Acceso a la superclase</p> <p></p> <p>07</p> <p>13/01/2025</p> <p></p> <p>AC 704</p> <p>08</p> <p>13/01/2025</p> <p></p> <p>AC 705</p> <p>09</p> <p>14/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>10</p> <p>15/01/2025</p> <p></p> <p>PR 707</p> <p>11</p> <p>15/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>12</p> <p>16/01/2025</p> <p></p> <p>PR 708</p> <p>13</p> <p>16/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>14</p> <p>17/01/2025</p> <p>Polimorfismo</p> <p>AC 709</p> <p>15</p> <p>20/01/2025</p> <p>Visibilidad</p> <p>AC 710</p> <p>16</p> <p>20/01/2025</p> <p></p> <p>AC 711</p> <p>17</p> <p>21/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>18</p> <p>22/01/2025</p> <p>Interfaces</p> <p>AC 712</p> <p>19</p> <p>22/01/2025</p> <p></p> <p>AC 713</p> <p>20</p> <p>23/01/2025</p> <p></p> <p>PR 714</p> <p>21</p> <p>23/01/2025</p> <p></p> <p>PR 714</p> <p>22</p> <p>24/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>23</p> <p>27/01/2025</p> <p></p> <p>PR 715</p> <p>24</p> <p>27/01/2025</p> <p></p> <p>PR 715</p> <p>25</p> <p>28/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>26</p> <p>29/01/2025</p> <p>Casting</p> <p>PR 716</p> <p>27</p> <p>29/01/2025</p> <p></p> <p>PR 716</p> <p>28</p> <p>30/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>29</p> <p>30/01/2025</p> <p></p> <p>Trabajo en clase</p> <p>30</p> <p>31/01/2025</p> <p></p> <p>PO UT 07 - Test</p> <p>31</p> <p>03/02/2025</p> <p></p> <p>PO UT 07 - Pr\u00e1ctico</p> <p>32</p> <p>03/02/2025</p> <p></p> <p>PO UT 07 - Pr\u00e1ctico</p>"},{"location":"uutt/ut07/ResumenUT.html#referencias","title":"Referencias","text":""},{"location":"uutt/ut07/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":""},{"location":"uutt/ut08/081_IntroduccionExcepciones.html","title":"Introducci\u00f3n","text":"<p>Tanto en el proceso de la creaci\u00f3n de un programa en cualquier lenguaje como posteriormente al hacerlo funcionar se pueden cometer diversos errores que es conveniente detectar y clasificar para manejarlos y que los programas no se queden \u201ccolgados\u201d y sigan su funcionamiento a pesar de haber ocurrido un error.</p> <p>El lenguaje Java incorpora soporte para manejar situaciones an\u00f3malas, conocidas como \u201cexcepciones\u201d, para atender a los errores que pueden ocurrir durante la ejecuci\u00f3n de un programa. Con el sistema de manipulaci\u00f3n de excepciones de Java, un programa puede comunicar eventos inesperados a un contexto de ejecuci\u00f3n m\u00e1s capacitado para responder a tales eventos anormales. Estas excepciones son manejadas por c\u00f3digo fuera del flujo normal de control del programa.</p>"},{"location":"uutt/ut08/081_IntroduccionExcepciones.html#cuando-y-como-se-provoca-una-excepcion","title":"\u00bfCu\u00e1ndo y c\u00f3mo se provoca una excepci\u00f3n?","text":"<p>Una excepci\u00f3n se puede provocar al acontecer, por ejemplo, alguna de las siguientes situaciones:</p> <ul> <li>No hay memoria disponible para asignar.</li> <li>Acceso a un elemento de un array fuera de rango.</li> <li>Leer por teclado un dato de un tipo distinto al esperado.</li> <li>Error al abrir un fichero que no se encuentra.</li> <li>Divisi\u00f3n por cero.</li> <li>Problemas de Hardware.</li> </ul> <p>Si la excepci\u00f3n no se trata, el manejador de excepciones realiza lo siguiente:</p> <ul> <li>Muestra la descripci\u00f3n de la excepci\u00f3n.</li> <li>Muestra la traza de la pila de llamadas.</li> <li>Provoca el final del programa.</li> </ul>"},{"location":"uutt/ut08/081_IntroduccionExcepciones.html#pila-de-llamadas","title":"Pila de llamadas","text":"Pila de llamadas.<pre><code>package exceppiladellamadas;\nimport java.util.Scanner;\npublic class ExcepPiladellamadas {\n    static void incluirNumerador(){\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Indica el numerador: \");\n        int num = sc.nextInt();\n        incluirDenominador(num);\n    }\n    static void incluirDenominador(int n){\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Indica el denominador: \");\n        int den = sc.nextInt(); realizarDivisi\u00f3n(n, den);\n    }\n    static void realizarDivisi\u00f3n(int n, int d){\n        System.out.println(\"La divisi\u00f3n es: \" + n/d);\n    }\n    public static void main(String[] args) {\n        incluirNumerador();\n    }\n}\n</code></pre> <p>Salida </p> <p>Ejemplos de c\u00f3digo Java que provocan una excepci\u00f3n:</p> <p>El manejo de excepciones proporciona una separaci\u00f3n entre el c\u00f3digo b\u00e1sico y el c\u00f3digo que maneja los errores, haci\u00e9ndolo m\u00e1s legible. Utilizando excepciones se consigue:</p> <ul> <li>Separar las instrucciones del programa de las del tratamiento de errores.</li> <li>Evitar llenar el c\u00f3digo del programa de instrucciones de comprobaci\u00f3n (<code>if</code>, <code>switch</code>, etc).</li> <li>El c\u00f3digo es m\u00e1s simple de escribir ya que no se fuerza al programador a comprobar los errores constantemente.</li> </ul>"},{"location":"uutt/ut08/081_IntroduccionExcepciones.html#que-ocurre-cuando-se-produce-una-excepcion","title":"\u00bfQu\u00e9 ocurre cuando se produce una excepci\u00f3n?","text":"<p>Cuando ocurre una excepci\u00f3n:</p> <ul> <li>La M\u00e1quina Virtual Java crea un objeto excepci\u00f3n y lo lanza. El objeto excepci\u00f3n creado contiene informaci\u00f3n sobre el error. La ejecuci\u00f3n normal del programa se detiene.</li> <li>El sistema busca en el m\u00e9todo donde se ha producido la excepci\u00f3n un manejador de excepciones que capture(catch) ese objeto y trate la excepci\u00f3n.</li> <li>Si el m\u00e9todo no contiene un manejador para la excepci\u00f3n se busca en el m\u00e9todo que llam\u00f3 a este y as\u00ed sucesivamente en toda la pila de llamadas. </li> </ul> <ul> <li>Cuando se encuentra un manejador apropiado se le pasa la excepci\u00f3n. Un manejador de excepciones es considerado apropiado si el tipo de objeto excepci\u00f3n lanzado es compatible al tipo que puede manejar.</li> <li>Si no se encuentra un manejador adecuado la M\u00e1quina Virtual Java muestra el error y acaba el programa.</li> </ul>"},{"location":"uutt/ut08/082_Jerarquia.html","title":"Jerarqu\u00eda de excepciones","text":"<p>Todas las excepciones lanzadas autom\u00e1ticamente en un programa Java son objetos de la clase <code>Throwable</code> (Lanzable) o de alguna de sus clases derivadas. La clase <code>Throwable</code> deriva directamente de Object y tiene dos clases derivadas directas: <code>Error</code> y <code>Exception</code>.</p> <p>La <code>API</code><sup>1</sup> Java es una interfaz de programaci\u00f3n de aplicaciones provista por los creadores del lenguaje de programaci\u00f3n Java, que da a los programadores los medios para desarrollar aplicaciones Java. Como el lenguaje Java es un lenguaje orientado a objetos, la <code>API</code> provee de un conjunto de clases utilitarias para efectuar toda clase de tareas necesarias dentro de un programa. La <code>API</code> Java est\u00e1 organizada en paquetes l\u00f3gicos, donde cada paquete contiene un conjunto de clases relacionadas sem\u00e1nticamente.</p> <p>La clase <code>Error</code> est\u00e1 relacionada con errores de la m\u00e1quina virtual de Java. Generalmente estos errores no dependen del programador, por lo que no nos debemos preocupar por tratarlos, por ejemplo, <code>OutOfMemoryError</code>, <code>StackOverflowError</code>, errores de hardware, etc.</p> <p>En la clase <code>Exception</code> se encuentran las excepciones que se pueden lanzar en una aplicaci\u00f3n. Tiene varias subclases, entre ellas:</p> <ul> <li><code>RuntimeException</code>: son excepciones lanzadas durante la ejecuci\u00f3n del programa. Por ejemplo: <code>ArithmeticException</code>, <code>NullPointerException</code>, <code>ArrayIndexOutOfBoundsException</code>, etc. y pertenecen al paquete <code>java.lang</code>.</li> <li><code>IOException</code>: son excepciones lanzadas al ejecutar una operaci\u00f3n de entrada-salida. Pertenecen al paquete <code>java.io</code>.</li> <li><code>ClassNotFoundException</code>: excepci\u00f3n lanzada cuando una aplicaci\u00f3n intenta cargar una clase, pero no se encuentra el fichero <code>.class</code> correspondiente.</li> </ul>"},{"location":"uutt/ut08/082_Jerarquia.html#metodos-de-la-clase-throwable","title":"M\u00e9todos de la clase <code>Throwable</code>","text":"<p><code>Throwable</code> es la clase de la que derivan todos los dem\u00e1s tipos de excepciones. Tiene los siguientes constructores:</p> <ul> <li><code>Throwable()</code> genera un objeto de la clase con un mensaje de error nulo.</li> <li><code>Throwable(String mensaje)</code> genera un objeto de la clase con un mensaje.</li> </ul> <p>Los m\u00e9todos de <code>Throwable</code> est\u00e1n disponibles en todas las clases que derivan de ella. Algunos de estos m\u00e9todos son:</p> <ul> <li>String <code>getMessage()</code>: Devuelve el mensaje que se asoci\u00f3 al objeto cuando se cre\u00f3.</li> <li>String <code>toString()</code>: Devuelve una descripci\u00f3n del objeto. Suele indicar el nombre de la clase y el text de <code>getMessage()</code>.</li> <li>void <code>printStackTrace()</code>. Es el m\u00e9todo invocado por la m\u00e1quina virtual cuando se produce una excepci\u00f3n. Aparece un listado con toda la pila de llamadas a m\u00e9todos hasta que se llega al que provoc\u00f3 la excepci\u00f3n.</li> </ul>"},{"location":"uutt/ut08/082_Jerarquia.html#actividad","title":"Actividad","text":"<ul> <li>AC801 (RA3 / CE3d CE3f CE3i / IC1 / 3p). Dado el siguiente programa en Java indica cada uno de los errores que aparecer\u00e1n como resultado de su compilaci\u00f3n y su ejecuci\u00f3n.     <pre><code>import java.util.Scanner;\n\npublic class Ejerc1 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[] array = new int[5];\n        int buscado;\n\n        array[0] = 15;\n        array[1] = 6;\n        array[2] = 8;\n        array[3] = 9;\n        array[4] = 12;\n\n        System.out.println(\"Introduce el n\u00famero a buscar en el array: \");\n        buscado = sc.nextInt();\n\n        for (int i = 0; i &lt; 6; i++) {\n            if (buscado == array[i]) {\n                System.out.println(\"El n\u00famero buscado est\u00e1 en la posici\u00f3n: \" + i);\n            }\n        }\n    }\n}\n</code></pre><ul> <li>Introduce el n\u00famero a buscar en el array: 5.4</li> <li>Corrige la excepci\u00f3n</li> </ul> </li> </ul> <ol> <li> <p>API, por sus siglas del ingl\u00e9s: Application Programming Interface\u00a0\u21a9</p> </li> </ol>"},{"location":"uutt/ut08/083_Tratamiento.html","title":"Tratamiento de excepciones","text":"<p>Un programa que trate las excepciones debe realizar los siguientes pasos:</p> <ol> <li>Se intenta (<code>try</code>) ejecutar un bloque de c\u00f3digo.</li> <li>Si se produce una circunstancia excepcional se lanza (<code>throw</code>) una excepci\u00f3n. En caso contrario el programa sigue su curso normal.</li> <li>Si se ha lanzado una excepci\u00f3n, la ejecuci\u00f3n del programa es desviada al manejador de excepciones donde la excepci\u00f3n se captura (<code>catch</code>) y se decide qu\u00e9 hacer al respecto.</li> </ol> <pre><code>try{\n    //Instrucciones que se intentan ejecutar, si se produce una\n    //situaci\u00f3n inesperada se lanza una excepci\u00f3n\n} catch(tipoExcepcion e){\n    //Instrucciones para tratar esta excepci\u00f3n\n} catch(otroTipoExcepcion e){\n    //Instrucciones para tratar esta excepci\u00f3n\n}\n//Se pueden escribir tantos bloques catch como sean necesarios\nfinally{\n    //instrucciones que se ejecutar\u00e1n siempre despu\u00e9s de un bloque try,\n    //se haya producido o no una excepci\u00f3n\n}\n</code></pre>"},{"location":"uutt/ut08/083_Tratamiento.html#bloque-try","title":"Bloque <code>try</code>","text":"<ul> <li>En el bloque <code>try</code> se encuentran las instrucciones que pueden lanzar una excepci\u00f3n.</li> <li>Solamente se pueden capturar las excepciones lanzadas dentro del bloque <code>try</code>.</li> <li>Una excepci\u00f3n se puede lanzar de forma autom\u00e1tica o mediante la palabra reservada <code>throw</code>.</li> <li>Cuando se lanza la excepci\u00f3n se transfiere la ejecuci\u00f3n del programa desde el punto donde se lanza la excepci\u00f3n a otro punto donde se captura.</li> </ul>"},{"location":"uutt/ut08/083_Tratamiento.html#bloque-catch","title":"Bloque <code>catch</code>","text":"<ul> <li>Es el bloque de c\u00f3digo donde se captura la excepci\u00f3n.</li> <li>El bloque <code>catch</code> es el manejador o handler de la excepci\u00f3n.</li> <li>Aqu\u00ed se decide qu\u00e9 hacer con la excepci\u00f3n capturada.</li> <li>Puede haber varios bloques catch relacionados con un bloque <code>try</code>.</li> <li>Una vez finalizado un bloque <code>catch</code> la ejecuci\u00f3n no vuelve al punto donde se lanz\u00f3 la excepci\u00f3n, sino que contin\u00faa por la primera instrucci\u00f3n a continuaci\u00f3n de los bloques <code>catch</code>.</li> </ul>"},{"location":"uutt/ut08/083_Tratamiento.html#bloque-finally","title":"Bloque <code>finally</code>","text":"<ul> <li>Es un bloque opcional y debe aparecer a continuaci\u00f3n de los bloques <code>catch</code>.</li> <li>Tambi\u00e9n puede aparecer a continuaci\u00f3n de un bloque <code>try</code> si no hay bloques <code>catch</code>.</li> <li> <p>La ejecuci\u00f3n de sus instrucciones queda garantizada independientemente de que el bloque <code>try</code> acabe o no su ejecuci\u00f3n, incluso en los siguientes casos:</p> <ul> <li>Aunque el bloque <code>try</code> tenga una sentencia <code>return</code>, <code>continue</code> o <code>break</code>, se ejecutar\u00e1 el bloque <code>finally</code>.</li> <li>Cuando se haya lanzado una excepci\u00f3n que ha sido capturada por un bloque <code>catch</code>. El <code>finally</code> se ejecuta despu\u00e9s del <code>catch</code> correspondiente.</li> <li>Si se ha lanzado una excepci\u00f3n que no ha sido capturada, se ejecuta <code>finally</code> antes de acabar el programa.</li> </ul> </li> <li> <p>Un bloque <code>finally</code> se usa para dejar un estado consistente despu\u00e9s de ejecutar el bloque <code>try</code>.</p> </li> <li>Un ejemplo de uso de bloques <code>finally</code> puede ser cuando estamos tratando con ficheros y se produce una excepci\u00f3n. Podemos escribir un bloque <code>finally</code> para cerrar el fichero. Este bloque se ejecutar\u00e1 siempre y se liberar\u00e1n los recursos ocupados por el fichero.</li> </ul> <pre><code>/*El siguiente programa lee un n\u00famero entero y lo muestra. Si en la instrucci\u00f3n sc.nextInt() \nse introduce un n\u00famero de otro tipo o un car\u00e1cter, se lanza una excepci\u00f3n InputMismatchException \nque es capturada por el bloque catch. \nEn este bloque se realizan las instrucciones necesarias para \nresolver la situaci\u00f3n y que el programa pueda continuar.*/\n\npublic static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n;\n    do{\n        try{\n            System.out.print(\"Introduce un n\u00famero entero &gt; 0: \");\n            n = sc.nextInt();\n            System.out.println(\"Num. introducido: \" + n);\n        } catch(InputMismatchException e){\n            sc.nextLine(); //retorna la tecla enter\n            n = 0;\n            System.out.println(\"Introduzca un entero \" + e.toString());\n        }\n    }while(n&lt;=0);\n}\n</code></pre>"},{"location":"uutt/ut08/083_Tratamiento.html#captura-de-excepciones","title":"Captura de excepciones","text":"<p>Un bloque <code>try</code> puede estar seguido de varios bloques <code>catch</code>, tantos como excepciones diferentes queramos manejar.</p> <p>La estructura y el comportamiento de un bloque <code>catch</code> son similares al de un m\u00e9todo. La excepci\u00f3n es capturada por el bloque <code>catch</code> cuyo argumento coincida con el tipo de objeto lanzado.</p> <p>La b\u00fasqueda de coincidencia se realiza sucesivamente sobre los bloques <code>catch</code> en el orden en que aparecen en el c\u00f3digo hasta que aparece la primera concordancia.</p> <p>Cuando acaba la ejecuci\u00f3n de este bloque, el programa contin\u00faa despu\u00e9s del \u00faltimo de los catch que sigan al bloque <code>try</code> que lanz\u00f3 la excepci\u00f3n.</p> <p>Cuidado con las anidaciones</p> <p>El sistema de control de excepciones puede ser anidado a cualquier nivel. Debe mantenerse la regla de que un bloque <code>try</code> debe ser seguido por un <code>catch</code>. Pueden existir secuencias <code>try-catch</code> dentro de bloques <code>try</code> y de bloques <code>catch</code>.</p> <p>Cada <code>catch</code> debe tener como par\u00e1metro un objeto de la clase <code>Throwable</code>, de una clase derivada de ella o de una clase definida por el programador.</p> <p>Cuando se lanza una excepci\u00f3n se captura por el primer bloque <code>catch</code> cuyo par\u00e1metro sea de la misma clase que el objeto excepci\u00f3n o de una clase base directa o indirecta. Por este motivo, es importante el orden en que se coloquen los bloques <code>catch</code>.</p> <p>Las excepciones m\u00e1s gen\u00e9ricas se deben capturar al final. Si no es necesario tratar excepciones concretas de forma espec\u00edfica se puede poner un bloque <code>catch</code> de una clase base que las capture todas y las trate de forma general. Esto se conoce como captura gen\u00e9rica de excepciones.</p> <pre><code>public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int [] array = {4,2,6,7};\n    int n;\n    boolean repetir = false;\n    do{\n        try{\n            repetir = false;\n            System.out.print(\"Un entero &gt; 0 y &lt; \" + array.length + \" \");\n            n = sc.nextInt();\n            System.out.println(\"Valor en la posici\u00f3n \" + n + \": \" + array[n]);\n        } catch(InputMismatchException e){\n            sc.nextLine();\n            n = 0;\n            System.out.println(\"Debe introducir un entero \");\n            repetir = true;\n        } catch(IndexOutOfBoundsException e){\n            System.out.println(\"Un entero &gt; 0 y &lt; \" + array.length + \" \");\n            repetir = true;\n        } catch(Exception e){\n            // resto de excepciones de tipo Exception\n            // y derivadas\n            System.out.println(\"Error inesperado \" + e.toString());\n            repetir = true;\n        }\n    }while(repetir);\n}\n</code></pre>"},{"location":"uutt/ut08/083_Tratamiento.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 802 (RA3 / CE3d CE3f CE3i / IC1 / 3p). Escriba un programa que permita al usuario jugar a adivinar un n\u00famero. El ordenador debe generar un n\u00famero entero entre 1 y 100 y el usuario intentar\u00e1 adivinarlo. Para ello, cada vez que el usuario introduce un valor, el ordenador debe indicar si el n\u00famero buscado es mayor o menor que el que se ha introducido. Cuando consiga adivinarlo debe indicarlo e imprimir en pantalla el n\u00famero de intentos necesarios para encontrar el n\u00famero. Si el usuario no introduce un n\u00famero entero debe lanzarse y capturarse una excepci\u00f3n, mostrando la forma correcta de hacerlo, y contarlo como un intento.</p> </li> <li> <p>AC 803 (RA3 / CE3d CE3f CE3i / IC1 / 3p). Dado el siguiente programa en Java trata las excepciones que se puedan producir.</p> <pre><code>import java.util.Scanner;\n\npublic class Ejercicio3 {\n\n    static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        double n;\n        int posicion;\n        String cadena;\n        double[] valores = {9.83, 4.5, -3.06, 0.06, 2.52, -11.3, 7.60, 3.00, -30.4, 105.2};\n\n        System.out.println(\"Contenido del array antes de modificar:\");\n        for (int i = 0; i &lt; valores.length; i++) {\n            System.out.printf(\"%.2f \", valores[i]);\n        }\n\n        System.out.print(\"\\n\\nIntroduce la posici\u00f3n del array a modificar: \");\n        cadena = sc.nextLine();\n        posicion = Integer.parseInt(cadena);\n\n        System.out.print(\"\\nIntroduce el nuevo valor de la posici\u00f3n \" + posicion + \": \");\n        n = sc.nextDouble();\n\n        valores[posicion] = n;\n\n        System.out.println(\"\\nPosici\u00f3n a modificar: \" + posicion);\n        System.out.println(\"Nuevo valor: \" + n);\n        System.out.println(\"Contenido del array modificado:\");\n        for (int i = 0; i &lt; valores.length; i++) {\n            System.out.printf(\"%.2f \", valores[i]);\n        }\n    }\n}\n</code></pre> </li> <li> <p>AC 804 (RA3 / CE3d CE3f CE3i / IC1 / 3p). El siguiente programa permite al lectura por entrada est\u00e1ndar de 2 n\u00fameros enteros y 2 decimales. Modif\u00edcalo para evitar que haya duplicidad en el c\u00f3digo.</p> <pre><code>import java.util.*;\n\npublic class Ejercicio4 {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int x, y;\n        double m, n;\n        boolean repetir;\n\n        do {\n            repetir = false;\n            try {\n                System.out.print(\"Introduce n\u00famero entero: \");\n                x = sc.nextInt();\n            } catch (InputMismatchException e) {\n                System.out.println(\"Valor no v\u00e1lido \" + e.toString());\n                sc.nextLine();\n                repetir = true;\n            }\n        } while (repetir);\n\n        do {\n            repetir = false;\n            try {\n                System.out.print(\"Introduce n\u00famero entero: \");\n                y = sc.nextInt();\n            } catch (InputMismatchException e) {\n                System.out.println(\"Valor no v\u00e1lido \" + e.toString());\n                sc.nextLine();\n                repetir = true;\n            }\n        } while (repetir);\n\n        do {\n            repetir = false;\n            try {\n                System.out.print(\"Introduce n\u00famero decimal: \");\n                m = sc.nextDouble();\n            } catch (InputMismatchException e) {\n                System.out.println(\"Valor no v\u00e1lido \" + e.toString());\n                sc.nextLine();\n                repetir = true;\n            }\n        } while (repetir);\n\n        do {\n            repetir = false;\n            try {\n                System.out.print(\"Introduce n\u00famero decimal: \");\n                n = sc.nextDouble();\n            } catch (InputMismatchException e) {\n                System.out.println(\"Valor no v\u00e1lido \" + e.toString());\n                sc.nextLine();\n                repetir = true;\n            }\n        } while (repetir);\n\n        System.out.println(\"int introducido -&gt; \" + x);\n        System.out.println(\"int introducido -&gt; \" + y);\n        System.out.println(\"double introducido -&gt; \" + m);\n        System.out.println(\"double introducido -&gt; \" + n);\n    }\n}\n</code></pre> </li> <li> <p>AC 805 (RA3 / CE3d CE3f CE3i / IC1 / 3p). El siguiente programa simplemente asigna un archivo .jpg a un objeto imagen de la clase <code>BufferedImage</code>.</p> <ul> <li>a. Indica qu\u00e9 sucede al compilarlo. Explicaci\u00f3n.</li> <li>b. Modifica el c\u00f3digo para solucionar esa situaci\u00f3n con una excepci\u00f3n gen\u00e9rica.</li> <li>c. Realiza una nueva modificaci\u00f3n para que el programa capture exactamente la excepci\u00f3n lanzada</li> </ul> <pre><code>import java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.File;\n\npublic class Ejerc3 {\n    public static void main(String[] args) {\n        // Asignaci\u00f3n de un archivo .jpg al objeto imagen\n        BufferedImage imagen = ImageIO.read(new File(\"src/lugar/casa.jpg\"));\n    }\n}\n</code></pre> </li> <li> <p>AC 806 (RA3 / CE3d CE3f CE3i / IC1 / 3p). Compila la clase Cable siguiente y comprueba el error que te aparece:</p> <pre><code>package cable;\n\npublic class Cable {\n    public static void main(String[] args) {\n        Cable c1 = new Cable();\n        c1.conectar();\n    }\n\n    void conectar() {\n        Cable c2 = null; \n        c2.mostrar();\n    }\n\n    void mostrar() {\n        System.out.println(\"Conexi\u00f3n establecida\");\n    }\n}\n</code></pre> <ul> <li>a. Indica cu\u00e1l es el significado del error de ese mensaje de error.</li> <li>b. Corrige el c\u00f3digo para que funcione correctamente.</li> </ul> </li> </ul>"},{"location":"uutt/ut08/084_ExcepcionesComprobadasYNo.html","title":"Excepciones comprobadas y no comprobadas","text":"<p>Hay dos tipos de excepciones:</p> <ul> <li>Excepciones comprobadas o capturadas (checked) son aquellas que estamos obligados a tratar. Son todas las clases derivadas de la clase <code>Exception</code> excepto las derivadas de <code>RuntimeException</code>. No son culpa del programador de Java. Por ejemplo, un programa que debe acceder a una imagen en una carpeta. Si esa imagen no se encuentra en la ubicaci\u00f3n esperada porque alguien la ha movido, borrado o cambiado el nombre, dar\u00e1 error, no siendo responsabilidad del programador.</li> <li>Excepciones no comprobadas o no capturadas (unchecked) son aquellas que no estamos obligados a tratar. Pertenecen a la clase <code>Error</code> y a sus clases derivadas, y a la clase <code>RuntimeException</code> y sus derivadas. Son responsabilidad del programador. Est\u00e1 en nuestra mano solventarlas mejorando el c\u00f3digo. Por ejemplo, ser\u00edan excepciones no comprobadas: recorrer un array con m\u00e1s posiciones de las declaradas, o intentar almacenar en una variable de tipo String un dato de tipo entero, etc.</li> </ul> <p>El compilador Java obliga a declarar o capturar las excepciones comprobadas. El compilador muestra un mensaje de error si no se tratan o no se declara que son lanzadas de forma expl\u00edcita.</p>"},{"location":"uutt/ut08/084_ExcepcionesComprobadasYNo.html#declarar-excepciones","title":"Declarar excepciones","text":"<p>La declaraci\u00f3n de las excepciones que puede lanzar un m\u00e9todo se realiza escribiendo la palabra <code>throws</code> seguida del nombre de las excepciones separadas por comas. Por ejemplo, la instrucci\u00f3n <code>System.in.read()</code> para leer un car\u00e1cter lanza una excepci\u00f3n de tipo <code>IOException</code> que debemos capturar o declarar.</p> <pre><code>/*En este ejemplo no se captura la excepci\u00f3n por lo que \nestamos obligados a declararla*/\n\npublic static void main(String[] args) throws IOException{\n    char car;\n    System.out.println(\"Introduce un car\u00e1cter\");\n    car = (char)System.in.read();\n}\n</code></pre> <p>La declaraci\u00f3n de excepciones permite escribir m\u00e9todos que no capturan las excepciones marcadas que se puedan producir. Una excepci\u00f3n no capturada se lanza para que la trate alg\u00fan m\u00e9todo de la pila de llamadas.</p>"},{"location":"uutt/ut08/084_ExcepcionesComprobadasYNo.html#lanzar-excepciones","title":"Lanzar excepciones","text":"<p>Java permite al programador lanzar excepciones mediante la palabra reservada <code>throw</code>:</p> <pre><code>throw objetoExcepcion;\n</code></pre> <p>La excepci\u00f3n que se lanza es un objeto, por lo que hay que crearlo como cualquier otro objeto mediante <code>new</code>.</p> <p><pre><code>if (n==0) throw new ArithmeticException(\u201cDivisi\u00f3n por cero\u201d);\n</code></pre> Si se usa en un m\u00e9todo la cl\u00e1usula <code>throw</code> para lanzar un tipo de excepci\u00f3n comprobada o marcada, debe indicarse en su declaraci\u00f3n con la cl\u00e1usula <code>throws</code>.</p>"},{"location":"uutt/ut08/084_ExcepcionesComprobadasYNo.html#relanzar-excepciones","title":"Relanzar excepciones","text":"<p>Si se ha capturado una excepci\u00f3n es posible relanzar desde el bloque <code>catch</code> la excepci\u00f3n (el mismo objeto recibido en el bloque catch) utilizando la instrucci\u00f3n <code>throw objetoExcepcion</code>.</p>"},{"location":"uutt/ut08/084_ExcepcionesComprobadasYNo.html#crear-nuestras-propias-excepciones","title":"Crear nuestras propias excepciones","text":"<p>Aunque Java proporciona una gran cantidad de excepciones, en algunas ocasiones necesitaremos crear excepciones propias. Las excepciones propias deben ser subclases de la clase <code>Exception</code>. Normalmente crearemos excepciones propias cuando queramos manejar excepciones no contempladas por la librer\u00eda est\u00e1ndar de Java. </p> <p>Por ejemplo, vamos a crear un tipo de excepci\u00f3n llamada <code>ValorNoV\u00e1lido</code> que se lanzar\u00e1 cuando el valor utilizado en una determinada operaci\u00f3n no sea correcto.</p> Clase de la excepci\u00f3nClase Main <pre><code>public class ValorNoValido extends Exception{\n    public ValorNoValido(){ }\n    public ValorNoValido(String cadena) {\n        super(cadena); //Llama al constructor de Exception y le pasa\n        // el contenido de cadena\n    }\n}\n</code></pre> <pre><code>public static void main(String[] args) {\n    try {\n        double x = leerValor();\n        System.out.println(\"Ra\u00edz cuadrada de \" + x + \" = \" + Math.sqrt(x));\n    } catch (ValorNoValido e) {\n        System.out.println(e.getMessage());\n    }\n}\npublic static double leerValor() throws ValorNoValido {\n    Scanner sc = new Scanner(System.in);\n    System.out.print(\"Introduce n\u00famero &gt; 0 \");\n    double n = sc.nextDouble();\n    if (n &lt;= 0) {\n        throw new ValorNoValido(\"El n\u00famero debe ser positivo\");\n    }\n    return n;\n}\n</code></pre>"},{"location":"uutt/ut08/084_ExcepcionesComprobadasYNo.html#actividad","title":"Actividad","text":"<ul> <li>AC 807 (RA3 / CE3g CE3h / IC1 / 3p). Escribe una excepci\u00f3n personalizada SetOverflow que se lanza en el m\u00e9todo de inserci\u00f3n cuando el array est\u00e1 lleno. Escribe un bloque try/catch en el c\u00f3digo de prueba para probar la excepci\u00f3n.</li> </ul>"},{"location":"uutt/ut08/085_MetodosGenericos.html","title":"M\u00e9todos gen\u00e9ricos","text":"<p>Antes de Java 5 cuando introduc\u00edamos objetos en una colecci\u00f3n estos se guardaban como objetos de tipo <code>Object</code>, aprovechando el polimorfismo para poder introducir cualquier tipo de objeto en la colecci\u00f3n. Esto nos obligaba a hacer un casting al tipo original al obtener los elementos de la colecci\u00f3n.</p> <p>Esta forma de trabajar no solo nos ocasiona tener que escribir m\u00e1s c\u00f3digo innecesariamente, sino que es propenso a errores porque carecemos de un sistema de comprobaci\u00f3n de tipos. Si introdujeramos un objeto de tipo incorrecto el programa compilar\u00eda pero lanzar\u00eda una excepci\u00f3n en tiempo de ejecuci\u00f3n al intentar convertir el objeto en String:</p> <pre><code>public class Ejemplo {\n    public static void main(String[] args) {\n        List lista = new ArrayList();\n        lista.add(22);\n        String cadena = (String) lista.get(0);\n        System.out.println(cadena);\n    }\n}\n</code></pre> <p>Desde Java 5 contamos con una caracter\u00edstica llamada <code>generics</code> que puede solventar esta clase de problemas. Los <code>generics</code> son una mejora al sistema de tipos que nos permite programar abstray\u00e9ndonos de los tipos de datos.</p> <p>Gen\u00e9ricos significa tipos parametrizados. La idea es permitir que el tipo (<code>Integer</code>, <code>String</code>, etc., y tipos definidos por el usuario) sea un par\u00e1metro para m\u00e9todos, clases e interfaces. Utilizando <code>Generics</code>, es posible crear clases que trabajen con diferentes tipos de datos. Una entidad como clase, interfaz o m\u00e9todo que opera en un tipo parametrizado es una entidad gen\u00e9rica.</p> <p>Gracias a los <code>generics</code> podemos especificar el tipo de objeto que introduciremos en la colecci\u00f3n, de forma que el compilador conozca el tipo de objeto que vamos a utilizar, evit\u00e1ndonos as\u00ed el casting. Adem\u00e1s, gracias a esta informaci\u00f3n, el compilador podr\u00e1 comprobar el tipo de los objetos que introducimos, y lanzar un error en tiempo de compilaci\u00f3n si se intenta introducir un objeto de un tipo incompatible, en lugar de que se produzca una excepci\u00f3n en tiempo de ejecuci\u00f3n.</p> <p>Para utilizar generics con nuestras colecciones tan solo tenemos que indicar el tipo entre el operador <code>Diamond &lt;&gt;</code> a la hora de crearla. A estas clases a las que podemos pasar un tipo como par\u00e1metro se les llama clases parametrizadas, clases gen\u00e9ricas o simplemente gen\u00e9ricas (<code>generics</code>).</p> <pre><code>public class Ejemplo {\n    public static void main(String[] args) {\n        List&lt;String&gt; lista = new ArrayList&lt;String&gt;();\n        lista.add(\"Hola mundo\");\n        String cadena = lista.get(0);\n        System.out.println(cadena);\n    }\n}\n</code></pre> <p>El c\u00f3digo anterior no compilar\u00eda, si intent\u00e1ramos insertar en la lista un n\u00famero <code>lista.add(14);</code>, nos dar\u00eda un error de compilaci\u00f3n de tipos.</p>"},{"location":"uutt/ut08/085_MetodosGenericos.html#clases-genericas","title":"Clases gen\u00e9ricas","text":"<p>Al crear una clase que utiliza o contiene alg\u00fan atributo gen\u00e9rico, me obliga a a\u00f1adir este tipo de gen\u00e9rico en la definici\u00f3n de clase. Por convenci\u00f3n se suele utilizar una sola letra may\u00fascula para el tipo gen\u00e9rico. Seg\u00fan las convenciones los nombres de los par\u00e1metros de tipo usados com\u00fanmente son los siguientes:</p> <ul> <li>E: elemento de una colecci\u00f3n.</li> <li>K: clave.</li> <li>N: n\u00famero.</li> <li>T: tipo.</li> <li>V: valor.</li> <li>S, U, V etc: para segundos, terceros y cuartos tipos.</li> </ul> <pre><code>/*En el momento de la instanciaci\u00f3n de un tipo gen\u00e9rico indicaremos el argumento\npara el tipo, en este caso Box contendr\u00e1 una referencia a un tipo Integer.*/\n\n//Las dos formas son v\u00e1lidas:\nBox&lt;Integer&gt; integerBox1 = new Box&lt;Integer&gt;();\nBox&lt;Integer&gt; integerBox2 = new Box&lt;&gt;();\n\nBox&lt;String&gt; textoBox = new Box&lt;&gt;();\n\n//Estamos creando objetos de la clase Box, tanto de tipo Integer como String\n</code></pre> <p>Limitando tipos</p> <p>A veces querremos limitar los tipos que pueden ser usados empleando lo que se denomina bounded type. Con <code>&lt;T extends Number&gt;</code> el tipo T debe extender la clase <code>Number</code>. Java permite m\u00faltiples l\u00edmites o bounded type: <code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code>. Box es una clase y B1 y B2 son interfaces. Primero siempre debe ir la clase y luego las interfaces. </p> <p>Recuerda que Java no permite la herencia m\u00faltiple, por tanto, s\u00f3lo se puede extender de una clase, pero puede implementar varias interfaces en la declaraci\u00f3n del <code>bounded type</code>.</p>"},{"location":"uutt/ut08/085_MetodosGenericos.html#metodos-genericos_1","title":"M\u00e9todos gen\u00e9ricos","text":"<p>Al igual que ocurre con las clases, si me creo un m\u00e9todo gen\u00e9rico, es decir, que recibe tipos de datos gen\u00e9ricos \u00fanicos que no est\u00e1n definidos en la clase, tengo que especificar en la signatura del m\u00e9todo esos gen\u00e9ricos:</p> <pre><code>public static &lt;T, R&gt; void executeFunction(List&lt;T&gt; lista, Function&lt;T,R&gt; function) {\n    for(T t: lista) {\n        System.out.println(function.apply(t));\n    }\n}\n</code></pre>"},{"location":"uutt/ut08/085_MetodosGenericos.html#actividad","title":"Actividad","text":"<ul> <li> <p>AC 808 (RA3 / CE3f CE3g CE3i / IC1 / 3p). Escribe una clase gen\u00e9rica Set con un par\u00e1metro de tipo T. La clase usa un array de 10 elementos de tipo T (inicialmente solo almacena todos los valores NULL).</p> <p>La clase gestiona las siguientes operaciones:</p> <ul> <li>a. boolean insert(T element) - inserta un elemento en el conjunto(set). Se inserta un elemento en el primer lugar vac\u00edo del array. Si el array est\u00e1 lleno; simplemente no hagas nada si no puede insertar un elemento, devuelve false. Puede haber duplicados.</li> <li>b. boolean delete (T element): elimina un elemento igual a element (utiliza el m\u00e9todo equals, no ==, para determinar la igualdad). Devuelve cierto si elimina el elemento.</li> <li>c. T find(T element): devuelve el primer elemento igual a element, seg\u00fan lo determinado por el m\u00e9todo equals.</li> <li>d. Prueba el c\u00f3digo en un m\u00e9todo main creando un Conjunto de cadenas (Set) y un Set. Utiliza las operaciones insert, find and delete. No hagas un cast en los elementos devueltos por find: los tipos gen\u00e9ricos no requieren casting. <li>e. \u00bfPuedes insertar una cadena en un conjunto de enteros? Explica lo que sucede cuando lo intentas.</li>"},{"location":"uutt/ut08/086_ExpresionesLambda.html","title":"Expresiones lambda","text":"<p>Las expresiones lambda es una caracter\u00edstica importante que fue a\u00f1adida en Java 8. Es muy \u00fatil, ayuda a iterar, filtrar y extraer datos de la colecci\u00f3n. Una expresi\u00f3n lambda es un bloque corto de c\u00f3digo que toma par\u00e1metros y devuelve un valor. Las expresiones lambda son similares a los m\u00e9todos, pero no necesitan un nombre y se pueden implementar directamente en el cuerpo de un m\u00e9todo. La expresiones lambda de Java son tratadas como una funci\u00f3n, por lo que el compilador no crea un archivo <code>.class</code>.</p> <p>La expresi\u00f3n lambda proporciona la implementaci\u00f3n de una interfaz funcional. Una interfaz funcional es aquella que tiene un solo m\u00e9todo abstracto. Las interfaces funcionales en Java incluyen la anotaci\u00f3n <code>@FunctionalInterface</code>.</p>"},{"location":"uutt/ut08/086_ExpresionesLambda.html#sintaxis","title":"Sintaxis","text":"<p>Dado que las expresiones lambda son efectivamente solo m\u00e9todos, las expresiones lambda pueden tomar par\u00e1metros como los m\u00e9todos. La expresi\u00f3n lambda de Java consta de tres componentes.</p> <ol> <li>Par\u00e1metros - lista de argumentos: una expresi\u00f3n lambda puede tener cero o cualquier n\u00famero de argumentos.</li> <li>Token de flecha: se utiliza para vincular la lista de argumentos y el cuerpo de la expresi\u00f3n.</li> <li>Cuerpo: Contiene expresiones y declaraciones para la expresi\u00f3n lambda.</li> </ol> <p>Las expresiones lambda se pueden almacenar en variables si el tipo de variable es una interfaz que tiene un solo m\u00e9todo. La expresi\u00f3n lambda debe tener la misma cantidad de par\u00e1metros y el mismo tipo de retorno que ese m\u00e9todo.</p> Cero par\u00e1metrosUn par\u00e1metroM\u00faltiples par\u00e1metros <pre><code>//() -&gt; {body}\ninterface Saludo{\n    public String say();\n}\npublic class Main {\n    public static void main(String[] args) {\n        Saludo s=()-&gt;{\n            return \"Hola\";\n        };\n        System.out.println(s.say());\n    }\n}\n</code></pre> <pre><code>//p1 -&gt; {body}\ninterface Saludo{\n    public String say(String nombre);\n}\npublic class Main {\n    public static void main(String[] args) {\n        //sin omitir par\u00e9ntesis\n        Saludo s = (nombre)-&gt;{\n            return \"Hola \" + nombre;\n        };\n        System.out.println(s.say(\"Gin\u00e9s\"));\n        // Omitiendo par\u00e9ntesis\n        Saludo s2 = nombre -&gt;{\n            return \"Hola, \" + nombre;\n        };\n        System.out.println(s2.say(\"Gin\u00e9s\"));\n    }\n}\n</code></pre> <pre><code>//(p1, p2) -&gt; {body}\ninterface Sumable{\n    int add(int a,int b);\n}\npublic class Main {\n    public static void main(String[] args) {\n        Sumable ad1=(a,b)-&gt;(a+b);\n        System.out.println(ad1.add(10,20));\n        // con tipo de datos\n        Sumable ad2=(int a,int b)-&gt;(a+b);\n        System.out.println(ad2.add(100,200));\n    }\n}\n</code></pre> <p>Tipo de datos</p> <p>En ocasiones, puede ser necesario especificar tipos de par\u00e1metros para una expresi\u00f3n lambda si el compilador no puede inferir los tipos de par\u00e1metros del m\u00e9todo de interfaz funcional con el que coincide la lambda. </p> <pre><code>(Coche coche) -&gt; System.out.println(\"El coche es: \" + coche.getName());\n</code></pre>"},{"location":"uutt/ut08/086_ExpresionesLambda.html#devolviendo-valores","title":"Devolviendo valores","text":"<p>En las expresiones lambda, si solo hay una sentencia, puede o no usar la palabra <code>return</code>. Pero si la expresi\u00f3n lambda tiene varias sentencias se debe poner la palabra <code>return</code>.</p> <pre><code>interface Sumable{\n    int add(int a,int b);\n}\npublic class Main {\n    public static void main(String[] args) {\n        // Lambda expression sin palabra clave return\n        Sumable ad1 = (a,b)-&gt;(a + b);\n        System.out.println(ad1.add(10,20));\n        // Lambda expression con la palabra clave return\n        Sumable ad2 = (a,b)-&gt;{\n            return (a + b);\n        };\n        System.out.println(ad2.add(100,200));\n    }\n}\n</code></pre> <p>El compilador sabe que la expresi\u00f3n <code>a + b</code> es el valor de retorno de la expresi\u00f3n lambda (de ah\u00ed el nombre de expresiones lambda, ya que las expresiones devuelven un valor de alg\u00fan tipo).</p>"},{"location":"uutt/ut08/086_ExpresionesLambda.html#con-y-sin-expresion-lambda","title":"Con y sin expresi\u00f3n lambda","text":"<p>A la hora de programar, no deja de ser una herramienta m\u00e1s. El uso o no de ellas depende, en gran medida, de la pericia y/o gustos del programador.</p> Sin expresi\u00f3n lambdaCon expresi\u00f3n lambda <pre><code>interface Saludo {\n    public void saludar();\n}\npublic class LambdaExpressionExample {\n    public static void main(String[] args) {\n        String nombre = \"Luffy\";\n        //sin expresiones lambda, Saludo se implementa usando clases an\u00f3nimas\n        Saludo s = new Saludo(){\n            public void saludar(){System.out.println(\"Hola \" + nombre);}\n        };\n        s.saludar();\n    }\n}\n</code></pre> <pre><code>@FunctionalInterface //Esto es opcional\ninterface Saludo {\n    public void saludar();\n}\npublic class LambdaExpressionExample2 {\n    public static void main(String[] args) {\n        String nombre = \"Luffy\";\n        //con expresiones lambda\n        Saludo s2 = ()-&gt; {\n            System.out.println(\"Hola \" + nombre);\n        };\n        s2.saludar();\n    }\n}\n</code></pre>"},{"location":"uutt/ut08/086_ExpresionesLambda.html#crear-una-expresion-lambda-a-partir-de-un-metodo","title":"Crear una expresi\u00f3n lambda a partir de un m\u00e9todo","text":"<p>Para definir una expresi\u00f3n lambda de un m\u00e9todo que no est\u00e1 definido en ninguna interfaz funcional, tenemos que utilizar la clase <code>Function</code>. A la clase <code>Function</code> se le especifican dos tipos de par\u00e1metros entre <code>&lt;&gt;</code>, el primero es el par\u00e1metro de entrada de la funci\u00f3n, y el segundo es el par\u00e1metro de salida que devuelve la funci\u00f3n o m\u00e9todo.</p> Programaci\u00f3nEjecuci\u00f3n <pre><code>Function&lt;String, Integer&gt; funcionLambda = (s) -&gt; {\n    int total = 0;\n    for (int i = 0; i &lt; texto.length(); i++) {\n        total+=texto.charAt(i);\n    }\n    return total;\n};\n</code></pre> <pre><code>System.out.println(funcionLambda.apply(\"Programaci\u00f3n\"));\n</code></pre>"},{"location":"uutt/ut08/086_ExpresionesLambda.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 809 (RA3 / CE3f CE3g CE3i / IC1 / 3p). Transforma la siguiente clase an\u00f3nima en una expresi\u00f3n lambda y crea c\u00f3digo de prueba para usarla.</p> <pre><code>Runnable runnable = new Runnable() {\n    @Override\n    public void run() {\n        String texto = \"Vamos a crear un array\";\n        String[] partes = texto.split(\" \");\n        for (String parte: partes) {\n            System.out.println(part);\n        }\n    }\n};\n</code></pre> </li> <li> <p>AP 810 (RA3 / CE3f CE3g CE3i / IC1 / 3p).Transforma el siguiente m\u00e9todo en una expresi\u00f3n lambda:</p> <pre><code>public static String caracteresPares(String texto) {\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 0; i &lt; texto.length(); i++) {\n        if (i % 2 == 0) {\n            sb.append(texto.charAt(i));\n        }\n    }\n    return sb.toString();\n}\n</code></pre> <p>Escribe c\u00f3digo para ejecutar la funci\u00f3n del ejercicio anterior si se le pasa el siguiente texto:\u201d1234567890\u201d.</p> </li> </ul>"},{"location":"uutt/ut08/087_ExpresionesRegulares.html","title":"Expresiones Regulares","text":"<p>Una expresi\u00f3n regular (regex) define un patr\u00f3n de b\u00fasqueda para cadenas. El patr\u00f3n de b\u00fasqueda puede ser cualquier cosa, desde un car\u00e1cter simple, una cadena fija o una expresi\u00f3n compleja que contenga caracteres especiales que describan el patr\u00f3n.</p> <p>Se puede usar una expresi\u00f3n regular para buscar, editar y manipular texto. La expresi\u00f3n regular se aplica en el texto de izquierda a derecha. Se usa ampliamente para definir la restricci\u00f3n en cadenas como contrase\u00f1a y validaci\u00f3n de correo electr\u00f3nico.</p> <p>Java Regex API proporciona 1 interfaz y 3 clases en el paquete <code>java.util.regex</code>:</p> <ul> <li>MatchResult interface</li> <li>Matcher class</li> <li>Pattern class</li> <li>PatternSyntaxException class</li> </ul>"},{"location":"uutt/ut08/087_ExpresionesRegulares.html#clases-de-caracteres-y-limites-de-coincidencia","title":"Clases de caracteres y l\u00edmites de coincidencia","text":"<p>La forma m\u00e1s simple de una expresi\u00f3n regular (regex) es una cadena, un literal, un String. Por ejemplo, \"Hola\" es una regex que coincide (matches) con la palabra \"Hola\". Si solo us\u00e1ramos literales como patr\u00f3n para buscar en un String, las regex no ser\u00edan muy interesantes. Por eso, se crearon las <code>Character classes</code> y <code>boundary matches</code>. Los <code>boundary matches</code> o l\u00edmites de coincidencia son: <code>^</code> (al principio del String), <code>$</code> (final del String), <code>\\b</code> (principio y final palabra). Una clase car\u00e1cter es como un comod\u00edn y representa un conjunto o clase de caracteres.</p> Regex Descripci\u00f3n . Coincide con cualquier car\u00e1cter. ^pattern El s\u00edmbolo ^ indica al inicio del String. Encuentra la regex que coincide con el patr\u00f3n dado al comienzo del String. pattern$ El s\u00edmbolo $ indica el final del String. Encuentra la regex que coincide con el patr\u00f3n dado al final del String. [abc] Los corchetes representan un conjunto. El String debe coincidir con la/s letra/s dentro del corchete. [abc][12] El String debe coincidir con las letras a, b \u00f3 c, seguidas de 1 \u00f3 2. [^abc] El s\u00edmbolo ^ dentro de los corchetes indica negaci\u00f3n. El String debe coincidir con cualquier car\u00e1cter excepto a \u00f3 b \u00f3 c. [a-z1-9] Rango. Busca coincidir las letras min\u00fasculas de la a a la z (ambas incluidas) y los d\u00edgitos del 1 al 9 (ambos incluidos). <code>a|b</code> Encuentra en el String las ocurrencias de a \u00f3 b. ab Encuentra en el String todas las ocurrencias de 'a' seguido de una 'b'."},{"location":"uutt/ut08/087_ExpresionesRegulares.html#meta-caracteres","title":"Meta caracteres","text":"<p>Los siguientes metacaracteres tienen un significado predefinido y hacen que ciertos patrones comunes sean m\u00e1s f\u00e1ciles de usar. Por ejemplo, puede usar <code>\\d</code> como definici\u00f3n simplificada para [0..9].</p> Regex Descripci\u00f3n \\d Cualquier d\u00edgito. Equivale a [0-9] \\D No d\u00edgito. Equivale a [^0-9] \\s Espacio en blanco. Equivale a [ \\t\\n\\x0b\\r\\f] \\S No espacio en blanco. Equivale a [^\\s] \\w Una letra may\u00fascula o min\u00fascula, un d\u00edgito o el car\u00e1cter _ . Equivale a [a-zA-Z0-9_] \\W Equivale a [^\\w] \\S+ Varios caracteres que no son espacios en blanco \\b L\u00edmite de una palabra"},{"location":"uutt/ut08/087_ExpresionesRegulares.html#cuantificadores-regex","title":"Cuantificadores Regex","text":"<p>Los cuantificadores especifican el n\u00famero de ocurrencias de un car\u00e1cter. Un cuantificador define con qu\u00e9 frecuencia puede ocurrir un elemento.</p> Regex Descripci\u00f3n * Indica que ocurre 0 \u00f3 m\u00e1s veces. Equivale a {0,}. + Indica que ocurre 1 \u00f3 m\u00e1s veces. Equivale a {1,}. ? Indica que ocurre 0 \u00f3 1 veces. Equivale a {0,1}. {X} Indica que lo que va justo antes de las llaves {} se repite X n\u00famero de veces. {X, Y} Indica que lo que va justo antes de las llaves {} se repite m\u00ednimo X n\u00famero de veces y m\u00e1ximo Y. *? ? despu\u00e9s de un cuantificador lo convierte en un cuantificador perezoso (lazy). Intenta encontrar la coincidencia m\u00e1s peque\u00f1a. Esto hace que la expresi\u00f3n regular se detenga en la primera coincidencia. <p>En la documentaci\u00f3n de Oracle podemos ver todas las clases de caracteres que hay para construir una expresi\u00f3n regular.</p> <p>\u00a1Entrena tus Regex!</p> <p>A lo largo de Internet hay muchas webs que te permiten entrenar o revisar tus expresiones regulares. Una de ellas es Regex Crossword, que a trav\u00e9s del juego, te permite profundizar en el mundo de las expresiones regulares.</p>"},{"location":"uutt/ut08/087_ExpresionesRegulares.html#ejemplo-de-uso-de-expresion-regular-telefono-movil","title":"Ejemplo de uso de expresi\u00f3n regular: tel\u00e9fono m\u00f3vil","text":"<pre><code>//(+34) 655-555-555\nString regexTelefono = \"^([\\\\(]{1}[\\\\+]{1}34[\\\\)]{1}[ ]{1}[0-9]{3}[\\\\-]{1}[0-9]{3}[\\\\-]{1}[0-9]{3})$\";\nString t1 = \"123456789\";//no\nString t2 = \"(+35) 123456-789\";//no\nString t3 = \"(+34) 123-456-789\";//si\nString t4 = \"(+34)123-456-789\";//no\nSystem.out.println(t1.matches(regexTelefono));//false\nSystem.out.println(t2.matches(regexTelefono));//false\nSystem.out.println(t3.matches(regexTelefono));//true\nSystem.out.println(t4.matches(regexTelefono));//false\n</code></pre>"},{"location":"uutt/ut08/087_ExpresionesRegulares.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 811 (RA3 / CE3f CE3g CE3i / IC1 / 3p). Escribe una expresi\u00f3n regular que haga match tanto con el texto \"He ido al cine.\", como con \"He ido al supermercado.\". Verifica tu repuesta con el m\u00e9todo de la clase <code>String</code> <code>matches</code>. Una vez hecho usa el m\u00e9todo de la clase <code>Matcher</code> <code>matches</code> para verificar las coincidencias (<code>match</code>) en vez de <code>String.matches</code>.</p> </li> <li> <p>AC 812 (RA3 / CE3f CE3g CE3i / IC1 / 3p). Reemplaza todos los espacios en blanco con una barra baja (_) en la siguiente cadena. Imprime el resultado. \"Ciclo Formativo de Grado Superior de Desarrollo de Aplicaciones Web.\"</p> </li> <li> <p>AC 813 (RA3 / CE3f CE3g CE3i / IC1 / 3p). Escribe una expresi\u00f3n regular que coincida con el c\u00f3digo postal en Espa\u00f1a, utiliza \"03207\" como ejemplo.</p> </li> <li> <p>AC 814 (RA3 / CE3f CE3g CE3i / IC1 / 3p). Escribe una expresi\u00f3n regular para validar el n\u00famero de una tarjeta de cr\u00e9dito.</p> </li> <li> <p>AC 815 (RA3 / CE3f CE3g CE3i / IC1 / 3p). Escribe una expresi\u00f3n regular para validar emails. Verifica \"test2@gmail.com\".</p> </li> <li> <p>AC 816 (RA3 / CE3f CE3g CE3i / IC1 / 3p). Escribe una expresi\u00f3n regular para validar DNI. Verifica \"61234181Q\".</p> </li> </ul>"},{"location":"uutt/ut08/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 08","text":""},{"location":"uutt/ut08/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA3.CE <ul> <li>Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje.</li> </ul> <ul> <li>d. Se ha escrito c\u00f3digo utilizando control de excepciones.</li> <li>f. Se han probado y depurado los programas.</li> <li>g. Se ha comentado y documentado el c\u00f3digo.</li> <li>h. Se han creado excepciones.</li> <li>i. Se han utilizado aserciones para la detecci\u00f3n y correcci\u00f3n de errores durante la fase de desarrollo.</li> </ul>"},{"location":"uutt/ut08/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li>Cu\u00e1ndo y c\u00f3mo se provoca una excepci\u00f3n</li> <li>Qu\u00e9 ocurre cuando se produce una excepci\u00f3n</li> <li>Jerarqu\u00eda de excepciones<ol> <li>M\u00e9todos de la clase <code>Throwable</code></li> </ol> </li> <li>Tratamiento de excepciones<ol> <li>Bloques <code>try</code> \u2013 <code>catch</code> \u2013 <code>finally</code></li> </ol> </li> <li>Captura de excepciones</li> <li>Excepciones comprobadas y no comprobadas<ol> <li>Declarar excepciones</li> <li>Lanzar excepciones</li> <li>Relanzar excepciones</li> <li>Crear nuestras propias excepciones </li> </ol> </li> <li>Gen\u00e9ricos<ol> <li>Clases gen\u00e9ricas</li> <li>M\u00e9todos gen\u00e9ricos</li> </ol> </li> <li>Expresiones lambda<ol> <li>Sintaxis</li> <li>Crear una expresi\u00f3n lambda a partir de un m\u00e9todo</li> </ol> </li> <li>Expresiones Regulares</li> </ol>"},{"location":"uutt/ut08/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>04/02/2025</p> <p>Introducci\u00f3n</p> <p></p> <p>02</p> <p>05/02/2025</p> <p>Jerarqu\u00eda de Excepciones</p> <p>AC 801</p> <p>03</p> <p>05/02/2025</p> <p>Tratamiento de excepciones: <code>try</code><code>catch</code><code>finally</code></p> <p>AC 802</p> <p>04</p> <p>06/02/2025</p> <p></p> <p>AC 803</p> <p>05</p> <p>06/02/2025</p> <p></p> <p>AC 804</p> <p>06</p> <p>07/02/2025</p> <p></p> <p>Trabajo en clase</p> <p>07</p> <p>10/02/2025</p> <p></p> <p>AC 805AC 806</p> <p>08</p> <p>10/02/2025</p> <p>Excepciones comprobadas y no comprobadas</p> <p>AC 807</p> <p>09</p> <p>11/02/2025</p> <p>M\u00e9todos gen\u00e9ricos</p> <p>AC 808</p> <p>10</p> <p>11/02/2025</p> <p></p> <p>Trabajo en clase</p> <p>11</p> <p>12/02/2025</p> <p>Expresiones lambda</p> <p>AC 809</p> <p>12</p> <p>12/02/2025</p> <p></p> <p>Trabajo en clase</p> <p>13</p> <p>13/02/2025</p> <p>Expresiones regulares</p> <p>AC 811</p> <p>14</p> <p>13/02/2025</p> <p></p> <p>AC 812AC 813</p> <p>15</p> <p>14/02/2025</p> <p></p> <p>AC 814AC 815</p> <p>16</p> <p>17/02/2025</p> <p></p> <p>AC 816</p>"},{"location":"uutt/ut08/ResumenUT.html#referencias","title":"Referencias","text":""},{"location":"uutt/ut08/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":""},{"location":"uutt/ut09/091_Introduccion.html","title":"Introducci\u00f3n","text":"<p>Hasta ahora la \u00fanica forma de gestionar grupos de objetos o datos eran los arrays. Si bien son sencillos de usar, poseen una serie de inconvenientes que no los hacen pr\u00e1cticos en la mayor\u00eda de las aplicaciones, siendo estos:</p> <ul> <li>No se adapta al tama\u00f1o del problema. Se ha de conocer el tama\u00f1o al crear el array, implica que o se pierde algo de espacio o es posible que se quede peque\u00f1o\u2026</li> <li>B\u00fasquedas complejas. La b\u00fasqueda de un elemento en un vector desordenado es costosa computacionalmente.</li> <li>Posibles problemas de memoria. En caso de gran cantidad de objetos a gestionar se ha de reservar memoria contigua, y en ocasiones esto no es sencillo.</li> <li>Manejo complejo. La inserci\u00f3n, borrado y obtenci\u00f3n de elementos es compleja.</li> </ul> <p>Para solucionar estos problemas se han definido las estructuras de datos din\u00e1micas, tambi\u00e9n conocidas como tipos de datos abstractos o TAD. En Java gran parte de estas estructuras de datos din\u00e1micas se agrupan en lo que se conoce como Colecciones (<code>Collections</code>).</p>"},{"location":"uutt/ut09/092_WrappersJava.html","title":"Wrappers en Java","text":"<p>Para todos los tipos de datos primitivos, existen unas clases llamadas <code>Wrapper</code>, tambi\u00e9n conocidas como envoltorio, ya que proveen una serie de mecanismos que nos permiten envolver a un tipo de dato primitivo permiti\u00e9ndonos con ello el tratarlos como si fueran objetos.</p> Tipos primitivos Wrappers byte Byte short Short int Integer long Long boolean Boolean float Float double Double char Character <p>Todos los Wrappers a su vez dependen de <code>Java.lang.Object</code> ya que, como hemos dicho, los <code>Wrappers</code> no dejan de ser objetos y por tanto descienden de la clase <code>Object</code>. Podemos apreciar todo esto de una forma m\u00e1s sencilla a partir del siguiente esquema:</p> <p>Las clases envoltorio en Java, como <code>Integer</code>, <code>Double</code>, <code>Boolean</code>, <code>Character</code>, <code>Byte</code>, <code>Long</code> y <code>Float</code>, proporcionan una serie de m\u00e9todos para manejar los valores primitivos correspondientes. Lo ideal es consultar estos m\u00e9todos en la documentaci\u00f3n oficial, donde adem\u00e1s podremos ver cuales son los que podemos usar en nuestra versi\u00f3n de Java. A continuaci\u00f3n, vamos a ver una serie de ejemplos del uso de <code>Wrappers</code>:</p> Uso de IntegerUso de DoubleUso de BooleanUso de Character <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase Integer a partir de un valor primitivo int\n        int num = 10;\n        Integer numWrapper = Integer.valueOf(num);\n        // Conversi\u00f3n de un objeto de la clase Integer a un valor primitivo int\n        int numPrimitivo = numWrapper.intValue();\n        // Imprimir los valores\n        System.out.println(\"num: \" + num);\n        System.out.println(\"numWrapper: \" + numWrapper);\n        System.out.println(\"numPrimitivo: \" + numPrimitivo);\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase Double a partir de un valor primitivo double\n        double num = 10.5;\n        Double numWrapper = Double.valueOf(num);\n        // Conversi\u00f3n de un objeto de la clase Double a un valor primitivo double\n        double numPrimitivo = numWrapper.doubleValue();\n        // Imprimir los valores\n        System.out.println(\"num: \" + num);\n        System.out.println(\"numWrapper: \" + numWrapper);\n        System.out.println(\"numPrimitivo: \" + numPrimitivo);\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase Boolean a partir de un valor primitivo boolean\n        boolean flag = true;\n        Boolean flagWrapper = Boolean.valueOf(flag);\n        // Conversi\u00f3n de un objeto de la clase Boolean a un valor primitivo boolean\n        boolean flagPrimitivo = flagWrapper.booleanValue();\n        // Imprimir los valores\n        System.out.println(\"flag: \" + flag);\n        System.out.println(\"flagWrapper: \" + flagWrapper);\n        System.out.println(\"flagPrimitivo: \" + flagPrimitivo);\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase Character a partir de un valor primitivo char\n        char letra = 'A';\n        Character letraWrapper = Character.valueOf(letra);\n        // Conversi\u00f3n de un objeto de la clase Character a un valor primitivo char\n        char letraPrimitivo = letraWrapper.charValue();\n        // Imprimir los valores\n        System.out.println(\"letra: \" + letra);\n        System.out.println(\"letraWrapper: \" + letraWrapper);\n        System.out.println(\"letraPrimitivo: \" + letraPrimitivo);\n    }\n}\n</code></pre>"},{"location":"uutt/ut09/093_ListasEnlazadas.html","title":"Listas enlazadas y listas circulares","text":"<p>Una lista es una colecci\u00f3n, originalmente vac\u00eda, de elementos u objetos de cualquier tipo no necesariamente consecutivos en memoria, que durante la ejecuci\u00f3n del programa pueden crecer o decrecer elemento a elemento seg\u00fan las necesidades previstas en el mismo.</p> <p>Una lista est\u00e1 formada por un n\u00famero variable de datos (elementos) de un mismo tipo, ordenados seg\u00fan una secuencia lineal. Cada elemento, salvo el primero, tiene un predecesor en la lista. Todos los elementos, salvo el \u00faltimo, tienen un sucesor.</p>"},{"location":"uutt/ut09/093_ListasEnlazadas.html#listas-enlazadas","title":"Listas enlazadas","text":"<p>Piensa</p> <p>Si los elementos no est\u00e1n consecutivos en memoria \u00bfc\u00f3mo pasamos desde un elemento al siguiente cuando recorremos la lista? La respuesta es que cada elemento debe almacenar informaci\u00f3n de d\u00f3nde est\u00e1 el siguiente elemento o el anterior, o bien ambos.</p> <p>Podemos definir una lista como una estructura de datos formada por registros de, al menos, dos campos, en que uno de ellos contiene informaci\u00f3n que permite localizar al siguiente registro en la lista seg\u00fan una secuencia dada.</p> <p>En funci\u00f3n de la informaci\u00f3n que cada elemento de la lista almacene respecto a la localizaci\u00f3n de sus antecesores y/o predecesores, las listas pueden clasificarse en: listas lineales simplemente enlazadas, listas lineales doblemente enlazadas, listas circulares simplemente enlazadas, y listas circulares doblemente enlazadas.</p>"},{"location":"uutt/ut09/093_ListasEnlazadas.html#listas-lineales-simplemente-enlazadas","title":"Listas lineales simplemente enlazadas","text":"<p>Una lista lineal simplemente enlazada es una colecci\u00f3n de objetos (elementos de la lista), cada uno de los cuales contiene datos o una referencia a los datos, y una referencia al siguiente objeto en la colecci\u00f3n (elemento de la lista).</p> <p></p> <pre><code>class Persona {\n    //atributos\n    String apellido;\n    Persona siguiente; //referencia al siguiente elemento\n    public Persona(){ // constructor por defecto\n    }\n}\n</code></pre>"},{"location":"uutt/ut09/093_ListasEnlazadas.html#listas-lineales-doblemente-enlazadas","title":"Listas lineales doblemente enlazadas","text":"<p>En algunas aplicaciones puede ser deseable recorrer eficientemente una lista, tanto hacia adelante como hacia atr\u00e1s. O, dado un elemento, podr\u00eda desearse determinar con rapidez el siguiente y el anterior. En tales situaciones, quiz\u00e1 se quisiera poner en cada nodo de una lista un puntero al siguiente nodo y otro al anterior.</p> <p></p> <pre><code>class Persona {\n    //atributos\n    String apellido;\n    Persona siguiente; //referencia al siguiente elemento\n    Persona anterior; //referencia al anterior elemento\n    public Persona(){ // constructor por defecto\n    }\n}\n</code></pre>"},{"location":"uutt/ut09/093_ListasEnlazadas.html#listas-circulares","title":"Listas circulares","text":"<p>Una lista circular enlazada es una lista en la que el \u00faltimo elemento apunta al primero en lugar de apuntar al vac\u00edo o <code>NULL</code>.</p>"},{"location":"uutt/ut09/093_ListasEnlazadas.html#listas-circulares-simplemente-enlazadas","title":"Listas circulares simplemente enlazadas","text":"<p>En este tipo de listas es posible acceder a cualquier elemento de la lista desde cualquier punto dado desplaz\u00e1ndonos en un \u00fanico sentido. Una representaci\u00f3n gr\u00e1fica ser\u00eda la siguiente</p> <pre><code>class ListaCircular {\n    private Persona cabeza; // Referencia al primer nodo\n    private Persona cola;   // Referencia al \u00faltimo nodo\n\n    // Constructor por defecto\n    public ListaCircular() {\n        this.cabeza = null;\n        this.cola = null;\n    }\n\n    // M\u00e9todo para agregar un nodo al final de la lista\n    public void agregar(String apellido) {}\n\n    // M\u00e9todo para recorrer e imprimir la lista\n    public void mostrar() {}\n}\n</code></pre>"},{"location":"uutt/ut09/093_ListasEnlazadas.html#listas-circulares-doblemente-enlazadas","title":"Listas circulares doblemente enlazadas","text":"<p>Una lista circular doblemente enlazada es una combinaci\u00f3n de las listas circulares y de las listas doblemente enlazadas. Su principal ventaja es que se permite el desplazamiento en cualquier sentido a trav\u00e9s de la misma.</p> <pre><code>class ListaCircularDoble {\n    private Persona cabeza; // Referencia al primer nodo\n    private Persona cola;   // Referencia al \u00faltimo nodo\n\n    // Constructor por defecto\n    public ListaCircularDoble() {\n        this.cabeza = null;\n        this.cola = null;\n    }\n\n    // M\u00e9todo para agregar un nodo al final de la lista\n    public void agregar(String apellido) {}\n\n    // M\u00e9todo para recorrer e imprimir la lista hacia adelante\n    public void mostrarAdelante() {}\n\n    // M\u00e9todo para recorrer e imprimir la lista hacia atr\u00e1s\n    public void mostrarAtras() {}\n}\n</code></pre>"},{"location":"uutt/ut09/094_ArrayList.html","title":"ArrayList","text":"<p>La clase <code>ArrayList</code> pertenece a la biblioteca de Java, est\u00e1 incluida en el paquete <code>java.util</code>. Esta clase permite trabajar con arrays redimensionables cuyo n\u00famero de elementos puede crecer o decrecer en tiempo de ejecuci\u00f3n seg\u00fan las necesidades del programa. <code>ArrayList</code> contiene internamente una matriz de valores y una variable de contador para conocer el tama\u00f1o actual en cualquier punto. Si se agrega un elemento, se aumenta el tama\u00f1o, y si se elimina, se reduce.</p> <p>De forma general un ArrayList en Java se puede crear de cualquiera de las siguientes formas:</p> <pre><code>List nombreArrayList = new ArrayList();\nArrayList nombreArrayList = new ArrayList();\n</code></pre> <p>Esta instrucci\u00f3n crea el <code>ArrayList</code> nombreArrayList vac\u00edo. Un <code>ArrayList</code> declarado as\u00ed puede contener objetos de cualquier tipo. Por ejemplo:</p> <pre><code>ArrayList a = new ArrayList();\na.add(\"Lenguaje\");\na.add(3);\na.add('a');\na.add(23.5);\n</code></pre> <p>Los elementos del ArrayList a son: <code>\u201cLenguaje\u201d, 3, \u2018a\u2019, 23.5</code>. Es decir, un ArrayList puede contener objetos de tipos distintos. En este ejemplo, el primer objeto que se a\u00f1ade es el String \u201cLenguaje\u201d. El resto no son objetos. Son datos de tipos primitivos pero el compilador los convierte autom\u00e1ticamente en objetos de su clase envolvente (clase contenedora o <code>Wrapper</code>) antes de a\u00f1adirlos al <code>ArrayList</code>.</p> <p>Un array al que se le pueden asignar elementos de distinto tipo puede tener alguna complicaci\u00f3n a la hora de trabajar con \u00e9l. Por eso, una alternativa a esta declaraci\u00f3n es indicar el tipo de objetos que contiene. En este caso, el array redimensionable solo podr\u00e1 contener objetos de ese tipo. De forma general:</p> <pre><code>List&lt;tipo&gt; nombreArrayList = new ArrayList();\nArrayList&lt;tipo&gt; nombreArrayList = new ArrayList();\nArrayList &lt;tipo&gt; nombreArrayList = new ArrayList&lt;&gt;();\n</code></pre> <p>A esta forma de definir una clase class <code>ArrayList&lt;tipo&gt;</code> se le conoce como definici\u00f3n con tipo parametrizado o gen\u00e9rico. Donde, tipo presenta cualquier tipo de clase de objetos en Java. Los tipos gen\u00e9ricos no se limitan solamente a colecciones, tambi\u00e9n podemos definir clases o tipos gen\u00e9ricos propios. tipo debe ser una clase. Indica el tipo de objetos que contendr\u00e1 el array y no se pueden usar tipos primitivos. Para un tipo primitivo se debe utilizar su clase envolvente. Por ejemplo:</p> <pre><code>ArrayList &lt;Integer&gt; numeros = new ArrayList&lt;&gt;();\n//Crea el array redimensionable llamado n\u00fameros compuesto por enteros.\n</code></pre> <p>Hay una gran cantidad de m\u00e9todos que proporciona <code>ArrayList</code> implementados de la interface <code>List</code>, es recomendable acudir a la documentaci\u00f3n oficial</p> <p>Recorriendo ArrayList</p> <p>Podemos recorrerlo de forma cl\u00e1sica con un bucle for: <pre><code>for (int i = 0; i &lt; array.size(); i++){\n    System.out.println(array.get(i));\n}\n</code></pre> Con un bucle foreach, si suponemos el array de enteros llamado n\u00fameros: <pre><code>for (Integer i: numeros){\n    System.out.println(i);\n}\n</code></pre> Si el array contiene objetos de tipos distintos o desconocemos el tipo: <pre><code>for (Object o: nombreArray){\n    System.out.println(o);\n}\n</code></pre></p> Ejemplo 1Ejemplo 2 <pre><code>//Eliminar elementos del ArrayList con valor menor de 10. (No se puede realizar con foreach).\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class AL1 { \n    public static void main(String[] args) {\n        List&lt;Integer&gt; numeros = new ArrayList&lt;&gt;();\n        numeros.add(12);\n        numeros.add(8);\n        numeros.add(2);\n        numeros.add(23);\n        for (int i = 0; i &lt; numeros.size(); i++){\n            if (numeros.get(i) &lt; 10) {\n                numeros.remove(i);\n                /* Al borrar un elemento del ArrayList se desplazan el resto\n                de elementos una posici\u00f3n a la izquierda. */\n                i--; }\n        }\n        System.out.println(numeros);\n    }\n}\n</code></pre> <pre><code>//Uso de los m\u00e9todos add, remove, set, get.\nimport java.util.ArrayList;\n\npublic class AL2 {\n    public static void main(String[] args) {\n        ArrayList&lt;String&gt; nombres = new ArrayList&lt;&gt;();\n        nombres.add(\"Ana\");\n        nombres.add(\"Luisa\");\n        nombres.add(\"Felipe\");\n        System.out.println(nombres); // [Ana, Luisa, Felipe]\n        nombres.add(1, \"Pablo\");\n        System.out.println(nombres); // [Ana, Pablo, Luisa, Felipe]\n        nombres.remove(0);\n        System.out.println(nombres); // [Pablo, Luisa, Felipe]\n        nombres.set(0,\"Alfonso\");\n        System.out.println(nombres); // [Alfonso, Luisa, Felipe]\n        String s = nombres.get(1);\n        String ultimo = nombres.get(nombres.size() - 1);\n        System.out.println(s + \" \" + ultimo); // Luisa Felipe\n    }\n}\n</code></pre> <p>Copia de ArrayList</p> <p>El nombre de un ArrayList contiene la referencia al ArrayList, es decir, la direcci\u00f3n de memoria donde el ArrayList se encuentra, igual que sucede con los arrays est\u00e1ticos. Si disponemos de un ArrayList de enteros llamado ventas: <pre><code>ArrayList&lt;Integer&gt; ventas1 = ventas;\n</code></pre></p> <p>No copia el ArrayList ventas en el nuevo ArrayList <code>ventas1</code> sino que crea un alias. De esta forma tenemos dos maneras de acceder al mismo ArrayList, mediante la referencia ventas y mediante la referencia ventas1. </p> <p>La copia del ArrayList se puede realizar de forma manual elemento a elemento o se puede pasar la referencia del ArrayList original al constructor del nuevo:</p> <p><pre><code>ArrayList&lt;Integer&gt; ventas1 = new ArrayList&lt;&gt;(ventas);\n</code></pre> Es decir, ArrayList como par\u00e1metro de un m\u00e9todo, haciendo uso del constructor copia.</p>"},{"location":"uutt/ut09/094_ArrayList.html#linkedlist","title":"LinkedList","text":"<p>La clase <code>LinkedList</code> pertenece tambi\u00e9n a la biblioteca de Java se encuentra en el paquete <code>java.util</code>. Esta clase maneja listas doblemente enlazadas y es apropiado para el dise\u00f1o de colas y pilas.</p> <p>De forma general un ArrayList en Java se puede crear de la siguiente forma:</p> <pre><code>List nombreLinkedList = new LinkedList(); //downcasting desde interface\nLinkedList nombreLinkedList = new LinkedList();\n</code></pre> <p>Esta instrucci\u00f3n crea el <code>LinkedList</code> nombreLinkedList vac\u00edo. Un <code>LinkedList</code> declarado as\u00ed puede contener objetos de cualquier tipo:</p> <pre><code>List&lt;tipo&gt; nombreLinkedList = new LinkedList&lt;tipo&gt; (); //downcasting\nLinkedList&lt;tipo&gt; nombreLinkedList = new LinkedList&lt;tipo&gt; ();\n</code></pre> <p>Donde <code>tipo</code> debe ser una clase que indica el tipo de objetos que contendr\u00e1 la lista doblemente enlazada. Debe importarse el paquete <code>java.util.LinkedList;</code>.</p> <p>Al igual que ocurr\u00eda con <code>ArrayList</code>, no se pueden usar tipos primitivos, para usar un tipo primitivo se debe utilizar su clase envolvente. Adem\u00e1s, se puede hacer uso del operador diamond(<code>&lt;&gt;</code>).</p> <p>Hay una gran cantidad de m\u00e9todos que proporciona <code>LinkedList</code>, es recomendable acudir a la documentaci\u00f3n oficial.</p>"},{"location":"uutt/ut09/094_ArrayList.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 901 (RA6 / CE6a CE6b CE6c CE6e CE6f CE6g / IC1 / 3p). Crea un programa Java que utilice un <code>ArrayList</code> de objetos de la clase <code>Coche</code>. El programa pide por teclado los datos privados de cada uno de los coches y los guarda en un array redimensionable de la clase <code>ArrayList</code>. A continuaci\u00f3n, debe mostrar por pantalla lo siguiente:</p> <ul> <li>a) Todos los coches introducidos.</li> <li>b) Todos los coches de una marca determinada.</li> <li>c) Todos los coches con menos de un n\u00famero determinado de Kil\u00f3metros.</li> <li>d) El coche con mayor n\u00famero de Kil\u00f3metros.</li> <li>e) Todos los coches ordenados por n\u00famero de kil\u00f3metros de menor a mayor.</li> </ul> <p>La clase Coche tiene que estar correctamente definida por ti. Al main ha se ser funcional y permitir al usuario introducir tantos coches como desee. Se deben controlar que todas las excepciones que consideres.</p> </li> <li> <p>AC 902 (RA6 / CE6a CE6b CE6c CE6e CE6f CE6g / IC1 / 3p). Crea un programa que trabaje sobre el listado de empleados de una empresa utilizando un array redimensionable con la clase ArrayList. Para ello, en el mismo archivo .java:</p> <ul> <li>a) Genera una clase Principal con el m\u00e9todo main.</li> <li>b) Genera una clase Empleado con un atributo privado llamado apellido.</li> <li>c) El programa debe mostrar siempre el n\u00ba de empleados existente.</li> <li> <p>d) Y adem\u00e1s permitir\u00e1 realizar las siguientes acciones:</p> <ol> <li>Insertar empleado.</li> <li>Borrar empleado.</li> <li>Recorrer la lista.</li> <li>Buscar empleado.</li> <li>Borrar todos los empleados.</li> <li>Finalizar programa.</li> </ol> </li> </ul> <p>Al main ha se ser funcional y permitir al usuario introducir los empleados como desee. Se deben controlar que todas las excepciones que consideres.</p> </li> <li> <p>AC 903 (RA6 / CE6a CE6b CE6c CE6e CE6f CE6g / IC1 / 3p). Implementar una aplicaci\u00f3n para gestionar las existencias de una tienda de repuestos de autom\u00f3viles. Cada producto se identifica por un c\u00f3digo alfanum\u00e9rico. La aplicaci\u00f3n permitir\u00e1 dar de alta o de baja productos y actualizar el n\u00famero de unidades en stock de cada uno de ellos.</p> <p>Debes dise\u00f1ar la clase repuesto. El usuario puede crear tantos repuestos como considere. Se han de controlar las excepciones que consideres.</p> </li> </ul>"},{"location":"uutt/ut09/095_Pilas.html","title":"Pilas","text":"<p>Una pila es una lista en la que todas las inserciones y supresiones se hacen en un extremo de la lista. Un ejemplo de esta estructura es una pila de platos. En ella, el a\u00f1adir o quitar platos se hace siempre por la parte superior de la pila. Este tipo de listas recibe tambi\u00e9n el nombre de listas LIFO (last in first out \u2013 \u00faltimo en entrar, primero en salir). Las operaciones de meter y sacar en una pila son conocidas en los lenguajes ensambladores como <code>push</code> y <code>pop</code>, respectivamente. La operaci\u00f3n de sacar un elemento de la pila suprime dicho elemento de esta.</p>"},{"location":"uutt/ut09/095_Pilas.html#en-java-clase-stack","title":"En Java, clase Stack","text":"<p>En Java, podemos implementar pilas utilizando la clase gen\u00e9rica <code>Stack</code>.</p> M\u00e9todo Descripci\u00f3n push() Inserta un elemento en la pila pop() Elimina el elemento superior de la pila. peek() Devuelve el elemento superior de la pila sin eliminarlo. isEmpty() Verifica si la pila est\u00e1 vac\u00eda. search() Busca un elemento en la pila y devuelve su distancia desde la parte superior. <pre><code>public class ApplicationMain {\n    public static void main(String[] args) {\n        //Pilas con la clase Stack\n        //Crear una pila de libros\n        Stack&lt;String&gt; books = new Stack&lt;&gt;();\n        //Agregando elementos a la pila\n        books.push(\"Book 1\");\n        books.push(\"Book 2\");\n        books.push(\"Book 3\");\n        //Mostrando la pila\n        System.out.println(books);\n        //Ver el ultimo elemento\n        System.out.println(\"ultimo elemento: \" +\n        books.peek());\n        //Eliminar el ultimo elemento\n        System.out.println(\"ultimo elemento eliminado: \"+\n        books.pop());\n        //ver luego de eliminar\n        System.out.println(books);\n        //buscar elemento\n        System.out.println(\"ubicaci\u00f3n de Book 1 respecto a la parte superior: \"+ books.search(\"Book 1\"));\n    }\n}\n</code></pre>"},{"location":"uutt/ut09/095_Pilas.html#actividad","title":"Actividad","text":"<ul> <li>AC 904 (RA6 / CE6a CE6b CE6e CE6f / IC1 / 3p). Dise\u00f1a el algoritmo que necesita un friegaplato que debe limpiar 10 platos antes de proceder a su secado. Se debe mostrar por pantalla cual es la acci\u00f3n (fregar/secar).</li> </ul>"},{"location":"uutt/ut09/096_Colas.html","title":"Colas","text":"<p>Una cola es una lista lineal en la que todas las inserciones se hacen por un extremo de la lista (por el final) y todas las supresiones se hacen por el otro extremo (por el principio). Por ejemplo, una fila en la caja del supermercado. Este tipo de listas recibe tambi\u00e9n el nombre de listas FIFO (first in first out \u2013 primero en entrar, primero en salir). Este orden es la \u00fanica forma de insertar y recuperar un elemento de la cola. Una cola no permite acceso aleatorio a un elemento espec\u00edfico. Ten en cuenta que la operaci\u00f3n de sacar elimina el elemento de la cola.</p>"},{"location":"uutt/ut09/096_Colas.html#en-java-clase-queue","title":"En Java, clase Queue","text":"<p>En Java, podemos implementar colas utilizando la clase <code>Queue</code>.</p> M\u00e9todo Descripci\u00f3n add()/offer() Inserta un elemento en la cola remove/poll() Elimina el elemento superior de la cola. peek()/element() Devuelve el elemento superior de la cola sin eliminarlo. isEmpty() Verifica si la cola est\u00e1 vac\u00eda. <pre><code>public class ApplicationMain {\n  public static void main(String[] args) {\n    //Colas con la clase Dequeue\n    Queue&lt;String&gt; colas = new ArrayDeque&lt;&gt;();\n    colas.add(\"Amador\");\n    colas.add(\"Alex\");\n    colas.add(\"Pedro\");\n    System.out.println(colas);\n    //Eliminar el primer elimento\n    System.out.println(colas.poll());\n    System.out.println(colas);\n  }\n}\n</code></pre>"},{"location":"uutt/ut09/096_Colas.html#actividad","title":"Actividad","text":"<ul> <li> <p>AC 905 (RA6 / CE6a CE6b CE6e CE6f / IC1 / 3p). Realiza la creaci\u00f3n de un simulador de una cola de impresi\u00f3n simulada. Los usuarios pueden agregar documentos a la cola (enqueue), imprimir un documento de la cola (print), imprimir todos los documentos de la cola (print-all), mostrar todos los documentos en la cola (show), o salir del programa (exit).</p> <p>En caso de impresi\u00f3n se deber\u00e1 poner un tiempo aleatorio en cada ocasi\u00f3n.</p> </li> </ul>"},{"location":"uutt/ut09/097_IteratorHashcode.html","title":"Iterator, hashcode y equals","text":""},{"location":"uutt/ut09/097_IteratorHashcode.html#iterator","title":"<code>Iterator</code>","text":"<p>Los iteradores permiten recorrer colecciones de elementos. Para utilizar un iterador tenemos que implementar la interface <code>Iterator&lt;E&gt;</code> de la API de Java. Se genera un objeto iterador que recorrer\u00e1 una colecci\u00f3n de objetos, sin importar el tipo de objetos que tenga almacenada esa colecci\u00f3n.</p> <p>Para poder hacer el recorrido, esta interface proporciona tres m\u00e9todos:</p> M\u00e9todo Descripci\u00f3n next() Pasa al siguiente elemento de la colecci\u00f3n rhasnext() Comprueba si hay o no un elemento siguiente en la colecci\u00f3n. remove() Elimina un elemento dentro de la colecci\u00f3n. <p>A tener en cuenta</p> <p>Hay ciertas operaciones para las cuales es m\u00e1s recomendable recorrer y manipular una colecci\u00f3n mediante un iterador, mientras que para otras operaciones puede ser m\u00e1s conveniente un foreach.</p> <pre><code>public static void main(String[] args) {\n    ArrayList&lt;String&gt; nombres = new ArrayList&lt;&gt;();\n    String n = \"\";\n    nombres.add(\"Luis\");\n    nombres.add(\"Berta\");\n    nombres.add(\"Rodrigo\");\n    nombres.add(\"Susana\");\n    Iterator&lt;String&gt; it = nombres.iterator();\n    while(it.hasNext()){\n        n = it.next();\n        System.out.println(n);\n    }\n}\n</code></pre>"},{"location":"uutt/ut09/097_IteratorHashcode.html#hashcode","title":"hashCode","text":"<p>El <code>hashCode</code> es un n\u00famero que hace referencia a la localizaci\u00f3n de un objeto que tenemos almacenado en memoria (heap). Puede ser sobreescrito para adaptarlo a nuestras clases propias. Se implementa con el m\u00e9todo <code>hashCode()</code>.</p> <p>Es decir, se puede utilizar el hashCode para saber si dos objetos son distintos.</p>"},{"location":"uutt/ut09/097_IteratorHashcode.html#equals","title":"Equals","text":"<p>El m\u00e9todo <code>equals()</code> pertenece a la clase Object y funciona para las clases predefinidas en la API (String, Date,\u2026). Sin embargo, puede ser necesario sobreescribirlo para adaptarlo a nuestras clases propias.</p>"},{"location":"uutt/ut09/098_Mapas.html","title":"Mapas (<code>Map</code>)","text":"<p>Aunque la estructura de datos <code>Map</code> no forma parte dentro de la jerarqu\u00eda de la interfaz <code>Collection</code>, se considera una interfaz de colecci\u00f3n principal de Java Collections Framework. Un <code>Map</code> es un objeto que asigna claves a valores, un mapa no puede contener claves duplicadas: cada clave puede asignarse a un valor como m\u00e1ximo. Sin embargo, los valores asignados a la clave pueden tener valores duplicados. La interfaz <code>Map</code> incluye m\u00e9todos para operaciones b\u00e1sicas (como <code>put</code>, <code>get</code>, <code>remove</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, y <code>empty</code>) entre muchos otros.</p> <p>La plataforma Java contiene distintas implementaciones de <code>Map</code>: <code>HashMap</code>, <code>TreeMap</code> y <code>LinkedHashMap</code>. Como se puede observar en la siguiente imagen <code>TreeMap</code> es un <code>Map</code> cuyos elementos se almacenan ordenados. Esto es as\u00ed ya que <code>TreeMap</code> implementa la interfaz <code>SortedMap</code> (que a su vez hereda de <code>Map</code>).</p>"},{"location":"uutt/ut09/098_Mapas.html#crear-un-mapa","title":"Crear un Mapa","text":"<p>Para crear un objeto Map podemos usar cualquiera de las implementaciones para esta interfaz (<code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap\u2026</code>), por ejemplo:</p> <pre><code>Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n</code></pre> <p>Antes de seguir con ejemplos, os habr\u00e9is dado cuenta que hemos empezado la entrada diciendo que <code>Map</code> es una Interface y por tanto se deben de implementar los m\u00e9todos de la interface. Java ya tiene implementadas varias clases <code>Map</code>. No vamos a explicar todas, pero si las tres que consideramos m\u00e1s importantes y \u00fatiles para que ve\u00e1is la diferencia como son la clase <code>HashMap</code>, <code>TreeMap</code> y <code>LinkedHashMap</code>. La diferencia principal de estas 3 clases es la forma o el orden en las que guardan los valores en el <code>Map</code>, pero es necesario que veamos estas tres clases para que en funci\u00f3n de vuestro problema elij\u00e1is la mejor clase:</p> <ul> <li>HashMap: los elementos que inserta en el map no tendr\u00e1n un orden espec\u00edfico. No aceptan claves duplicadas ni valores nulos.</li> <li>TreeMap: el Mapa lo ordena de forma \"natural\". Por ejemplo, si la clave son valores enteros (como luego veremos), los ordena de menos a mayor.</li> <li>LinkedHashMap: inserta en el <code>Map</code> los elementos en el orden en el que se van insertando; es decir, que no tiene una ordenaci\u00f3n de los elementos como tal, por lo que esta clase realiza las b\u00fasquedas de los elementos de forma m\u00e1s lenta que las dem\u00e1s clases.</li> </ul> <p>Para a\u00f1adir un par de clave-valor al mapa usamos el m\u00e9todo <code>put</code>: <pre><code>public class MainMap {\n    public static void main(String[] args) {\n        Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n        idiomas.put(\"es\", \"Espa\u00f1ol\");\n        idiomas.put(\"en\", \"English EEUU\");\n        idiomas.put(\"ca\", \"English Canad\u00e1\");\n        idiomas.put(\"de\", \"Aleman\");\n        idiomas.put(\"fr\", \"Franc\u00e9s\");\n        idiomas.put(\"it\", \"Italian\");\n    }\n}\n</code></pre> Las claves de los mapas son \u00fanicas, si intentamos a\u00f1adir un nuevo valor para una clave que ya existe, el valor es sobreescrito.</p> <p>Para saber si estamos agregando una nueva clave o solo modificando el valor, el m\u00e9todo <code>put</code> nos ayuda, ya que devuelve el valor anterior asociado con la clave, o <code>null</code> si no hubo asignaci\u00f3n para la clave antes. Ejemplo: <pre><code>public class MainMap {\n    public static void main(String[] args) {\n        Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n        idiomas.put(\"es\", \"Espa\u00f1ol\");\n        idiomas.put(\"en\", \"English EEUU\");\n        idiomas.put(\"ca\", \"English Canad\u00e1\");\n        idiomas.put(\"de\", \"Aleman\");\n        idiomas.put(\"fr\", \"Franc\u00e9s\");\n        System.out.println(idiomas.put(\"it\", \"Italian\")); //devuelve null\n        /* devuelve el valor previo \"Italian\", lo que significa que se ha\n        sobreescrito: */ \n        System.out.println(idiomas.put(\"it\", \"Italiano\"));\n    }\n}\n</code></pre></p>"},{"location":"uutt/ut09/098_Mapas.html#obtener-el-valor-asociado-a-una-clave","title":"Obtener el valor asociado a una clave","text":"<p>Para esta tarea, usamos el m\u00e9todo <code>get</code>: <pre><code>String valor = idiomas.get(\"it\");\n</code></pre></p> <p>Comprobar si una clave o valor existe: <pre><code>if (idiomas.containsKey(\"es\")) {\n    System.out.println(\"La clave es ya existe\");\n} \nif (idiomas.containsValue(\"Espa\u00f1ol\")) {\n    System.out.println(\"El idioma espa\u00f1ol ya existe\");\n}\n</code></pre></p>"},{"location":"uutt/ut09/098_Mapas.html#imprimir","title":"Imprimir","text":"<p>Imprimir todos los valores del Map Lo haremos de la siguiente forma: <pre><code>for (String key: idiomas.keySet()) {\n    System.out.println(key + \" \" + idiomas.get(key));\n}\n</code></pre> Al imprimir vemos que las claves no aparecen en ning\u00fan orden, ni en el que las hemos introducido ni en orden alfab\u00e9tico. Los elementos del <code>HashMap</code> no est\u00e1n ordenados.</p> <p>Imprimir cada una de las entradas del mapa: <pre><code>for (Map.Entry&lt;String, String&gt; entradaMapa: idiomas.entrySet()) {\n    System.out.println(entradaMapa.getKey() + \" \" +entradaMapa.getValue());\n}\n</code></pre></p>"},{"location":"uutt/ut09/098_Mapas.html#eliminar-una-entrada-clave-valor-de-un-map","title":"Eliminar una entrada clave-valor de un Map","text":"<p>Tenemos dos formas de eliminar:</p> <ul> <li>Eliminar desde una clave existente.</li> <li>Eliminar un par clave-valor existente.</li> </ul> <pre><code>//Forma 1\nString eliminado = idiomas.remove(\"fr\"); // nos devuelve el elemento asociado al \u00edndice eliminado, \n                                        // hay que tener cuidado con el tipo de la variable si lo almacenamos\n//Forma 2\nif (idiomas.remove(\"de\", \"Ingles\")) {\n    System.out.println(\"de ha sido eliminado\");\n} else {\n    System.out.println(\"No existe un par clave-valor con de-Ingles\");\n}\n</code></pre>"},{"location":"uutt/ut09/098_Mapas.html#reemplazar-el-valor-de-una-clave","title":"Reemplazar el valor de una clave","text":"<pre><code>idiomas.replace(\"es\", \"Spain\");\n/* Reemplazo el antiguo valor por el nuevo, pero antes me aseguro de que el\nantiguo valor sea ese dato antes de cambiarlo */\nidiomas.replace(\"en\", \"English\", \"English EEUU\");\n</code></pre>"},{"location":"uutt/ut09/098_Mapas.html#actividad","title":"Actividad","text":"<ul> <li>AC 906 (RA6 / CE6a CE6b CE6c CE6d CE6e CE6f CE6g / IC1/ 3p). Implementar una aplicaci\u00f3n para gestionar las existencias de una tienda de repuestos de autom\u00f3viles. Cada producto se identifica por un c\u00f3digo alfanum\u00e9rico. La aplicaci\u00f3n permitir\u00e1 dar de alta o de baja productos y actualizar el n\u00famero de unidades en stock de cada uno de ellos.</li> </ul>"},{"location":"uutt/ut09/099_Conjuntos.html","title":"Conjuntos (<code>Set</code>)","text":"<p>La interfaz <code>Set</code> est\u00e1 contenida en el paquete <code>java.util</code> y extiende de la interfaz <code>Collection</code>, es una colecci\u00f3n desordenada de objetos en los que no se pueden almacenar valores duplicados. Esta interfaz contiene los m\u00e9todos heredados de la interfaz <code>Collection</code> y agrega una funci\u00f3n que restringe la inserci\u00f3n de elementos duplicados.</p> <p>La interfaz <code>Set</code> define los m\u00e9todos b\u00e1sicos de a\u00f1adir, eliminar, comprobar tama\u00f1o, si est\u00e1 vac\u00edo, tambi\u00e9n podemos verificar si un elemento existe en el conjunto. Pero no hay forma de obtener un elemento del conjunto. Es decir, podemos comprobar que algo existe y podemos iterar sobre los elementos del conjunto, pero no es posible obtener, por ejemplo, el elemento 3 del conjunto.</p> <p>Dado que <code>Set</code> es una interfaz, debe instanciar una implementaci\u00f3n concreta de la interfaz para poder usarla. Puedes elegir entre las siguientes implementaciones de <code>Set</code> en la API de colecciones de Java: <code>java.util.HashSet</code>, <code>java.util.TreeSet</code> y <code>java.util.LinkedHashSet</code>.</p> <p>Una de las mejores implementaciones (con mejor rendimiento) de la interfaz <code>Set</code> es la clase <code>HashSet</code>, que utiliza tablas hashes para almacenar los elementos. Es muy parecido a la clase <code>HashMap</code> que hemos utilizado anteriormente.</p> Crear un SetRecorrer los elementos de un SetConvertir en List <pre><code>//Sets gen\u00e9ricos sin especificar el tipo\nSet setA = new HashSet();\nSet setB = new LinkedHashSet();\nSet setC = new TreeSet();\n//Set de tipo Integer\nSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt; ();\n//A\u00f1adir elementos en un Set\nSet&lt;String&gt; setA = new HashSet&lt;&gt;();\nsetA.add(\"element 1\");\nsetA.add(\"element 2\");\nsetA.add(\"element 3\");\n</code></pre> <p>Hay dos formas de iterar los elementos de un Java <code>Set</code>:</p> <ul> <li>Utilizando un Iterator obtenido de la interfaz <code>Set</code>.</li> <li>Usando un bucle for-each.</li> </ul> <p>Al iterar los elementos en el Set, el orden de los elementos depende de la implementaci\u00f3n que utilicemos para crear el Set.</p> <pre><code>//Con Iterator\nSet&lt;String&gt; setA = new HashSet&lt;&gt;();\nsetA.add(\"element 1\");\nsetA.add(\"element 2\");\nsetA.add(\"element 3\");\nIterator iterator = set.iterator();\nwhile(iterator.hasNext(){\n    String element = iterator.next();\n}\n//Con bucle for-each\nSet&lt;Integer&gt; set= new HashSet();\nfor(Integer num: set) {\n    System.out.println(num);\n}\n//Si me he creado un set gen\u00e9rico, tengo que hacer un cast del objeto:\nSet set = new HashSet();\nfor(Object object : set) {\n    String element = (String) object;\n}\n</code></pre> <p>Se puede convertir los elementos de un Set en una List. Para ello, llamamos al m\u00e9todo <code>addAll()</code>, pasando el conjunto como par\u00e1metro.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(\"123\");\nset.add(\"456\");\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.addAll(set);\n</code></pre> <p>Adem\u00e1s de estos ejemplos, hay m\u00e1s funciones en la documentaci\u00f3n oficial.</p>"},{"location":"uutt/ut09/099_Conjuntos.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 907 (RA6 / CE6a CE6b CE6c CE6d CE6e CE6f CE6g / IC1 / 3p). Insertar en una lista 20 enteros aleatorios entre 1 y 10. A partir de ella, crear un conjunto con los elementos de la lista sin repetir, otro con los repetidos y otro con los elementos que aparecen una sola vez en la lista original.</p> </li> <li> <p>PR 908 (RA6 / CE6a CE6b CE6c CE6d CE6e CE6f CE6g / IC2 / 5p). En la biblioteca municipal, adem\u00e1s de los pr\u00e9stamos de libros, hay gente que va a leer, estudiar o hacer tareas, y es com\u00fan que cojan libros, revistas, pel\u00edculas... de las estanter\u00edas para utilizarlos en la propia biblioteca sin llevarlos a su casa. Queremos implementar un sistema de devoluci\u00f3n r\u00e1pida de estos materiales para poder colocarlos en su sitio.</p> <p>Los usuarios de la biblioteca, cuando han terminado de utilizar cualquier material, lo llevan a la mesa de devoluci\u00f3n r\u00e1pida y lo colocan en el mont\u00f3n. Pueden dejar varios elementos a la vez.</p> <p>Al finalizar su turno, el bibliotecario, coge los elementos del mont\u00f3n de uno en uno y los lleva a su lugar correspondiente. Realiza un programa en Java utilizando las colecciones m\u00e1s adecuadas para que los usuarios puedan hacer la devoluci\u00f3n r\u00e1pida en el mont\u00f3n y el bibliotecario pueda volver a colocar cada cosa en su lugar.</p> <p>Ayuda</p> <p>Puedes suponer 10 usuarios que devuelven entre 1 y 3 elementos.</p> <p>Se debe mostrar:</p> <ul> <li>a) Los elementos que tiene un usuario</li> <li>b) Los elementos que hay en el mont\u00f3n de devoluci\u00f3n despu\u00e9s de que cada usuario haga la devoluci\u00f3n.</li> <li>c) La colocaci\u00f3n de los elementos en su lugar por parte del bibliotecario.</li> </ul> <p>Se han de controlar todas las excepciones que consideres as\u00ed como usar expresiones regulares si lo consideras pertinente.</p> </li> <li> <p>PR 909 (RA6 / CE6a CE6b CE6c CE6d CE6e CE6f CE6g / IC2 / 5p). La pescader\u00eda Loli est\u00e1 buscando optimizar su proceso de atenci\u00f3n al cliente para reducir los tiempos de espera y mejorar la eficiencia del servicio. Para ello ha puesto una m\u00e1quina que da los turnos.</p> <p>Cuando un cliente llega a la pescader\u00eda toma un turno y espera a que Loli le atienda. Loli tarda un tiempo aleatorio entre 5 o 15 minutos en atender a un cliente. Los clientes llegan de uno en uno separados un tiempo de entre 2 y 5 minutos aleatoriamente. Es posible que un cliente llegue, vea que hay demasiada gente, y se vaya.</p> <p>Crea un programa en Java que permita gestionar los turnos en la Pescader\u00eda Loli utilizando las colecciones m\u00e1s adecuadas.</p> <p>Ayuda</p> <p>Puedes suponer un total de 20 clientes en la pescader\u00eda.</p> <p>Se debe mostrar:</p> <ul> <li>a) Un mensaje cada vez que llega un usuario y tomar su turno.</li> <li>b) La cantidad de personas que esperan cada vez que se modifica.</li> <li>c) Un mensaje cada vez que Loli termina de atender a alguien y llama al siguiente cliente.</li> <li>d) Un mensaje cada vez que alguien decide no quedarse a esperar y se va.</li> </ul> <p>Se han de controlar todas las excepciones que consideres as\u00ed como usar expresiones regulares si lo consideras pertinente.</p> </li> <li> <p>PR 910 (RA6 / CE6a CE6b CE6c CE6d CE6e CE6f CE6g / IC2 / 5p). Un estudiante de 1\u00ba de DAW acaba de comenzar su colecci\u00f3n de cromos de \u201cProgramadores Locos y sus Locos Lenguajes de Programaci\u00f3n\u201d que consta de 250 cromos diferentes de dos categor\u00edas: programadores y lenguajes de programaci\u00f3n.</p> <p>Para ello ha comprado 10 sobres con 5 cromos cada uno. Los cromos de los sobres est\u00e1n colocados aleatoriamente, pudiendo incluso estar repetidos. El estudiante, tiene los cromos completamente ordenados en un \u00e1lbum con un lugar espec\u00edfico para cada uno de ellos.</p> <p>Adem\u00e1s los cromos repetidos los lleva en un mazo a clase para intercambiar con sus compa\u00f1eros.</p> <p>Crea un programa en Java, utilizando las colecciones que consideres oportunas, que permita que gestionar los cromos del estudiante, tanto los ordenados en el \u00e1lbum como el mazo de cromos repetidos para intercambiar.</p> <p>El programa debe mostrar:</p> <ul> <li>a) Los cromos que salen en cada sobre.</li> <li>b) Un listado de todos los cromos que tengo en el \u00e1lbum.</li> <li>c) Un listado de todos los cromos de programadores locos.</li> <li>d) Un listado de todos los cromos de lenguajes de programaci\u00f3n.</li> <li>e) Un listado de todos los cromos que me faltan.</li> <li>f) Un listado de todos los cromos que tengo en el mazo.</li> </ul> <p>Se han de controlar todas las excepciones que consideres as\u00ed como usar expresiones regulares si lo consideras pertinente.</p> </li> <li> <p>PR 911 (RA6 / CE6a CE6b CE6c CE6d CE6e CE6f CE6g / IC2 / 5p). Los alumnos de programaci\u00f3n de 1\u00ba de DAW han creado un foro para intercambiar cromos de \u201cProgramadores Locos y sus Locos Lenguajes de Programaci\u00f3n\u201d. Pero se han dado cuenta que algunos de los alumnos m\u00e1s malvados que pueblan el Aula I01, con m\u00e9todos criminales m\u00e1s propios de la Yakuza, est\u00e1n creando m\u00faltiples cuentas para inflar los precios y controlar el mercado negro de cromos de PLyLLP. Para evitar estos problemas han decidido que los alumnos solo podr\u00e1n tener una \u00fanica cuenta activa en el foro al mismo tiempo.</p> <p>Los alumnos se registran en el foro creando una cuenta con un pseud\u00f3nimo, su email y una contrase\u00f1a. Los alumnos pueden crear tantas cuentas como quieran con el mismo email. Una vez que usuario se valida con su cuenta y accede al foro, no podr\u00e1 validarse ning\u00fan otro usuario con el mismo email.</p> <p>Crea una peque\u00f1a aplicaci\u00f3n en Java, utilizando las colecciones que estimes oportunas, que permita crear y almacenar las cuentas de usuario. Autenticar a los usuarios y mantener un registro de los usuarios que est\u00e1n conectados en el foro, impidiendo que un alumno este activo con dos cuentas a la vez. El programa debe mostrar:</p> <ul> <li>a) Todos los usuarios registrados en el foro con todos sus datos.</li> <li>b) Los usuarios actualmente validados en el foro.</li> </ul> <p>Se han de controlar todas las excepciones que consideres as\u00ed como usar expresiones regulares si lo consideras pertinente.</p> </li> <li> <p>PR 912 (RA6 / CE6a CE6b CE6c CE6d CE6e CE6f CE6g / IC2 / 5p). Despu\u00e9s de recorrer el Camino de Baldosas Amarillas y enfrentarte a varias brujas malvadas, llegas a la Ciudad Esmeralda y compruebas que para hablar con el Mago de Oz tienes que pedir cita previa.</p> <p>Para acceder al sistema de citas te tienes que registrar con tus datos personales, DNI, y el deseo que quieres que te conceda el mago. Solo se puede pedir una cita por cada demandante de ayuda. El sistema almacenar\u00e1 la cita, y el Mago, cuando sea tu turno, te conceder\u00e1 tu deseo o no, a su voluntad.</p> <p>Realiza un programa en Java, utilizando las colecciones que estimes oportunas, para crear el sistema de cita previa del Mago de Oz. Debe permitir inscribirse en el sistema y que el Mago procese las citas \u00fanicas e identificadas por DNI y conceda o no los deseos.</p> <p>Ayuda</p> <p>Puedes crear a Dorothy que quiere volver a Kansas, al Hombre de Hojalata que quiere un coraz\u00f3n, al Espantap\u00e1jaros que quiere un cerebro y al Le\u00f3n que quiere ser valiente.</p> <p>El programa debe mostrar:</p> <ul> <li>a) El listado de citas previas con todos los datos de los demandantes.</li> <li>b) El proceso de concesi\u00f3n o no de deseos por parte del mago.</li> </ul> <p>Se han de controlar todas las excepciones que consideres as\u00ed como usar expresiones regulares si lo consideras pertinente.</p> </li> <li> <p>PR 913 (RA6 / CE6a CE6b CE6c CE6d CE6e CE6f CE6g / IC2 / 5p). Tu amigo Jacobo Racho va a abrir una elegante chupiter\u00eda llamada el Bar Bit\u00farico. Pero como es m\u00e1s vago que el sastre de Tarz\u00e1n, te ha pedido que le crees un programa que genere los chupitos aleatoriamente.</p> <p>Las bebidas del bar las tenemos clasificadas en las siguientes categor\u00edas:</p> <ul> <li> <ol> <li>Alta graduaci\u00f3n: whisky, ron, ginebra, vodka, tequila\u2026 todo bebidas de 40\u00ba o m\u00e1s</li> </ol> </li> <li> <ol> <li>Baja graduaci\u00f3n: licores y dem\u00e1s bebidas con menos alcohol, 20\u00ba o menos.</li> </ol> </li> <li> <ol> <li>Refrescos y otras bebidas sin alcohol</li> </ol> </li> <li> <ol> <li>Zumos y bebidas naturales</li> </ol> </li> <li> <ol> <li>Otras: bot\u00e1nicos, semillas y otras chorradas.</li> </ol> </li> </ul> <p>Un chupito est\u00e1 formado por un m\u00ednimo de 2 ingredientes y un m\u00e1ximo de 4. Si son dos ingredientes ser\u00e1 uno de la primera y otro de la segunda categor\u00eda, si son 3 se a\u00f1adir\u00e1 otro de la tercera o la cuarta categor\u00eda, y si son 4 ingredientes, se a\u00f1adir\u00e1 otro m\u00e1s de la quinta.</p> <p>Jacobo Racho nos ha pedido que le hagamos un programa que almacene las bebidas y que genere chupitos aleatoriamente. Tambi\u00e9n quiere guardar los chupitos generados con un nombre que debe ser \u00fanico. Crea un programa en Java que realice esta tarea utilizando las colecciones que estimes oportunas.</p> <p>El programa deber\u00e1 mostrar:</p> <ul> <li>a) Las bebidas de cada categor\u00eda.</li> <li>b) Los ingredientes de los chupitos generados y pedir\u00e1 su nombre.</li> <li>c) Todos los chupitos guardados con todos sus datos.</li> <li>d) Todos los chupitos con un ingrediente concreto.</li> <li>e) Todos los chupitos que no tengan un ingrediente concreto.</li> <li>f) Todos los chupitos que tengan 3 o m\u00e1s ingredientes.</li> </ul> <p>Se han de controlar todas las excepciones que consideres as\u00ed como usar expresiones regulares si lo consideras pertinente.</p> </li> </ul>"},{"location":"uutt/ut09/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 09","text":""},{"location":"uutt/ut09/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA6.CE <ul> <li>Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos.</li> </ul> <ul> <li>a. Se han escrito programas que utilicen matrices (arrays).</li> <li>b. Se han reconocido las librer\u00edas de clases relacionadas con tipos de datos avanzados.</li> <li>c. Se han utilizado listas para almacenar y procesar informaci\u00f3n.</li> <li>d. Se han utilizado iteradores para recorrer los elementos de las listas.</li> <li>e. Se han reconocido las caracter\u00edsticas y ventajas de cada una de las colecciones de datos disponibles.</li> <li>f. Se han creado clases y m\u00e9todos gen\u00e9ricos.</li> <li>g. Se han utilizado expresiones regulares en la b\u00fasqueda de patrones en cadenas de texto.</li> <li>h. Se han identificado las clases relacionadas con el tratamiento de documentos escritos en diferentes lenguajes de intercambio de datos.</li> <li>i. Se han realizado programas que realicen manipulaciones sobre documentos escritos en diferentes lenguajes de intercambio de datos.</li> <li>j. Se han utilizado operaciones agregadas para el manejo de informaci\u00f3n almacenada en colecciones.</li> </ul>"},{"location":"uutt/ut09/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ul> <li>Wrappers de tipos en Java</li> <li>Listas enlazadas<ul> <li>Listas circulares</li> </ul> </li> <li>ArrayList</li> <li>Pilas (Stack)</li> <li>Colas (Queue)</li> <li>Iterator, hashcode y equals. </li> <li>Conjuntos</li> <li>Mapas</li> </ul>"},{"location":"uutt/ut09/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>18/02/2025</p> <p>Introducci\u00f3n Wrappers</p> <p></p> <p>02</p> <p>19/02/2025</p> <p>Listas enlazadas  ArrayList</p> <p>AC 901</p> <p>03</p> <p>19/02/2025</p> <p></p> <p>AC 902</p> <p>04</p> <p>20/02/2025</p> <p></p> <p>AC 903</p> <p>05</p> <p>20/02/2025</p> <p>Pilas</p> <p>AC 904</p> <p>06</p> <p>21/02/2025</p> <p>Colas</p> <p>AC 905</p> <p>07</p> <p>24/02/2025</p> <p>Iterators  Mapas</p> <p>AC 906</p> <p>08</p> <p>24/02/2025</p> <p></p> <p>Trabajo en clase</p> <p>09</p> <p>25/02/2025</p> <p>Set</p> <p>AC 907</p> <p>10</p> <p>26/02/2025</p> <p></p> <p>PR 908</p> <p>11</p> <p>26/02/2225</p> <p></p> <p>PR 908</p> <p>12</p> <p>27/02/2025</p> <p></p> <p>PR 909</p> <p>13</p> <p>27/02/2025</p> <p></p> <p>PR 909</p> <p>14</p> <p>28/02/2025</p> <p></p> <p>Trabajo en clase</p> <p>15</p> <p>03/03/2025</p> <p></p> <p>PO UT 09</p> <p>16</p> <p>03/03/2025</p> <p></p> <p>PO UT 09</p>"},{"location":"uutt/ut09/ResumenUT.html#referencias","title":"Referencias","text":""},{"location":"uutt/ut09/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":""},{"location":"uutt/ut10/1001_Flujos.html","title":"Flujos","text":"<p>Los Streams fueron introducidos en Java 8 para abrir la puerta a la programaci\u00f3n funcional al igual que con las expresiones lambda. No hay que confundirlos con los streams de entrada/salida, como un buffer stream de entrada o un fichero de salida.</p> <p>La API Stream permite manipular las colecciones como nunca antes. Nos permite realizar operaciones sobre la colecci\u00f3n, como por ejemplo, buscar, filtrar, reordenar, etc. Pero no nos permite manipular los elementos individualmente en el flujo, sino que se trata el flujo como un todo, a menudo agregando o reduciendo los datos, o quiz\u00e1s contando o agrupando elementos de alguna manera.</p> <p>Conceptos b\u00e1sicos</p> <p>Hay que tener en cuenta:</p> <ul> <li>Con Streams podemos utilizar cualquier clase que implemente la interfaz Collection como si fuese un Stream con la ventaja que nos ofrecen las expresiones lambda.</li> <li>Con streams hay que tener en cuenta que la fuente o colecci\u00f3n que utilicemos no se puede modificar y no debe afectar al estado de la misma. </li> <li>Cada operaci\u00f3n dentro del stream debe verse como una operaci\u00f3n independiente que opera sobre el argumento (colecci\u00f3n).</li> </ul> <p>A trav\u00e9s del API Stream podemos trabajar sobre colecciones como si estuvi\u00e9ramos realizando sentencias SQL pero de una manera limpia y clara, evitando bucles y algoritmos que ralentizan los programas e incluso hacen que el c\u00f3digo se torne inmanejable.</p> <p>Los Streams dise\u00f1an un flujo de trabajo que se ejecuta de forma unitaria item a item.</p>"},{"location":"uutt/ut10/1001_Flujos.html#clases-relativas-a-flujos","title":"Clases relativas a flujos","text":""},{"location":"uutt/ut10/1001_Flujos.html#empty-stream","title":"Empty Stream","text":"<p>Podemos usar el m\u00e9todo <code>empty()</code> en el caso de la creaci\u00f3n de una secuencia vac\u00eda:  <pre><code>Stream&lt;String&gt; streamEmpty = Stream.empty();\n</code></pre></p>"},{"location":"uutt/ut10/1001_Flujos.html#stream-de-una-coleccion-collection","title":"Stream de una Colecci\u00f3n (Collection)","text":"<p>Tambi\u00e9n podemos crear un flujo de cualquier tipo de Colecci\u00f3n (Collection, List, Set): <pre><code>List&lt;String&gt; lista = Arrays.asList(\"a\", \"b\", \"c\");\nStream&lt;String&gt; streamDeLista = lista.stream();\n</code></pre></p>"},{"location":"uutt/ut10/1001_Flujos.html#stream-de-array","title":"Stream de Array","text":"<p>Tambi\u00e9n podemos crear un stream a partir de un array existente o de parte de una matriz: <pre><code>String[] arr = new String[]{\"a\", \"b\", \"c\"};\nStream&lt;String&gt; streamDeArrayFull = Arrays.stream(arr);\n</code></pre></p>"},{"location":"uutt/ut10/1001_Flujos.html#streambuilder","title":"Stream.builder()","text":"<p>Cuando se usa el constructor, el tipo deseado debe especificarse adicionalmente en la parte derecha de la instrucci\u00f3n; de lo contrario, el m\u00e9todo <code>build()</code> crear\u00e1 una instancia de Stream:  <pre><code>Stream streamBuilder = Stream.builder().add(\"a\").add(\"b\").add(\"c\").build();\n</code></pre> Stream.generate() El m\u00e9todo <code>generate()</code> acepta un <code>Supplier&lt;T&gt;</code> para la generaci\u00f3n de elementos. Como el flujo resultante es infinito, el desarrollador debe especificar el tama\u00f1o deseado, o el m\u00e9todo generate() funcionar\u00e1 hasta que alcance el l\u00edmite de memoria:  <pre><code>Stream&lt;String&gt; streamGenerated = Stream.generate(() -&gt; \"valor\").limit(10);\n</code></pre></p>"},{"location":"uutt/ut10/1001_Flujos.html#streamiterate","title":"Stream.iterate()","text":"<p>Otra forma de crear un flujo infinito es usando el m\u00e9todo <code>iterate()</code>: <pre><code>Stream&lt;Integer&gt; streamIterated = Stream.iterate(40, n -&gt; n + 2).limit(20);\n</code></pre></p>"},{"location":"uutt/ut10/1001_Flujos.html#stream-de-primitivos","title":"Stream de Primitivos","text":"<p>Java 8 ofrece la posibilidad de crear streams a partir de tres tipos primitivos: <code>int</code>, <code>long</code> y <code>double</code>. Como Stream es una interfaz gen\u00e9rica y no hay forma de usar primitivas como par\u00e1metro de tipo con gen\u00e9ricos, se crearon tres nuevas interfaces especiales: <code>IntStream</code>, <code>LongStream</code>, <code>DoubleStream</code>. <pre><code>IntStream intStream = IntStream.range(1, 3);\nLongStream longStream = LongStream.rangeClosed(1, 3);\n</code></pre></p>"},{"location":"uutt/ut10/1001_Flujos.html#stream-de-string","title":"Stream de String","text":"<p>Tambi\u00e9n podemos usar <code>String</code> como fuente para crear un flujo con la ayuda del m\u00e9todo <code>chars()</code> de la clase <code>String</code>. Dado que no hay una interfaz para <code>CharStream</code> en JDK, en su lugar usamos <code>IntStream</code> para representar un flujo de caracteres. <pre><code>IntStream streamDeChars = \"abc\".chars();\n</code></pre></p>"},{"location":"uutt/ut10/1002_UsoFlujos.html","title":"Uso de flujos","text":"<p>Los Streams son una interesante incorporaci\u00f3n a Java, ya que me aportan varias ventajas:</p> <ol> <li>Hacen que el c\u00f3digo para procesar los datos sea uniforme, conciso y legible. Tiene una forma similar a SQL.</li> <li>Cuando se trabaja con grandes colecciones, los flujos paralelos proporcionan una ventaja de rendimiento.</li> </ol> <p>De forma gen\u00e9rica existen 3 partes que componen un Stream:</p> <ol> <li>Un Stream funciona a partir de una lista o colecci\u00f3n, que tambi\u00e9n se la conoce como la fuente de donde obtienen informaci\u00f3n.</li> <li>Operaciones intermedias como por ejemplo el m\u00e9todo filter, que permite hacer una selecci\u00f3n a partir de un predicado.</li> <li>Operaciones terminales, como por ejemplo los m\u00e9todos <code>max</code>, <code>min</code>, <code>forEach</code>, <code>findFirst</code> etc.</li> </ol> <p>Se pueden clasificar las funciones relacionados con Streams en dos grandes bloques: intermedias y finales.</p> <p>Son perezosas</p> <p>Las operaciones intermedias son perezosas (lazy). Esto significa que se invocar\u00e1n solo si es necesario para la ejecuci\u00f3n de la operaci\u00f3n del terminal.</p> <pre><code>List&lt;String&gt; lista = Arrays.asList(\u201cabc1\u201d, \u201cabc2\u201d, \u201cabc3\u201d);\nStream&lt;String&gt; stream = lista.stream().filter(valor-&gt; {\n    System.out.println(\"Procesando elemento: \" + valor);\n    return valor.contains(\"2\");\n});\n</code></pre> <p>Como tenemos una fuente de tres elementos, podemos suponer que el m\u00e9todo <code>filter()</code> se llamar\u00e1 tres veces y se imprimir\u00e1 por pantalla \u201cProcesando elemento: \u201d 3 veces. Sin embargo, ejecutar este c\u00f3digo no imprime nada por pantalla, por lo que el m\u00e9todo <code>filter()</code> ni siquiera se llam\u00f3 una vez. La raz\u00f3n por la que falta la operaci\u00f3n de la terminal. Si en vez de eso llamamos al final a una operaci\u00f3n terminal: <pre><code>List&lt;String&gt; lista = Arrays.asList(\u201cabc1\u201d, \u201cabc2\u201d, \u201cabc3\u201d);\nlong contador = lista.stream().filter(valor-&gt; {\n    System.out.println(\"Procesando elemento: \" + valor);\n    return valor.contains(\"2\");\n}).count();\n</code></pre> El resultado muestra que llamamos al m\u00e9todo <code>filter()</code> 3 veces y al m\u00e9todo <code>count()</code> una vez. Esto se debe a que la canalizaci\u00f3n se ejecuta verticalmente.</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#operaciones-intermedias","title":"Operaciones intermedias","text":"Operaci\u00f3n Descripci\u00f3n distinct() Elimina los valores duplicados del Stream. filter(Predicate) Los elementos que coinciden con el filtro de Predicate se mantienen en el stream de salida para las operaciones. takeWhile(Predicate) Similar a filter. Con la diferencia de que la primera vez que se eval\u00faa a falsa la condici\u00f3n, deja de comprobar el resto de elementos. dropWhile(Predicate) Eliminar\u00e1 o filtrar\u00e1 cualquier elemento mientras coincida con la condici\u00f3n del Predicate. Cuando la condici\u00f3n se eval\u00faa como falso la primera vez, la condici\u00f3n ya no se comprueba. limit(long maxSize) Reduce el stream al tama\u00f1o especificados en el par\u00e1metro. skip(long n) Este m\u00e9todo omite elementos, es decir, no formar\u00e1n parte del stream resultante <p>Adem\u00e1s de estas operaciones b\u00e1sicas, hay otras que son de gran inter\u00e9s:</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#peek","title":"Peek()","text":"<p>Este m\u00e9todo existe principalmente para la depuraci\u00f3n del programa, donde se desea ver los elementos a medida que pasan por un punto determinado en el pipeline.</p> <p><code>peek()</code> tambi\u00e9n se utiliza cuando queremos alterar el estado interno de un elemento (aunque esto no es muy com\u00fan). <pre><code>Stream.of(\"one\", \"two\", \"three\", \"four\")\n  .filter(e -&gt; e.length() &gt; 3)\n  .peek(e -&gt; System.out.println(\"Filtered value: \" + e))\n  .map(String::toUpperCase)\n  .peek(e -&gt; System.out.println(\"Mapped value: \" + e))\n  .collect(Collectors.toList());\n</code></pre></p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#sorted","title":"Sorted()","text":"<p>Se utiliza para ordenar los elementos del stream. Recibe como par\u00e1metro una expresi\u00f3n lambda de tipo Comparator para que podamos indicar la l\u00f3gica de la ordenaci\u00f3n.</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#map","title":"Map()","text":"<p>El m\u00e9todo map recibe como par\u00e1metro una expresi\u00f3n lambda de tipo Function, por lo que debemos especificar una funci\u00f3n que recibe como par\u00e1metro de entrada cada elemento del stream, y devuelve un objeto que puede ser un tipo de dato distinto o el mismo.</p> <p>La funci\u00f3n se aplica a cada uno de los elementos del stream para realizar alguna transformaci\u00f3n sobre cada elemento y devuelve otro Stream sobre el cual puedes seguir trabajando. Se utiliza para modificar el contenido del stream. </p> <p><code>map()</code> devuelve un stream nuevo que consta de los resultados de aplicar la funci\u00f3n dada a los elementos del stream. <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 6, 9, 12, 15);\n//Mostramos el nuevo stream devuelto por map\nlist.stream().map(number -&gt; number * 3).forEach(System.out::println);\n//[9 18 27 36 45]\n</code></pre></p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#flatmap","title":"FlatMap","text":"<p>Cuando nos encontramos con estructuras m\u00e1s complejas, como por ejemplo una lista con otra lista, trabajar con <code>map()</code> no es suficiente, por ello, utilizamos <code>flatMap()</code> que lo que hace es \"aplanar\" listas anidadas y quedarnos con un stream plano.</p> <p>Es una funci\u00f3n que recibe una entrada y devuelve varias salidas para esa entrada. Esa es la diferencia con respecto a <code>map()</code> que recibe solo un par\u00e1metro de entrada y devuelve una salida.</p> <p><code>flatMap()</code> es una operaci\u00f3n intermedia y devuelve un nuevo Stream. Devuelve un Stream que consiste en los resultados de reemplazar cada elemento del stream dado con el contenido de un stream mapeado producido al aplicar la funci\u00f3n de mapeo provista a cada elemento. La funci\u00f3n de mapeo utilizada para la transformaci\u00f3n en <code>flatMap()</code> es una funci\u00f3n sin estado y solo devuelve una secuencia de nuevos valores.</p> <p>En el siguiente ejemplo el programa usa la operaci\u00f3n <code>flatMap()</code> para convertir una lista de una lista <code>List&lt;List&lt;Integer&gt;&gt;</code> a una lista <code>List&lt;Integer&gt;</code>. <pre><code>List&lt;Integer&gt; list1 = Arrays.asList(1,2,3);\nList&lt;Integer&gt; list2 = Arrays.asList(4,5,6);\nList&lt;Integer&gt; list3 = Arrays.asList(7,8,9);\nList&lt;List&lt;Integer&gt;&gt; listOfLists = Arrays.asList(list1, list2, list3);\nList&lt;Integer&gt; listOfAllIntegers = listOfLists.stream()\n          .flatMap(x -&gt; x.stream())\n          .collect(Collectors.toList());\nSystem.out.println(listOfAllIntegers);\n//[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre></p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#operaciones-terminales","title":"Operaciones terminales","text":"<p>Las operaciones terminales significan el final del ciclo de vida del steam. Lo m\u00e1s importante para nuestro escenario es que inician el trabajo en la tuber\u00eda. </p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#foreach","title":"forEach()","text":"<p>Recorremos cada elemento del stream para realizar alguna acci\u00f3n con \u00e9l.  <pre><code>list.stream().map(number -&gt; number * 3).forEach(System.out::println);\n</code></pre></p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#collect","title":"collect()","text":"<p>Es una operaci\u00f3n terminal, se utiliza para indicar el tipo de colecci\u00f3n en la que se devolver\u00e1 el resultado final de todas las operaciones realizadas en el stream. <pre><code>List&lt;String&gt; lista = Arrays.asList(\"Texto1\", \"Texto2\");\nSet&lt;String&gt; set = lista.stream().collect(Collectors.toSet());\n</code></pre></p> <p>Clase Optional</p> <p><code>Optional</code> es una clase gen\u00e9rica, cuyo prop\u00f3sito es ser un contenedor para un valor que puede o no ser nulo. Fue creado por los ingenieros de Java, para abordar el problema o excepci\u00f3n tan conocida la <code>NullPointerException</code>.</p> <p>La documentaci\u00f3n oficial de Java dice que este tipo est\u00e1 pensado principalmente para un uso como tipo de retorno de m\u00e9todo, bajo condiciones espec\u00edficas.</p> <p><code>Optional</code> trata de resolver el problema cuando hay ausencia de resultados o datos y no queremos que esto sea un error. Por ejemplo, no todas las personas tienen 2o apellido. Esto ser\u00eda v\u00e1lido para un <code>optional</code>, pero por ejemplo todo el mundo tenemos fecha de nacimiento, esto s\u00ed que es un error.</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#findfirst","title":"findFirst()","text":"<p>Se utiliza para devolver el primer elemento encontrado del stream. Se suele utilizar en combinaci\u00f3n con otras funciones cuando hay que seleccionar un \u00fanico valor del stream que cumpla determinadas condiciones.</p> <p><code>findFirst</code> devuelve un objeto de tipo Optional para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#toarray","title":"toArray()","text":"<p>Con este m\u00e9todo se puede convertir cualquier tipo de Collection en un array de forma sencilla.</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#min","title":"min()","text":"<p>Con <code>min</code> se obtiene el elemento del stream con el valor m\u00ednimo calculado a partir de una expresi\u00f3n lambda de tipo Comparator que indicamos como par\u00e1metro.</p> <p><code>min</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#max","title":"max()","text":"<p>Con <code>max</code> se obtiene el elemento del stream con el valor m\u00e1ximo calculado a partir de una expresi\u00f3n lambda de tipo Comparator que indicamos como par\u00e1metro de la expresi\u00f3n.</p> <p><code>max</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#match","title":"Match()","text":"<p>La API Stream ofrece un pr\u00e1ctico conjunto de instrumentos para validar elementos de una secuencia de acuerdo con alg\u00fan predicado. Para hacer esto, se puede usar uno de los siguientes m\u00e9todos: <code>anyMatch()</code>, <code>allMatch()</code>, <code>noneMatch()</code>. </p> <p>Sus nombres se explican por s\u00ed mismos. Esas son operaciones de terminal que devuelven un valor booleano: <pre><code>boolean alMenosUnoContieneHMinuscula = list.stream().anyMatch(element -&gt; element.contains(\"h\")); // verdadero\nboolean todosContienenHMinuscula = list.stream().allMatch(element -&gt; element.contains(\"h\")); // falso\nboolean ningunoContieneHMinuscula  = list.stream().noneMatch(element -&gt; element.contains(\"h\")); // falso\n</code></pre></p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#reduce","title":"Reduce()","text":"<p>La API Stream permite reducir una secuencia de elementos a alg\u00fan valor de acuerdo con una funci\u00f3n espec\u00edfica con la ayuda del m\u00e9todo <code>reduce()</code> del tipo Stream. Este m\u00e9todo toma dos par\u00e1metros: primero, valor de inicio, segundo, una funci\u00f3n de acumulador.</p> <p>Imagina que tienes un List y quieres tener una suma de todos estos elementos y alg\u00fan Integer inicial (en este ejemplo 23). Entonces, puede ejecutar el siguiente c\u00f3digo y el resultado ser\u00e1 26 (23 + 1 + 1 + 1). <pre><code>List&lt;Integer&gt; integers = Arrays.asList(1, 1, 1);\nInteger reducido = integers.stream().reduce(23, (a, b) -&gt; a + b);\n</code></pre></p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#collect_1","title":"Collect()","text":"<p>La reducci\u00f3n tambi\u00e9n puede proporcionarse mediante el m\u00e9todo <code>collect()</code> de tipo Stream. Esta operaci\u00f3n es muy \u00fatil en el caso de convertir un stream en una colecci\u00f3n o un mapa y representar un stream en forma de una sola cadena. Hay una clase de utilidad Collectors que proporciona una soluci\u00f3n para casi todas las operaciones de recolecci\u00f3n t\u00edpicas. Para algunas tareas no triviales, se puede crear un recopilador personalizado. <pre><code>Lista lista de resultados&lt;br&gt;= list.stream().map(element -&gt; element.toUpperCase()).collect(Collectors.toList());\n</code></pre> Este c\u00f3digo usa la operaci\u00f3n de terminal <code>collect()</code> para reducir un Stream a List.</p>"},{"location":"uutt/ut10/1002_UsoFlujos.html#ventajas-e-inconvenientes","title":"Ventajas e inconvenientes","text":"<p>Ventajas de Streams</p> <ul> <li>C\u00f3digo conciso y m\u00e1s limpio.</li> <li>Programaci\u00f3n funcional: se programa escribiendo el \"qu\u00e9\" en lugar del \"c\u00f3mo\" para que sea comprensible de un vistazo.</li> <li>Puede leer y comprender f\u00e1cilmente el c\u00f3digo que tiene una serie de operaciones complejas.</li> <li>Ejecutar tan r\u00e1pido como bucles for (o m\u00e1s r\u00e1pido con operaciones paralelas)</li> <li>Ideal para listas grandes.</li> </ul> <p>Desventajas</p> <ul> <li>Excesivo para peque\u00f1as colecciones.</li> <li>Dif\u00edcil de aprender si est\u00e1 acostumbrado a la codificaci\u00f3n de estilo imperativo tradicional</li> </ul>"},{"location":"uutt/ut10/1002_UsoFlujos.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 1001 (RA6 / IC1 / 3p). Crea una lista de n\u00fameros enteros, utiliza programaci\u00f3n funcional para filtrar y obtener solo los n\u00fameros pares.</p> </li> <li> <p>AC 1002 (RA6 / IC1 / 3p). Crea una lista de n\u00fameros enteros, utiliza programaci\u00f3n funcional para obtener la suma de los cuadrados de todos los elementos.</p> </li> <li> <p>AC 1003 (RA6 / IC1 / 3p). Crea una lista de cadenas, utiliza programaci\u00f3n funcional para convertir todas las cadenas a may\u00fasculas.</p> </li> <li> <p>AC 1004 (RA6 / IC1 / 3p). Crea una lista de n\u00fameros, utiliza programaci\u00f3n funcional para verificar si al menos uno de los n\u00fameros es mayor que 10.</p> </li> <li> <p>AC 1005 (RA6 / IC1 / 3p). Crea una lista de cadenas, utiliza programaci\u00f3n funcional para contar cu\u00e1ntas cadenas tienen m\u00e1s de 3 caracteres.</p> </li> <li> <p>AC 1006 (RA6 / IC1 / 3p). A partir de una lista de nombres, convi\u00e9rtelos todos a may\u00fasculas, ord\u00e9nalos alfab\u00e9ticamente y muestra cada paso intermedio utilizando <code>peek</code>.</p> </li> <li> <p>AC 1007 (RA6 / IC1 / 3p). Disponemos de una lista de productos con nombre y precio, ord\u00e9nalos de menor a mayor precio utilizando <code>sorted</code> y mu\u00e9stralos en la consola.</p> </li> <li> <p>AC 1008 (RA6 / IC1 / 3p). Dada una lista de n\u00fameros enteros, eleva cada n\u00famero al cuadrado y luego devuelve una lista con los resultados usando <code>map</code>.</p> </li> <li> <p>AC 1009 (RA6 / IC1 / 3p). A partir de una lista formada por frases, obtener una nueva lista con todas las palabras almacenadas de forma individual utilizando <code>flatMap</code>.</p> </li> <li> <p>PR 1010 (RA6 / IC1 / 5p). Crea una lista de libros con el t\u00edtulo y el nombre de su autor o autores y obt\u00e9n una lista con el nombre de todos los autores que hay sin repetir</p> </li> <li> <p>PR 1011 (RA6 / IC1 / 5p). Dado un listado de empleados, cada uno con un nombre y un salario, debes escribir un programa en Java que realice las siguientes operaciones utilizando programaci\u00f3n funcional (con streams):</p> <ol> <li>Filtra a los empleados cuyo salario sea superior a 3000.</li> <li>Obt\u00e9n una lista con los nombres de los empleados que cumplen con el criterio de salario anterior.</li> <li>Ordena alfab\u00e9ticamente los nombres de los empleados filtrados.</li> <li>Calcula el salario promedio de estos empleados.</li> </ol> </li> </ul>"},{"location":"uutt/ut10/1003_Ficheros.html","title":"Ficheros de datos","text":"<p>Normalmente, cuando se codifica un programa, se hace con la intenci\u00f3n de que ese programa pueda interactuar con los usuarios del mismo, es decir, que el usuario pueda pedirle que realice cosas y pueda suministrarle datos con los que se quiere que haga algo. Una vez introducidos los datos y las \u00f3rdenes, se espera que el programa manipule de alguna forma esos datos para proporcionarnos una respuesta a lo solicitado.</p>"},{"location":"uutt/ut10/1003_Ficheros.html#lectura-y-escritura-secuencial-en-un-archivo","title":"Lectura y escritura secuencial en un archivo","text":"<p>En Java es posible utilizar dos tipos de ficheros (de texto o binarios) y dos tipos de acceso a los ficheros (secuencial o aleatorio). Los ficheros de texto est\u00e1n compuestos de caracteres legibles, mientras que los binarios pueden almacenar cualquier tipo de datos (int, float, boolean,...).</p> <p>Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Sin embargo los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.</p> <p>Para tratar con un fichero siempre hay que actuar de la misma manera:</p> <ol> <li>Se abre el fichero.</li> <li>Se utiliza el fichero.</li> <li>Gesti\u00f3n de excepciones (opcional, pero recomendada)</li> <li>Se cierra el fichero y se destruye el objeto.</li> </ol>"},{"location":"uutt/ut10/1003_Ficheros.html#la-clase-file","title":"La clase File","text":"<p>La clase <code>File</code> (Fichero) se usa para obtener informaci\u00f3n sobre ficheros (tambi\u00e9n llamado archivos) y directorios. Adem\u00e1s, permite crear esos ficheros y directorios. Un objeto de la clase File representa un archivo o directorio. Para hacer un de esta clase, seguiremos la siguiente estructura:</p> <pre><code>File nombreFichero = new File (\"nombreFichero.extension\"); // si se considera que esta\n                                                          //en el mismo directorio\nFile nombreFichero = new File (\"ruta/nombreFichero.extension\"); // si se considera que \n                                                               // no esta  en el mismo directorio                                                               \nFile nombreFichero = new File (\"ruta\",\"nombreFichero.extension\");\n\n//Podemos hacer uso de File para crear directorios para ello:\nFile nombreRuta = new File (\"ruta\");\nFile nombreFichero = new File (nombreRuta,\"nombreFichero.extension\");\n</code></pre> <p>Info</p> <p>En todos los casos la ruta o path puede ser absoluta o relativa. Debemos tener en cuenta que crear un objeto File no significa que deba existir el fichero o el directorio o que el path sea correcto. Si no existen no se lanzar\u00e1 ning\u00fan tipo de excepci\u00f3n, ni tampoco ser\u00e1n creados.</p> <p>Es por ello que debemos conocer los m\u00e9todos que nos proporciona la clase <code>File</code> para conocer lo que se puede desarrollar con ella. A continuaci\u00f3n, se exponen algunos m\u00e9todos que pueden ser de utilidad, pero es recomendable que se haga uso de la documentaci\u00f3n oficial.</p> M\u00e9todo Descripci\u00f3n <code>boolean createNewFile()</code> Crea el fichero asociado al objeto File. Devuelve <code>true</code> si se ha podido crear o <code>false</code> si ya existe. Si ocurre un error I/O lanza una excepci\u00f3n del tipo <code>IOException</code>. <code>boolean delete()</code> Elimina el fichero o directorio. Si es un directorio debe estar vac\u00edo. Devuelve <code>true</code> si se ha podido eliminar. <code>boolean exists()</code> Devuelve <code>true</code> si el fichero o directorio existe. <code>String getName()</code> Devuelve el nombre del fichero o directorio. <code>String getAbsolutePath()</code> Devuelve la ruta absoluta asociada al objeto File. <code>String getPath()</code> Devuelve la ruta con la que se cre\u00f3 el objeto File. Puede ser relativa o no. <code>String getParent()</code> Devuelve un <code>String</code> conteniendo el directorio padre del File. Devuelve <code>null</code> si no tiene directorio padre. <code>File getParentFile()</code> Devuelve un objeto File conteniendo el directorio padre del File. Devuelve <code>null</code> si no tiene directorio padre. <code>boolean isDirectory()</code> Devuelve <code>true</code> si es un directorio v\u00e1lido. <code>boolean isFile()</code> Devuelve <code>true</code> si es un fichero v\u00e1lido. <code>long length()</code> Devuelve el tama\u00f1o en bytes del fichero. Devuelve <code>0</code> si no existe. Devuelve un valor indeterminado si es un directorio. <code>String[] list()</code> Devuelve un array de <code>String</code> con el nombre de los archivos y directorios que contiene el directorio indicado en el objeto File. Si no es un directorio devuelve <code>null</code>. Si el directorio est\u00e1 vac\u00edo devuelve un array vac\u00edo. <code>String[] list(FilenameFilter filtro)</code> Similar al anterior. Devuelve un array de <code>String</code> con el nombre de los archivos y directorios que contiene el directorio indicado en el objeto File que cumplen con el filtro indicado. <code>boolean mkdir()</code> Crea el directorio. Devuelve <code>true</code> si se ha podido crear. <code>boolean renameTo(File dest)</code> Cambia el nombre del fichero por el indicado en el par\u00e1metro <code>dest</code>. Devuelve <code>true</code> si se ha realizado el cambio. Ejemplo 1Ejemplo 2 <pre><code>/*El siguiente programa muestra el uso de algunos m\u00e9todos de la clase File. \nSe crea un objeto File ruta asociado al directorio c:/ficheros y un objeto File f \nasociado al fichero datos.txt que se encuentra en ese directorio. \nSi el fichero y/o el directorio no existen se crean, \nsi el fichero ya exist\u00eda se muestra el tama\u00f1o del mismo.*/\n\nimport java.io.File; \nimport java.io.IOException;\n\npublic class Ejemplo1 {\n    public static void main(String[] args) throws IOException {\n        File ruta = new File(\"c:/ficheros\"); // ruta absoluta\n        File f = new File(ruta, \"datos.txt\"); // tercer constructor explicado\n\n        System.out.println(f.getAbsolutePath()); // path absoluto de datos.txt\n        System.out.println(f.getParent()); // path del directorio ra\u00edz de datos.txt\n        System.out.println(ruta.getAbsolutePath()); // path absoluto de c:/ficheros\n        System.out.println(ruta.getParent()); // path del directorio ra\u00edz de c:/ficheros\n\n        if (!f.exists()) { // se comprueba si el fichero existe o no\n            System.out.println(\"Fichero \" + f.getName() + \" no existe\");\n\n            if (!ruta.exists()) { // se comprueba si la ruta existe o no\n                System.out.println(\"El directorio \" + ruta.getName() + \" no existe\");\n\n                if (ruta.mkdir()) { // se crea la ruta. Si se ha creado correctamente\n                    System.out.println(\"Directorio creado\");\n\n                    if (f.createNewFile()) { // se crea el fichero. Si lo crea correctamente\n                        System.out.println(\"Fichero \" + f.getName() + \" creado\");\n                    } else {\n                        System.out.println(\"No se ha podido crear \" + f.getName());\n                    }\n                } else {\n                    System.out.println(\"No se ha podido crear \" + ruta.getName());\n                }\n            } else { // si la ruta existe creamos el fichero\n                if (f.createNewFile()) {\n                    System.out.println(\"Fichero \" + f.getName() + \" creado\");\n                } else {\n                    System.out.println(\"No se ha podido crear \" + f.getName());\n                }\n            }\n        } else { // el fichero existe. Mostramos el tama\u00f1o\n            System.out.println(\"Fichero \" + f.getName() + \" existe\");\n            System.out.println(\"Tama\u00f1o \" + f.length() + \" bytes\");\n        }\n    }   \n}\n</code></pre> <pre><code>/*El siguiente programa muestra c\u00f3mo eliminar un fichero \ny c\u00f3mo cambiar el nombre de un fichero usando la clase File.\n*/\n\nimport java.io.File;\nimport java.util.Scanner;\n\npublic class Ejemplo2 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String nombre;\n        File ruta = new File(\"c:/ficheros\"); // Ruta absoluta\n\n        // Eliminar un fichero\n        System.out.println(\"Introduce el nombre del fichero a eliminar: \");\n        nombre = sc.nextLine();\n        File f = new File(ruta, nombre); // Tercer constructor explicado\n\n        if (f.exists()) {\n            System.out.println(f.getAbsolutePath());\n            if (f.delete()) {\n                System.out.println(\"Fichero eliminado\");\n            } else {\n                System.out.println(\"No se ha podido eliminar\");\n            }\n        } else {\n            System.out.println(\"El fichero \" + f.getAbsolutePath() + \" no existe\");\n        }\n\n        // Cambiar el nombre de un fichero\n        System.out.println(\"Introduce el nombre del fichero a renombrar: \");\n        nombre = sc.nextLine();\n        File f1 = new File(ruta, nombre);\n\n        if (f1.exists()) {\n            System.out.println(f1.getAbsolutePath());\n            System.out.println(\"Introduce nuevo nombre: \");\n            String nuevoNombre = sc.nextLine();\n            File f2 = new File(ruta, nuevoNombre);\n\n            if (f1.renameTo(f2)) {\n                System.out.println(\"Se ha cambiado el nombre\");\n            } else {\n                System.out.println(\"No se ha podido cambiar el nombre\");\n            }\n        } else {\n            System.out.println(\"El fichero \" + f1.getAbsolutePath() + \" no existe\");\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut10/1003_Ficheros.html#filtros","title":"Filtros","text":"<p>Un filtro sirve para que el m\u00e9todo list devuelva solo aquellos archivos o carpetas que cumplan una determinada condici\u00f3n (que sean de una extensi\u00f3n determinada, que contengan en su nombre cierta cadena, empiecen por una cadena, etc\u2026). Un filtro es un objeto de una clase que implementa la interfaz FilenameFilter (Filtro de nombres de fichero). Esta interface tiene un solo m\u00e9todo llamado accept que devuelve un valor de tipo boolean:  <pre><code>public interface FilenameFilter{ boolean accept (File ruta, String nombre); } \n</code></pre></p> <p>El m\u00e9todo recibe el directorio donde se encuentra el archivo (objeto <code>File</code>) y el nombre del archivo (<code>String</code>). Este m\u00e9todo lo utiliza el m\u00e9todo list de <code>File</code> para decidir si un archivo o directorio determinado se incluye o no en el array que devuelve. Si accept devuelve true se incluye y si devuelve false no se incluye. El m\u00e9todo list llama de forma autom\u00e1tica al m\u00e9todo accept para cada uno de los archivos o directorios.</p> Filtro.java<pre><code>import java.io.File; \nimport java.io.FilenameFilter; \n//Clase Filtro implementa el interface FilenameFilter \nclass Filtro implements FilenameFilter { \n    String extension; \n    Filtro(String extension) { \n        this.extension = extension; \n} \n//implementaci\u00f3n del m\u00e9todo accept del interface \n@Override \npublic boolean accept(File ruta, String nombre) { \n    return nombre.endsWith(extension); \n    }\n}\n</code></pre> <p>Que de forma pr\u00e1ctica se puede aplicar:</p> <pre><code>import java.io.File;\n\npublic class Ejemplo5 {\n    public static void main(String[] args) {\n        File ruta = new File(\"/temas/teoria\"); // Ruta absoluta\n        System.out.println(\"Archivos .pdf en el directorio \" + ruta.getAbsolutePath());\n\n        // Crear el filtro\n        String[] lista = ruta.list(new Filtro(\".pdf\"));\n\n        // Verificar y listar los archivos\n        if (lista == null) {\n            System.out.println(\"Total: 0 archivos\");\n        } else {\n            for (int i = 0; i &lt; lista.length; i++) {\n                System.out.println(lista[i]);\n            }\n            System.out.println(\"Total: \" + lista.length);\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut10/1003_Ficheros.html#clases-filewriter-y-filereader","title":"Clases FileWriter y FileReader","text":""},{"location":"uutt/ut10/1003_Ficheros.html#filewriter","title":"FileWriter","text":"<p>Para escribir en un fichero de texto utilizaremos dos clases: <code>FileWriter</code> (Escritor de ficheros) y <code>PrintWriter</code> (Impresor con formato). La clase <code>FileWriter</code> permite tener acceso al fichero en modo escritura. Para crear objetos <code>FileWriter</code> podemos utilizar los constructores: <pre><code>FileWriter fw = new FileWriter (Path);\nFileWriter fw = new FileWriter (File Objeto);\n</code></pre> El fichero se crea y si ya existe su contenido se pierde. Si lo que necesitamos es abrir un fichero de texto existente sin perder su contenido y a\u00f1adir m\u00e1s contenido al final utilizaremos los constructores: <pre><code>FileWriter fw = new FileWriter (Path, append);\nFileWriter fw = new FileWriter (File Objeto, append);\n</code></pre> Si el par\u00e1metro append es true significa que los datos se van a a\u00f1adir a los existentes. Si es false los datos existentes se pierden. La clase <code>FileWriter</code> proporciona el m\u00e9todo <code>write()</code> para escribir cadenas de caracteres aunque lo normal es utilizar esta clase junto con la clase <code>PrintWriter</code> para facilitar la escritura. La clase <code>PrintWriter</code> permite escribir caracteres en el fichero de la misma forma que en la pantalla.</p> <p>Si lo queremos ver en un ejemplo: <pre><code>FileWriter fw = new FileWriter(\"c:/ficheros/datos.txt\");\nPrintWriter salida = new PrintWriter(\"c:/ficheros/datos.txt\");\n</code></pre> En este caso, si el fichero no existe se crea. Si no se puede crear un archivo con ese nombre o si ocurre alg\u00fan error se lanza una excepci\u00f3n <code>FileNotFoundException</code>. </p> <p>Una vez creado el objeto PrintWriter podemos utilizar <code>print()</code>, <code>println()</code> y <code>printf()</code> para escribir en el fichero como si fuese en pantalla</p> <pre><code>import java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Ejemplo6 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter salida = null;\n\n        try {\n            salida = new PrintWriter(\"c:/ficheros/datos.txt\");\n            String cadena;\n\n            System.out.println(\"Introduce texto. Para acabar introduce la cadena FIN:\");\n            cadena = sc.nextLine();\n\n            while (!cadena.equalsIgnoreCase(\"FIN\")) {\n                salida.println(cadena);\n                cadena = sc.nextLine();\n            }\n\n            salida.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut10/1003_Ficheros.html#filereader","title":"FileReader","text":"<p>Para leer en un fichero de texto utilizaremos dos clases: <code>FileReader</code> (Lector de ficheros) y <code>BufferedReader</code> (Lector con buffer). La clase <code>FileReader</code> permite tener acceso al fichero en modo lectura. <pre><code>FileReaderfw = new FileReader (Path);\nFileReaderfw = new FileReader (File Objeto);\n</code></pre> Ambos lanzan una excepci\u00f3n <code>FileNotFoundException</code> si el fichero no existe. La clase <code>FileReader</code> proporciona el m\u00e9todo <code>read()</code> para leer caracteres del fichero aunque lo normal es realizar la lectura mediante la clase <code>BufferedReader</code>. Para leer utilizando la clase <code>BufferedReader</code> se debe crear un objeto <code>BufferedReader</code> a partir de un objeto <code>FileReader</code>. <pre><code>FileReader fr = new FileReader(\"c:/ficheros/datos.txt\"); \nBufferedReader entrada = new Buffered(fr); \n</code></pre> Una vez creado el objeto <code>BufferedReader</code> podemos utilizar: </p> <ul> <li>El m\u00e9todo <code>readLine()</code> para leer l\u00edneas de texto del fichero (String). Este m\u00e9todo devuelve null cuando no hay m\u00e1s l\u00edneas para leer. </li> <li>El m\u00e9todo <code>read()</code> para leer car\u00e1cter a car\u00e1cter. Devuelve un entero que representa el c\u00f3digo Unicode del car\u00e1cter le\u00eddo. Devuelve -1 si no hay m\u00e1s caracteres. </li> </ul> <p>Ambos m\u00e9todos lanzan una excepci\u00f3n <code>IOException</code> si ocurre un error de lectura. El fichero se debe cerrar cuando ya no se use, mediante el m\u00e9todo <code>close()</code>. Este m\u00e9todo lanza una excepci\u00f3n <code>IOException</code>.</p> <pre><code>import java.io.BufferedReader; // Para leer caracteres almacenados en un buffer\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Ejemplo7 {\n    public static void main(String[] args) {\n        FileReader fr = null;\n\n        try {\n            fr = new FileReader(\"c:/ficheros/datos.txt\");\n            BufferedReader entrada = new BufferedReader(fr);\n            String cadena = entrada.readLine();\n\n            while (cadena != null) {\n                System.out.println(cadena);\n                cadena = entrada.readLine();\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(e.getMessage());\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        } finally {\n            try {\n                if (fr != null) {\n                    fr.close();\n                }\n            } catch (IOException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut10/1003_Ficheros.html#flujos-de-datos-outputstream-y-inputstream","title":"Flujos de datos OutputStream y InputStream","text":""},{"location":"uutt/ut10/1003_Ficheros.html#outputstream","title":"OutputStream","text":"<p>Para escribir datos en un fichero binario utilizaremos las clases <code>FileOutputStream</code> (Flujo de salida de ficheros) y <code>DataOutputStream</code> (Flujo de salida de datos), derivadas de OutputStream (Flujo de salida).</p> <p>La clase <code>FileOutputStream</code> permite tener acceso al fichero para escribir bytes. El fichero se crea y si ya existe su contenido se pierde. Si lo que necesitamos es abrir un fichero binario existente sin perder su contenido y a\u00f1adir m\u00e1s contenido al final utilizaremos los constructores con el append correspondiente. <pre><code>FileOutputStream fos = new FileOutputStream (Path, append);\nFileOutputStream fos = new FileOutputStream (File Objeto, append);\n</code></pre> Los constructores lanzan una excepci\u00f3n FileNotFoundException si no existe y no se ha podido crear el fichero. La clase FileOutputStream proporciona el m\u00e9todo <code>write()</code> para escribir bytes en el fichero. Este m\u00e9todo lanza una <code>IOException</code>. </p> <p>A partir de un objeto FileOutputStream se puede crear un objeto DataOutputStream, que proporciona m\u00e9todos para escribir datos de tipo primitivo en el fichero. La clase proporciona m\u00e9todos <code>writeXxx()</code> donde Xxx es el nombre del tipo primitivo. Lanza una <code>IOException</code>.</p> <p>Ejemplo: Programa que lee enteros por teclado y los escribe en el fichero datos.dat. La lectura de datos acaba cuando se introduce -1.</p> <pre><code>import java.io.DataOutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Ejemplo12 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        FileOutputStream fos = null;\n        DataOutputStream salida = null;\n\n        try {\n            fos = new FileOutputStream(\"c:/ficheros/datos.dat\");\n            salida = new DataOutputStream(fos);\n\n            System.out.print(\"Introduce n\u00famero entero. -1 para acabar: \");\n            int n = sc.nextInt();\n\n            while (n != -1) {\n                salida.writeInt(n); // Se escribe el n\u00famero entero en el fichero\n                System.out.print(\"Introduce n\u00famero entero. -1 para acabar: \");\n                n = sc.nextInt();\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(e.getMessage());\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                if (salida != null) {\n                    salida.close();\n                }\n            } catch (IOException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut10/1003_Ficheros.html#inputstream","title":"InputStream","text":"<p>Para leer de un fichero binario utilizaremos las clases <code>FileInputStream</code> (Flujo de entrada de ficheros) y <code>DataInputStream</code> (Flujo de entrada de datos), derivadas de <code>InputStream</code> (Flujo de entrada).</p> <p>La clase <code>FileInputStream</code> permite leer bytes de un fichero. Ambos lanzan una excepci\u00f3n <code>FileNotFoundException</code> si el fichero no existe. La clase proporciona el m\u00e9todo <code>read()</code> para leer bytes del fichero. El m\u00e9todo read() lanza una excepci\u00f3n <code>IOException</code>.</p> <pre><code>FileInputStream fis = new FileInputStream (Path);\nFileInputStream fis = new FileInputStream (File Objeto);\n</code></pre> <p>La clase proporciona m\u00e9todos <code>readXxx()</code> donde Xxx es el nombre del tipo primitivo. Lanzan una excepci\u00f3n <code>IOException</code>.</p> <p>Ejemplo: Programa que lee el contenido del fichero creado en el ejemplo anterior. Utilizaremos un bucle infinito para leer datos. Cuando se llega al final del fichero se lanza la excepci\u00f3n EOFException que se utiliza para salir del bucle while.</p> <pre><code>import java.io.DataInputStream;\nimport java.io.EOFException;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class Ejemplo14 {\n    public static void main(String[] args) {\n        FileInputStream fis = null;\n        DataInputStream entrada = null;\n\n        try {\n            fis = new FileInputStream(\"c:/ficheros/datos.dat\");\n            entrada = new DataInputStream(fis);\n            int n;\n\n            while (true) {\n                n = entrada.readInt(); // Se lee un entero del fichero\n                System.out.println(n); // Se muestra en pantalla\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(e.getMessage());\n        } catch (EOFException e) {\n            System.out.println(\"Fin de fichero\");\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        } finally {\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n                if (entrada != null) {\n                    entrada.close();\n                }\n            } catch (IOException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut10/1003_Ficheros.html#lectura-y-escritura-aleatoria-en-un-archivo","title":"Lectura y escritura aleatoria en un archivo","text":"<p>La clase <code>RandomAccessFile</code> (Fichero de acceso aleatorio) se utiliza para acceder a un fichero sobre cualquier posici\u00f3n. <pre><code>RandomAccessFile fichero = new RandomAccessFile(\"ruta\", \"modo\");\nRandomAccessFile fichero = new RandomAccessFile(Objeto, \"modo\");\n</code></pre> Lanzan una excepci\u00f3n <code>FileNotFoundException</code>. El argumento mode indica el modo de acceso en el que se abre el fichero. Los valores permitidos para este par\u00e1metro son:</p> Modo Significado <code>r</code> Abre el fichero en modo solo lectura. El fichero debe existir. Una operaci\u00f3n de escritura en este fichero lanzar\u00e1 una excepci\u00f3n <code>IOException</code>. <code>rw</code> Abre el fichero en modo lectura y escritura. Si el fichero no existe se intentar\u00e1 crear. <p>Abrir un fichero aleatorio para lectura. Se abre el fichero clientes.dat para lectura usando el primer constructor.  <pre><code>RandomAccessFile fichero = new RandomAccessFile(\"/ficheros/clientes.dat\", \"r\"); \n</code></pre> Abrir un fichero aleatorio para lectura/escritura. Se abre el fichero personas.dat para lectura/escritura usando el segundo constructor. Si el fichero no existe se crea.  <pre><code>File f = new File (\"/ficheros/personas.dat\"); \nRandomAccessFile fichero = new RandomAccessFile(f, \"rw\")\n</code></pre></p> M\u00e9todo Significado <code>long getFilePointer()</code> Devuelve la posici\u00f3n actual del puntero del fichero. Indica la posici\u00f3n (en bytes) donde se va a leer o escribir. <code>long length()</code> Devuelve la longitud del fichero en bytes. <code>void seek(long pos)</code> Coloca el puntero del fichero en una posici\u00f3n <code>pos</code> determinada. La posici\u00f3n se da como un desplazamiento en bytes desde el comienzo del fichero. La posici\u00f3n <code>0</code> indica el principio del fichero y la posici\u00f3n <code>length()</code> indica el final del fichero. <code>int read()</code> Devuelve el byte le\u00eddo en la posici\u00f3n marcada por el puntero. Devuelve <code>-1</code> si alcanza el final del fichero. Se debe utilizar este m\u00e9todo para leer los caracteres de un fichero de texto. <code>final String readLine()</code> Devuelve la cadena de caracteres que se lee, desde la posici\u00f3n marcada por el puntero, hasta el siguiente salto de l\u00ednea que se encuentre. El modificador <code>final</code> indica que no puede ser sobrescrito. <code>xxx readXxx()</code> Hay un m\u00e9todo <code>read</code> para cada tipo de dato b\u00e1sico: <code>readChar</code>, <code>readInt</code>, <code>readDouble</code>, <code>readBoolean</code>, etc. <code>void write(int b)</code> Escribe en el fichero el byte indicado por par\u00e1metro. Se debe utilizar este m\u00e9todo para escribir caracteres en un fichero de texto. <code>final void writeBytes(String s)</code> Escribe en el fichero la cadena de caracteres indicada por par\u00e1metro. <code>final void writeXxx(argumento)</code> Tambi\u00e9n existe un m\u00e9todo <code>write</code> para cada tipo de dato b\u00e1sico: <code>writeChar</code>, <code>writeInt</code>, <code>writeDouble</code>, <code>writeBoolean</code>, etc. Ejemplo 1Ejemplo 2 <p>Programa que pide un n\u00famero entero por teclado y lo a\u00f1ade al final de un fichero binario enteros.dat que contiene n\u00fameros enteros. El programa utiliza el m\u00e9todo mostrarFichero() que se llama dos veces. La primera muestra el contenido del fichero antes de a\u00f1adir el nuevo n\u00famero y la segunda llamada muestra el fichero despu\u00e9s de a\u00f1adirlo.</p> <pre><code>import java.io.EOFException;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.util.Scanner;\n\npublic class Ejemplo16 {\n    static Scanner sc = new Scanner(System.in);\n    static RandomAccessFile fichero = null;\n\n    public static void main(String[] args) {\n        int numero;\n\n        try {\n            // Se abre el fichero para lectura y escritura\n            fichero = new RandomAccessFile(\"c:/ficheros/enteros.dat\", \"rw\");\n\n            mostrarFichero(); // Muestra el contenido original del fichero\n\n            System.out.print(\"Introduce un n\u00famero entero para a\u00f1adir al final del fichero: \");\n            numero = sc.nextInt(); // Se lee el entero a a\u00f1adir en el fichero\n\n            fichero.seek(fichero.length()); // Nos situamos al final del fichero\n            fichero.writeInt(numero); // Se escribe el entero\n\n            mostrarFichero(); // Muestra el contenido del fichero despu\u00e9s de a\u00f1adir el n\u00famero\n\n            fichero.close();\n        } catch (FileNotFoundException ex) {\n            System.out.println(ex.getMessage());\n        } catch (IOException ex) {\n            System.out.println(ex.getMessage());\n        }\n    }\n    // M\u00e9todo para mostrar los datos del fichero\n    public static void mostrarFichero() {\n        int n;\n\n        try {\n            fichero.seek(0); // Nos situamos al principio del fichero\n            while (true) {\n                n = fichero.readInt(); // Se lee un entero del fichero\n                System.out.println(n); // Se muestra en pantalla\n            }\n        } catch (EOFException e) {\n            System.out.println(\"Fin de fichero\");\n        } catch (IOException ex) {\n            System.out.println(ex.getMessage());\n        }\n    }\n}\n</code></pre> <p>Programa Java para modificar un entero dentro del fichero enteros.dat con acceso aleatorio. Para ello se pide la posici\u00f3n que ocupa el entero a modificar dentro del fichero, a continuaci\u00f3n, se lee y muestra el valor actual, se pide el nuevo valor y finalmente se escribe el nuevo valor en la posici\u00f3n indicada, modificando de esta forma el valor antiguo por el nuevo. La posici\u00f3n deber\u00e1 estar comprendida entre 1 y el n\u00famero de enteros que contiene el fichero. La cantidad de enteros que contiene el fichero se calcula as\u00ed:</p> <pre><code>import java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.util.Scanner;\n\npublic class Ejemplo17 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        RandomAccessFile fichero = null;\n        int pos, numero;\n        long size;\n\n        try {\n            // Abrir el fichero para lectura y escritura\n            fichero = new RandomAccessFile(\"c:/ficheros/enteros.dat\", \"rw\");\n\n            // Calcular cu\u00e1ntos enteros tiene el fichero\n            size = fichero.length();\n            size = size / 4; // Cada entero ocupa 4 bytes\n            System.out.println(\"El fichero tiene \" + size + \" enteros\");\n\n            // Modificar el entero que se encuentra en una posici\u00f3n determinada\n            do {\n                System.out.println(\"Introduce una posici\u00f3n (&gt;= 1 y &lt;= \" + size + \"): \");\n                pos = sc.nextInt();\n            } while (pos &lt; 1 || pos &gt; size);\n\n            pos--; // Ajustar a la indexaci\u00f3n 0 (la posici\u00f3n 1 realmente es la 0)\n\n            // Nos situamos en la posici\u00f3n (byte de inicio) del entero a modificar\n            fichero.seek(pos * 4); // Cada entero ocupa 4 bytes\n\n            // Leemos y mostramos el valor actual\n            System.out.println(\"Valor actual: \" + fichero.readInt());\n\n            // Pedimos que se introduzca el nuevo valor\n            System.out.println(\"Introduce nuevo valor: \");\n            numero = sc.nextInt();\n\n            // Nos situamos de nuevo en la posici\u00f3n del entero a modificar\n            fichero.seek(pos * 4);\n\n            // Escribimos el entero\n            fichero.writeInt(numero);\n\n            fichero.close();\n        } catch (FileNotFoundException ex) {\n            System.out.println(ex.getMessage());\n        } catch (IOException ex) {\n            System.out.println(ex.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut10/1003_Ficheros.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 1012 (RA6 / IC1 / 3p). Dise\u00f1a un programa que muestre \u00fanicamente los ficheros de un directorio cuya primera letra sea \u201cA\u201d. Para ello deber\u00e1s crear primero una clase llamada FiltroPrimeraLetra, la cual implemente la interface FilenameFilter.</p> </li> <li> <p>AC 1013 (RA6 / IC1 / 3p). Escribe un programa que escriba los 100 primeros n\u00fameros naturales en un archivo de nombre numNaturales.txt Escribe un programa que utilice un m\u00e9todo, de nombre obtenerSumaNumerosArchivo, que reciba por par\u00e1metro el nombre del archivo numNaturales.txt con la serie de cantidades enteras y positivas. El m\u00e9todo leer\u00e1 todos los valores del archivo, calcular\u00e1 su suma y la devolver\u00e1.</p> </li> <li> <p>AC 1014 (RA6 / IC1 / 3p). Escribe un programa que contenga un m\u00e9todo, de nombre escribirCadenasEnArchivo, que reciba un array de cadenas de caracteres y vuelque su contenido a un archivo cuyo nombre tambi\u00e9n se recibir\u00e1 por par\u00e1metro. Las cadenas quedar\u00e1n separadas en el archivo por un gui\u00f3n bajo.</p> </li> <li> <p>PR 1015 (RA6 / IC1 / 5p). A partir del fichero empleados.csv que contiene los empleados de una empresa multinacional. Los nombres de los campos est\u00e1n en la primera linea y los valores separados por comas.</p> <ul> <li>a. Importa adecuadamente los datos del fichero proporcionado de forma que cada empleado ser\u00e1 un objeto que se almacenar\u00e1 en una colecci\u00f3n adecuada.</li> <li> <p>b. Genera el correo de todos los empleados independientemente del que tengan.</p> <p>Ejemplo</p> <ul> <li><code>formato: nombre.apellidos@location.multinacional.com</code></li> <li>Nombre y apellidos en min\u00fasculas.</li> <li> <p>Location: en min\u00fascula y si hay espacios los sustituyes por guiones.</p> <p>Ejemplo</p> <p>Jhon Doe New York --&gt; jhon.doe@new-york.multinacional.com</p> </li> </ul> </li> <li> <p>c. Completa el tel\u00e9fono de los empleados que no tienen pidi\u00e9ndolos por consola. Comprueba adecuadamente el formato de todos los email y tel\u00e9fonos.</p> </li> <li>d. El programa deber\u00e1 permitir contar los empleados de cada departamento y ciudad, pidiendo el departamento o ciudad por consola. </li> <li>e. El programa deber\u00e1 mostrar los empleados de mayor y menor edad de cada departamento y ciudad, pidiendo el departamento o ciudad por consola.</li> <li>f. El programa deber\u00e1 generar un listado de texto plano, ordenado por apellido, solamente con los empleados del departamento o la ciudad indicados por el usuario. El fichero deber\u00e1 llamarse como el departamento o la ciudad indicados.</li> </ul> </li> <li> <p>PR 1016 (RA6 / IC1 / 5p) A partir del fichero coches.csv que contiene los datos de coches de un concesionario de venta de segunda mano. Los nombres de los campos est\u00e1n en la primera l\u00ednea y los valores separados por comas.</p> <ul> <li>a. Importa adecuadamente los datos del fichero proporcionado de forma que cada coche ser\u00e1 un objeto que se almacenar\u00e1 en una colecci\u00f3n adecuada.</li> <li>b. Calcula el precio final de cada coche aplicando el descuento en caso de que lo tenga, y los impuestos que son del 21% si el coche tiene 20 a\u00f1os o menos y del 10% si tiene m\u00e1s.</li> <li>c. El programa deber\u00e1 permitir guardar la colecci\u00f3n que contiene los coches del concesionario en un fichero binario, es decir, guardo y recupero el objeto colecci\u00f3n que contiene todos los coches. Guardar\u00e1 los coches de la Marca indicada por consola y los que tengan menos de los km indicados, ordenados adecuadamente.</li> <li>d. El programa deber\u00e1 de permitir recuperar el fichero binario guardado en el apartado anterior, llevarlo a la colecci\u00f3n adecuada y mostrarlo por pantalla.</li> <li>e. El programa deber\u00e1 permitir guardar los coches individuales del concesionario en un fichero binario, es decir, recorro la colecci\u00f3n y guardo los coches uno a uno. Guardar\u00e1 los coches del tipo de combustible indicado y los que tengan un precio menor que el indicado, ordenados adecuadamente.</li> <li>f. El programa deber\u00e1 permitir recuperar el fichero binario guardado en el apartado anterior, llevarlo a la colecci\u00f3n adecuada y mostrarlo por pantalla.</li> </ul> </li> </ul>"},{"location":"uutt/ut10/1004_StringBufferStringBuilder.html","title":"La clase StringBuffer y StringBuilder","text":"<p>Java provee distintas clases para el trabajo con cadenas de texto. La m\u00e1s b\u00e1sica, la clase String. Sin embargo existen otras clases como <code>StringBuffer</code> y <code>StringBuilder</code> que resultan de inter\u00e9s porque facilitan cierto tipo de trabajos y aportan mayor eficiencia en determinados contextos.</p>"},{"location":"uutt/ut10/1004_StringBufferStringBuilder.html#stringbuilder","title":"StringBuilder","text":"<p>La clase <code>StringBuilder</code> es similar a la clase <code>String</code> en el sentido de que sirve para almacenar cadenas de caracteres. No obstante, presenta algunas diferencias relevantes. Se\u00f1alaremos como caracter\u00edsticas de <code>StringBuilder</code> a tener en cuenta:</p> <ul> <li>Su tama\u00f1o y contenido pueden modificarse. Los objetos de \u00e9ste tipo son mutables. Esto es una diferencia con los String.</li> <li>Debe crearse con alguno de sus constructores asociados. No se permite instanciar directamente a una cadena como s\u00ed permiten los String.</li> <li>Un <code>StringBuilder</code> est\u00e1 indexado. Cada uno de sus caracteres tiene un \u00edndice: 0 para el primero,1 para el segundo, etc.</li> <li>Los m\u00e9todos de <code>StringBuilder</code> no est\u00e1n sincronizados. Esto implica que es m\u00e1s eficiente que StringBuffer siempre que no se requiera trabajar con m\u00faltiples hilos (threads), que es lo m\u00e1s habitual.</li> </ul> <p>Los constructores de <code>StringBuilder</code> se resumen en la siguiente tabla:</p> Constructor Descripci\u00f3n Ejemplo <code>StringBuilder()</code> Construye un <code>StringBuilder</code> vac\u00edo y con una capacidad por defecto de 16 caracteres. <code>StringBuilder s = new StringBuilder();</code> <code>StringBuilder(int capacidad)</code> Se le pasa la capacidad (n\u00famero de caracteres) como argumento. <code>StringBuilder s = new StringBuilder(55);</code> <code>StringBuilder(String str)</code> Construye un <code>StringBuilder</code> en base al <code>String</code> que se le pasa como argumento. <code>StringBuilder s = new StringBuilder(\"hola\");</code> <p>Los m\u00e9todos principales de <code>StringBuilder</code> se resumen en la siguiente tabla:</p> Retorno M\u00e9todo Explicaci\u00f3n <code>StringBuilder</code> <code>append(...)</code> A\u00f1ade al final del <code>StringBuilder</code> un <code>String</code> o la representaci\u00f3n en forma de <code>String</code> de un dato asociado a una variable primitiva. <code>int</code> <code>capacity()</code> Devuelve la capacidad del <code>StringBuilder</code>. <code>int</code> <code>length()</code> Devuelve el n\u00famero de caracteres del <code>StringBuilder</code>. <code>StringBuilder</code> <code>reverse()</code> Invierte el orden de los caracteres del <code>StringBuilder</code>. <code>void</code> <code>setCharAt(int indice, char ch)</code> Cambia el car\u00e1cter indicado en el primer argumento por el car\u00e1cter que se le pasa en el segundo. <code>char</code> <code>charAt(int indice)</code> Devuelve el car\u00e1cter asociado a la posici\u00f3n que se le indica en el argumento. <code>void</code> <code>setLength(int nuevaLongitud)</code> Modifica la longitud. La nueva longitud no puede ser menor que la longitud actual. <code>String</code> <code>toString()</code> Convierte un <code>StringBuilder</code> en un <code>String</code>. <code>StringBuilder</code> <code>insert(int indiceIni, String cadena)</code> A\u00f1ade la cadena del segundo argumento a partir de la posici\u00f3n indicada en el primero. <code>StringBuilder</code> <code>delete(int indiceIni, int indiceFin)</code> Borra la cadena de caracteres incluidos entre los dos \u00edndices indicados en los argumentos. <code>StringBuilder</code> <code>deleteCharAt(int indice)</code> Borra el car\u00e1cter indicado en el \u00edndice. <code>StringBuilder</code> <code>replace(int indiceIni, int indiceFin, String str)</code> Reemplaza los caracteres comprendidos entre los dos \u00edndices por la cadena que se le pasa en el argumento. <code>int</code> <code>indexOf(String str)</code> Analiza los caracteres de la cadena y encuentra el primer \u00edndice que coincide con el valor deseado. <code>String</code> <code>substring(int indiceIni, int indiceFin)</code> Devuelve una cadena comprendida entre los dos \u00edndices."},{"location":"uutt/ut10/1004_StringBufferStringBuilder.html#stringbuffer","title":"StringBuffer","text":"<p>La clase StringBuffer es similar a la clase <code>StringBuilder</code>, siendo la principal diferencia que sus m\u00e9todos est\u00e1n sincronizados, lo cual permite trabajar con m\u00faltiples hilos de ejecuci\u00f3n (<code>threads</code>).</p> <p>Los constructores y m\u00e9todos de <code>StringBuffer</code> son los mismos que los de <code>StringBuilder</code>.</p> Constructor Descripci\u00f3n Ejemplo <code>StringBuffer()</code> Construye un <code>StringBuffer</code> vac\u00edo y con una capacidad por defecto de 16 caracteres. <code>StringBuffer s = new StringBuffer();</code> <code>StringBuffer(int capacidad)</code> Se le pasa la capacidad (n\u00famero de caracteres) como argumento. <code>StringBuffer s = new StringBuffer(55);</code> <code>StringBuffer(String str)</code> Construye un <code>StringBuffer</code> en base al <code>String</code> que se le pasa como argumento. <code>StringBuffer s = new StringBuffer(\"hola\");</code>"},{"location":"uutt/ut10/1004_StringBufferStringBuilder.html#diferencias-entre-string-stringbuilder-y-stringbuffer","title":"Diferencias entre string, stringbuilder y stringbuffer","text":"<p>Vamos a enumerar las principales diferencias entre estas tres clases:</p> <ul> <li><code>StringBuffer</code> y <code>StringBuilder</code> son mutables, mientras que <code>String</code> es inmutable. Cada vez que modificamos un <code>String</code> se crea un objeto nuevo. Esto no ocurre con <code>StringBuffer</code> y <code>StringBuilder</code>.</li> <li>Los objetos <code>String</code> se almacenan en el <code>Constant String Pool</code> que es un repositorio o almac\u00e9n de cadenas, de valores de Strings. Esto se hace  con el fin de que si creamos otro <code>String</code>, con el mismo valor, no se cree un nuevo objeto sino que se use el mismo y se asigne una referencia al objeto ya creado. Los objetos <code>StringBuffer</code> y <code>StringBuilder</code> se almacenan en el heap que es otro espacio de memoria usado en tiempo de ejecuci\u00f3n para almacenar las instancias de clases, objetos y arrays. Realmente no nos interesa entrar a nivel de detalle en estas diferencias: simplemente, recordar que los objetos <code>String</code> tienen diferente tratamiento que los <code>StringBuffer</code> y <code>StringBuilder</code>.</li> <li>La  implementaci\u00f3n de la clase <code>StringBuffer</code> es sincronizada, la de <code>StringBuilder</code> no. </li> <li>El operador de concatenaci\u00f3n \"+\" es implementado internamente por Java usando <code>StringBuilder</code>.</li> </ul>"},{"location":"uutt/ut10/1004_StringBufferStringBuilder.html#actividades","title":"Actividades","text":"<ul> <li> <p>PR 1017 (RA6 / IC1 / 5p). Crea un programa que reciba una frase de entrada del usuario y realice las siguientes operaciones utilizando las clases StringBuffer y StringBuilder:</p> <ol> <li> <p>Uso de StringBuilder:</p> <ol> <li>Crear un objeto de la clase StringBuilder con la frase ingresada.</li> <li> <p>Realizar las siguientes operaciones sobre la cadena usando StringBuilder:</p> <ul> <li>A\u00f1adir al final de la frase la palabra \"\u00a1Bienvenido!\".</li> <li>Invertir la cadena resultante.</li> <li>Reemplazar todas las vocales de la cadena por el s\u00edmbolo '*'.</li> </ul> </li> </ol> </li> <li> <p>Uso de StringBuffer:</p> <ol> <li>Crear un objeto de la clase StringBuffer con la frase original.</li> <li> <p>Realizar las siguientes operaciones sobre la cadena usando StringBuffer:</p> <ul> <li>Insertar al principio de la frase la palabra \"Saludo: \".</li> <li>Eliminar las primeras 5 letras de la cadena.</li> <li>Convertir todos los caracteres a may\u00fasculas.</li> </ul> </li> </ol> <p>Requisitos:</p> <ul> <li>Aseg\u00farate de que el programa maneje excepciones si el usuario introduce datos incorrectos o vac\u00edos.</li> <li>El programa debe mostrar la cadena resultante despu\u00e9s de cada operaci\u00f3n realizada con StringBuilder y StringBuffer.</li> <li>Comenta el c\u00f3digo explicando las funciones de cada parte del programa.</li> </ul> </li> </ol> </li> </ul>"},{"location":"uutt/ut10/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 10","text":""},{"location":"uutt/ut10/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA6.CE <ul> <li>Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos.</li> </ul> <ul> <li>a. Se han escrito programas que utilicen matrices (arrays).</li> <li>b. Se han reconocido las librer\u00edas de clases relacionadas con tipos de datos avanzados.</li> <li>c. Se han utilizado listas para almacenar y procesar informaci\u00f3n.</li> <li>d. Se han utilizado iteradores para recorrer los elementos de las listas.</li> <li>e. Se han reconocido las caracter\u00edsticas y ventajas de cada una de las colecciones de datos disponibles.</li> <li>f. Se han creado clases y m\u00e9todos gen\u00e9ricos.</li> <li>g. Se han utilizado expresiones regulares en la b\u00fasqueda de patrones en cadenas de texto.</li> <li>h. Se han identificado las clases relacionadas con el tratamiento de documentos escritos en diferentes lenguajes de intercambio de datos.</li> <li>i. Se han realizado programas que realicen manipulaciones sobre documentos escritos en diferentes lenguajes de intercambio de datos.</li> <li>j. Se han utilizado operaciones agregadas para el manejo de informaci\u00f3n almacenada en colecciones.</li> </ul>"},{"location":"uutt/ut10/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p>"},{"location":"uutt/ut10/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>04/03/2025</p> <p></p> <p></p> <p>02</p> <p>05/03/2025</p> <p></p> <p></p> <p>03</p> <p>05/03/2025</p> <p></p> <p></p> <p>04</p> <p>06/03/2025</p> <p></p> <p></p> <p>05</p> <p>06/03/2025</p> <p></p> <p></p> <p>06</p> <p>07/03/2025</p> <p></p> <p></p> <p>07</p> <p>10/03/2025</p> <p></p> <p></p> <p>08</p> <p>10/03/2025</p> <p></p> <p></p> <p>09</p> <p>11/03/2025</p> <p></p> <p></p> <p>10</p> <p>12/03/2025</p> <p></p> <p></p> <p>11</p> <p>12/03/2025</p> <p></p> <p></p> <p>12</p> <p>13/03/2025</p> <p></p> <p></p> <p>13</p> <p>13/03/2025</p> <p></p> <p></p> <p>14</p> <p>14/03/2025</p> <p></p> <p></p> <p>15</p> <p>20/03/2025</p> <p></p> <p>PO UT 10</p> <p>16</p> <p>20/03/2025</p> <p></p> <p>PO UT 10</p>"},{"location":"uutt/ut10/ResumenUT.html#referencias","title":"Referencias","text":""},{"location":"uutt/ut10/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":""},{"location":"uutt/ut11/1101_Persistencia.html","title":"Persistencia de datos","text":"<p>La persistencia es la capacidad de guardar el estado de un objeto en alg\u00fan tipo de almacenamiento, para poder restaurarlo en alg\u00fan momento posteriormente.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#xml","title":"XML","text":"<p>XML es la abreviatura de Extensible Markup Language y es un formato de intercambio de datos establecido. XML fue definido en 1998 por el World Wide Web Consortium (W3C). A diferencia de otros lenguajes, XML da soporte a bases de datos, siendo \u00fatil cuando varias aplicaciones deben comunicarse entre s\u00ed o integrar informaci\u00f3n.</p> <p>Un documento XML consta de elementos, cada elemento tiene una etiqueta de inicio, contenido y una etiqueta de finalizaci\u00f3n. Una etiqueta consiste en una marca hecha en el documento, que se\u00f1ala una porci\u00f3n de este como un elemento. Un pedazo de informaci\u00f3n con un sentido claro y definido. Las etiquetas tienen la forma <code>&lt;nombre&gt;</code>, donde nombre es el nombre del elemento que se est\u00e1 se\u00f1alando.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#documento-xml-valido","title":"Documento XML v\u00e1lido","text":"<p>Los documentos denominados como \u00abbien formados\u00bb (del ingl\u00e9s well formed) son aquellos que cumplen con todas las definiciones b\u00e1sicas de formato y pueden, por lo tanto, analizarse correctamente por cualquier analizador sint\u00e1ctico (parser) que cumpla con la norma. Esto significa que debe aplicarse a las siguientes condiciones:</p> <ol> <li>Cada etiqueta de apertura tiene una etiqueta de cierre.</li> <li>Todas las etiquetas est\u00e1n completamente anidadas.</li> <li>Los documentos XML solamente permiten un elemento ra\u00edz del que todos los dem\u00e1s sean parte, es decir, solo pueden tener un elemento inicial.</li> <li>El XML es sensible a may\u00fasculas y min\u00fasculas.</li> </ol>"},{"location":"uutt/ut11/1101_Persistencia.html#partes-de-un-documento-xml","title":"Partes de un documento XML","text":""},{"location":"uutt/ut11/1101_Persistencia.html#prologo","title":"Pr\u00f3logo","text":"<p>Aunque no es obligatorio, los documentos XML pueden empezar con unas l\u00edneas que describen la versi\u00f3n XML, el tipo de documento y otras cosas.</p> <p>El pr\u00f3logo de un documento XML contiene:</p> <ul> <li>Una declaraci\u00f3n XML. Es la sentencia que declara al documento como un documento XML.</li> <li>Una declaraci\u00f3n de tipo de documento. Enlaza el documento con su DTD (definici\u00f3n de tipo de documento), o el DTD puede estar incluido en la propia declaraci\u00f3n o ambas cosas al mismo tiempo.</li> <li>Uno o m\u00e1s comentarios e instrucciones de procesamiento. Ejemplo: <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n</code></pre></li> </ul>"},{"location":"uutt/ut11/1101_Persistencia.html#cuerpo","title":"Cuerpo","text":"<p>A diferencia del pr\u00f3logo, el cuerpo no es opcional en un documento XML, el cuerpo debe contener solo un elemento ra\u00edz, caracter\u00edstica indispensable tambi\u00e9n para que el documento est\u00e9 bien formado. Sin embargo es necesaria la adquisici\u00f3n de datos para su buen funcionamiento.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#elementos","title":"Elementos","text":"<p>Los elementos XML pueden tener contenido (m\u00e1s elementos, caracteres o ambos), o bien ser elementos vac\u00edos.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#atributos","title":"Atributos","text":"<p>Los elementos pueden tener atributos, que son una manera de incorporar caracter\u00edsticas o propiedades a los elementos de un documento. Deben ir entre comillas. <pre><code>&lt;person sex=\"male\"&gt;\n    &lt;firstname&gt;Luffy&lt;/firstname&gt;\n    &lt;lastname&gt;D. Monkey&lt;/lastname&gt;\n&lt;/person&gt;\n</code></pre> En el ejemplo, el elemento <code>person</code> tiene un atributo <code>sex</code>.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#comentarios","title":"Comentarios","text":"<p>Comentarios a modo informativo para el programador que han de ser ignorados por el procesador. Los comentarios en XML tienen el siguiente formato: <pre><code>&lt;!-- Comment --&gt;\n</code></pre></p>"},{"location":"uutt/ut11/1101_Persistencia.html#java-xml","title":"Java XML","text":"<p>Java permite usar analizadores XMLpara leer y escribir documentos XML; Adem\u00e1s, JAXB para convertir XML a/desde objetos. En general, existen dos modelos para trabajar con documentos XML: DOM y SAX.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#dom","title":"DOM","text":"<p>El modelo de objeto de documento (DOM) utiliza nodos para representar los documentos XML completos como una estructura de \u00e1rbol y almacenarlos en la memoria. DOM es bueno para manipular el archivo XML peque\u00f1o, como leer, escribir y modificar la estructura XML; DOM NO es para analizar o manipular archivos XML grandes porque construir la estructura XML completa en la memoria consume mucha memoria.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#sax","title":"SAX","text":"<p>La API simple para XML (SAX) permite leer el archivo XML de principio a fin, es decir, de manera secuencial.</p> <p>El SAX es r\u00e1pido y eficiente, requiere mucha menos memoria que DOM porque SAX no crea una representaci\u00f3n interna (estructura de \u00e1rbol) de los datos XML, como lo hace un DOM.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#stax","title":"StAX","text":"<p>Streaming API for XML (StAX) est\u00e1 basado en eventos, permite leer y escribir documentos XML. StAX ofrece un modelo de programaci\u00f3n m\u00e1s simple que SAX y una gesti\u00f3n de memoria m\u00e1s eficiente que DOM.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#ejemplos-con-inputstream-y-outputstream","title":"Ejemplos con InputStream y OutputStream","text":"CargaEscritura <pre><code>private static Document loadXMLDocument(String url) {\n    try (InputStream input = new URL(url).openStream()) {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        return builder.parse(input);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n</code></pre> <pre><code>private static void writeXml(Document doc, OutputStream output) throws TransformerException {\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\n    Transformer transformer = transformerFactory.newTransformer();\n    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n    DOMSource source = new DOMSource(doc);\n    StreamResult result = new StreamResult(output);\n    transformer.transform(source, result);\n}\n</code></pre>"},{"location":"uutt/ut11/1101_Persistencia.html#json","title":"JSON","text":"<p>JSON (JavaScript Object Notation) es un formato ligero de intercambio de datos. Es un fichero f\u00e1cil de leer y escribir para los humanos y tambi\u00e9n f\u00e1cil de analizar y generar para las m\u00e1quinas. Se basa en un subconjunto del lenguaje de programaci\u00f3n JavaScript. Debido a su amplia adopci\u00f3n como alternativa a XML. JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones que son ampliamente conocidos por los programadores de la familia de lenguajes C, incluyendo C, C++, C#, Java, JavaScript, Perl, Python, y muchos otros. Estas propiedades hacen que JSON sea un lenguaje ideal para el intercambio de datos.</p> <p>JSON se basa en dos estructuras que son universales; virtualmente todos los lenguajes de programaci\u00f3n las soportan de una forma u otra:</p> <ul> <li>Una colecci\u00f3n de pares de name/value. En varios lenguajes, esto se realiza como un objeto, registro, estructura, diccionario, tabla hash, lista con clave o matriz asociativa.</li> <li>Una lista ordenada de valores. En la mayor\u00eda de los lenguajes, esto se realiza como una matriz, vector, lista o secuencia.</li> </ul>"},{"location":"uutt/ut11/1101_Persistencia.html#tipos-de-datos-disponibles","title":"Tipos de datos disponibles","text":"<ol> <li>N\u00fameros: Se permiten n\u00fameros negativos y opcionalmente pueden contener parte decimal separada por puntos. Ejemplo: 123.456</li> <li>Cadenas: Representan secuencias de cero o m\u00e1s caracteres. Se ponen entre doble comillas y se permiten cadenas de escape. Ejemplo: \"Hola\"</li> <li>Booleanos: Representan valores booleanos y pueden tener dos valores: true y false</li> <li>null: Representan el valor nulo.</li> <li>Array: Representa una lista ordenada de cero o m\u00e1s valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes.</li> <li>Objetos: Son colecciones no ordenadas de pares de la forma <code>nombre:valor</code> separados por comas y puestas entre llaves. El nombre tiene que ser una cadena entre comillas dobles. El valor puede ser de cualquier tipo.</li> </ol>"},{"location":"uutt/ut11/1101_Persistencia.html#formato-json","title":"Formato JSON","text":"<ul> <li>Un objeto es un conjunto desordenado de pares de name/value. Un objeto comienza con <code>{</code>(llave izquierda) y termina con <code>}</code>(llave derecha). Cada nombre va seguido de <code>:</code> (dos puntos) y los pares de name/value est\u00e1n separados por <code>,</code> (coma).</li> </ul> <ul> <li>Un array es una colecci\u00f3n ordenada de valores. Una matriz comienza con <code>[</code>(corchete izquierdo) y termina con <code>]</code> (corchete derecho). Los valores est\u00e1n separados por <code>,</code>(coma).</li> </ul> <ul> <li>Un value puede ser una cadena entre comillas dobles, un n\u00famero, verdadero, falso, nulo, un objeto o una matriz. Estas estructuras se pueden anidar.</li> </ul>"},{"location":"uutt/ut11/1101_Persistencia.html#java-json","title":"Java JSON","text":"<p>Java por defecto no ofrece ninguna funcionalidad integrada para analizar o crear JSON, en lugar de eso, tendremos que confiar en una biblioteca/paquete de terceros. En la actualidad existen varias librer\u00edas para pasar transformar un objeto Java en una cadena JSON (serializaci\u00f3n) o viceversa (deserializaci\u00f3n).</p> <p>Desde la p\u00e1gina en donde se encuentra la especificaci\u00f3n de JSON se indican las librer\u00edas m\u00e1s conocidas para tratar/generar informaci\u00f3n relativa al formato JSON en los diferentes lenguajes de programaci\u00f3n. Vamos a ver c\u00f3mo parsear un JSON utilizando el paquete org.json. Los archivos en este paquete implementan codificadores/decodificadores JSON en Java.</p> <pre><code>// Este m\u00e9todo accede a una URL y descarga el contenido en forma de String\npublic static String stream(String url) {\n    try (InputStream input = new URL(url).openStream()) {\n        InputStreamReader isr = new InputStreamReader(input);\n        BufferedReader reader = new BufferedReader(isr);\n        StringBuilder json = new StringBuilder();\n        int c;\n        while ((c = reader.read()) != -1) {\n            json.append((char) c);\n        }\n        return json.toString();\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n\npublic static void main(String[] args) {\n    String caturl = \"https://catfact.ninja/facts\";\n\n    // Parseamos un string a un JSONObject\n    JSONObject jsonObject = new JSONObject(stream(caturl));\n    JSONArray a = jsonObject.getJSONArray(\"data\");\n    JSONObject o = (JSONObject) a.get(0);\n    System.out.println(o.getString(\"fact\"));\n}\n</code></pre> <p>Un <code>JSONObject</code> es una colecci\u00f3n desordenada de pares clave y valor, que se asemeja a las implementaciones Map nativas de Java.</p>"},{"location":"uutt/ut11/1101_Persistencia.html#bases-de-datos","title":"Bases de datos","text":"<p>Una base de datos es una herramienta que recopila datos, los organiza y los relaciona para que se pueda hacer una r\u00e1pida b\u00fasqueda y recuperar con ayuda de un ordenador. Hoy en d\u00eda, las bases de datos tambi\u00e9n sirven para desarrollar an\u00e1lisis. Las bases de datos m\u00e1s modernas tienen motores espec\u00edficos para sacar informes de datos complejos.</p> <p>Adem\u00e1s, es importante saber que hay varios tipos de base de datos: la relacional; la distribuida; NoSQL; orientada a objetos; y, gr\u00e1ficas. La existencia de estas diversas bases de datos se debe a la variedad de forma de trabajo que se requiere de ellas.</p> <p>Las bases de datos relacionales representan la informaci\u00f3n en forma de tablas, con filas y columnas que se relacionan mediante campos clave. Adem\u00e1s se trabaja con el lenguaje est\u00e1ndar conocido como SQL, para poder realizar las consultas que deseemos a la base de datos.</p> <p>El sistema gestor de bases de datos, en ingl\u00e9s conocido como: Database Management System (DBMS), gestiona el modo en que los datos se almacenan, mantienen y recuperan. En el caso de una base de datos relacional, el sistema gestor de base de datos se denomina: Relational Database Management System (RDBMS).</p>"},{"location":"uutt/ut11/1102_DesfaseObjetoRelacional.html","title":"Desfase objeto - relacional","text":"<p>Las bases de datos relacionales no est\u00e1n dise\u00f1adas para almacenar objetos, ya que existe un desfase entre las construcciones t\u00edpicas que proporciona el modelo relacional y las proporcionadas por la programaci\u00f3n basada en objetos.</p> <p>El desfase objeto-relacional consiste en la diferencia de aspectos que existen entre la programaci\u00f3n orientada a objetos y la base de datos.</p> <p>Hay que recordar que el modelo relacional trata con relaciones y conjuntos y que, en las BD relacionales tenemos reglas de integridad:</p> <ul> <li>Todas las tablas deben tener una clave primaria</li> <li>La clave primaria tiene que ser \u00fanica y no puede ser NULL</li> <li>Para relacionar dos tablas usamos una foreign key</li> </ul> <p>Sin embargo, el modelo de Programaci\u00f3n Orientada a Objetos trata con objetos y las asociaciones entre ellos. Por esta raz\u00f3n, el problema entre estos dos modelos surge en el momento de querer persistir los objetos.</p>"},{"location":"uutt/ut11/1102_DesfaseObjetoRelacional.html#mapeo-objeto-relacional","title":"Mapeo objeto - relacional","text":"<p>Al trabajar con POO y BDR tenemos que estar continuamente gestionando los objetos para escribir la sentencia SQL, o recolectar todos los atributos para componer un objeto cuando leemos informaci\u00f3n desde la base de datos. A este conjunto de t\u00e9cnicas se le conoce como mapeo objeto-relacional. Y puede hacerse ayud\u00e1ndose de alguna herramienta o bien manualmente por el programador.</p>"},{"location":"uutt/ut11/1103_Conectores.html","title":"Conectores o drivers","text":"<p>Un conector o driver es un mecanismo que permite a un lenguaje de programaci\u00f3n conectarse, y trabajar, contra una base de datos. Se encarga de mantener el di\u00e1logo con la base de datos, para poder llevar a cabo el acceso y manipulaci\u00f3n de los datos.</p> <p>Algunos de los m\u00e1s conocidos son:</p> <ul> <li>ODBC (Open Database Connectivity). Es un est\u00e1ndar viejo. Esta tecnolog\u00eda proporciona una interfaz com\u00fan para tener acceso a bases de datos SQL heterog\u00e9neas. ODBC est\u00e1 basado en SQL (Structured Query Language) como un est\u00e1ndar para tener acceso a datos. ODBC permite la conexi\u00f3n f\u00e1cil desde varios lenguajes de programaci\u00f3n y se utiliza mucho en el entorno Windows.</li> <li>JDBC (Java Data Base Connectivity).</li> </ul> <p>Nosotros nos vamos a centrar en JDBC, puesto que, desde el punto de vista de Java, es una de las tecnolog\u00edas m\u00e1s importantes de conectividad a la base de datos. Y, adem\u00e1s, Java 8 ha eliminado el puente JDBC-ODBC, lo que significa que los controladores ODBC de Microsoft ya no funcionan.</p>"},{"location":"uutt/ut11/1103_Conectores.html#jdbc","title":"JDBC","text":"<p>Casi de forma simult\u00e1nea a ODBC, la empresa Sun Microsystems, en 1997 sac\u00f3 a la luz JDBC, un API conector de bases de datos, implementado espec\u00edficamente para usar con el lenguaje Java. Se trata de un API bastante similar a ODBC en cuanto a funcionalidad, pero adaptado a las especificidades de Java. Es decir, la funcionalidad se encuentra capsulada en clases (ya que Java es un lenguaje totalmente orientado a objetos) y, adem\u00e1s, no depende de ninguna plataforma espec\u00edfica, de acuerdo con la caracter\u00edstica multiplataforma defendida por Java.</p> <p>Es una API que permite la ejecuci\u00f3n de operaciones contra una base de datos desde Java independientemente del sistema operativo donde se ejecute o de la base de datos a la cual se acceda.</p> <p>Es importante destacar tambi\u00e9n que JDBC no exige ninguna instalaci\u00f3n, ni ning\u00fan cambio sustancial en el c\u00f3digo a la hora de utilizar uno u otro controlador. Esta caracter\u00edstica se sustenta, en primer lugar, en la utilidad de Java que permite cargar program\u00e1ticamente cualquier clase a partir de su nombre; en segundo lugar, en la funcionalidad de la clase DriverManager (de la API JDBC), que sin necesidad de indicarle el driver espec\u00edfico que hay que utilizar es capaz de encontrarlo y seleccionarlo de entre todos los que el sistema tenga cargados en memoria.</p> <p>A pesar de eso tampoco es mucho problema ya que actualmente podemos encontrar un driver JDBC para pr\u00e1cticamente cualquier SGBDR existente. El conector lo proporciona el fabricante de la base de datos o bien un tercero.</p>"},{"location":"uutt/ut11/1103_Conectores.html#conexion-con-la-bbdd-desde-jdbc","title":"Conexi\u00f3n con la BBDD desde JDBC","text":"<p>Antes de empezar a desarrollar aplicaciones JDBC es necesario aseguramos que tenemos instalado el SGBD, y adem\u00e1s que tenemos acceso desde el lugar donde estemos desarrollando la aplicaci\u00f3n. Una vez verificado el sistema gestor de base de datos, ser\u00e1 necesario obtener el controlador JDBC del sistema gestor. Generalmente, cada fabricante pondr\u00e1 a disposici\u00f3n de sus usuarios los diferentes tipos de controladores que tenga para sus productos. Sea cual sea el tipo de controlador que finalmente necesita, \u00e9ste tendr\u00e1 como m\u00ednimo una biblioteca en formato .jar con todas las clases de la API JDBC. Habr\u00e1 que a\u00f1adir el archivo .jar como biblioteca de nuestra aplicaci\u00f3n.</p> <p>Para descargar el driver JDBC para MySQL podemos hacerlo desde el repositorio de Maven, MySQL JDBC.</p>"},{"location":"uutt/ut11/1103_Conectores.html#establecimiento-y-cierre-de-conexion","title":"Establecimiento y cierre de conexi\u00f3n","text":"<p>Las clases que afectan a la gesti\u00f3n de la conexi\u00f3n con la BBDD son:</p> <ul> <li><code>DriverManager</code>: esta clase se utiliza para registrar el controlador para un tipo de base de datos espec\u00edfico (por ejemplo, MySQL) y para establecer una conexi\u00f3n de base de datos con el servidor a trav\u00e9s de su m\u00e9todo <code>getConnection()</code>.</li> <li><code>Connection</code>, es una interfaz que representa una conexi\u00f3n a la base de datos establecida (sesi\u00f3n) desde la cual podemos crear declaraciones para ejecutar consultas y recuperar resultados, obtener metadatos sobre la base de datos, cerrar conexi\u00f3n, etc. Los objetos Connection mantendr\u00e1n la capacidad de comunicarse con el sistema gestor mientras permanezcan abiertos. Esto es, desde que se crean hasta que se cierran utilizando el m\u00e9todo close.</li> </ul> <p>El objeto <code>Connection</code> est\u00e1 totalmente vinculado a una fuente de datos, por eso en pedir la conexi\u00f3n hay que especificar de qu\u00e9 fuente se trata siguiendo el protocolo JDBC e indicando la url de los datos, y en su caso el usuario y password. La url seguir\u00e1 el protocolo JDBC, comenzar\u00e1 siempre por la palabra jdbc seguida de dos puntos. El resto depender\u00e1 del tipo de controlador utilizado, del host donde se aloje el SGBD, del puerto que este use para escuchar las peticiones y del nombre de la base de datos o esquema con el que queremos trabajar.</p> <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DatabaseConnectionExample {\n    public static void main(String[] args) {\n        String user = \"admin\";\n        String password = \"admin\";\n        String url = \"jdbc:mysql://localhost/gobiernomundial_ad\";\n\n        try (final Connection connection = DriverManager.getConnection(url, user, password)) {\n            System.out.println(connection.getCatalog());\n        } catch (SQLException ex) {\n            System.out.println(\"SQLException: \" + ex.getMessage());\n            System.out.println(\"SQLState: \" + ex.getSQLState());\n            System.out.println(\"VendorError: \" + ex.getErrorCode());\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut11/1103_Conectores.html#operaciones-basicas","title":"Operaciones b\u00e1sicas","text":"<p>El API JDBC distingue dos tipos de consultas:</p> <ul> <li>Consultas: SELECT</li> <li>Actualizaciones: INSERT, UPDATE, DELETE, sentencias DDL.</li> </ul>"},{"location":"uutt/ut11/1103_Conectores.html#interfaces-y-clases-principales-de-jdbc","title":"Interfaces y clases principales de JDBC","text":"<ul> <li> <p><code>Statement</code> y <code>PreparedStatement</code>: estas interfaces se utilizan para ejecutar consultas SQL est\u00e1ticas y consultas SQL parametrizadas, respectivamente. <code>Statement</code> es la superinterfaz de la interfaz <code>PreparedStatement</code>, que se utiliza para consultas parametrizadas. Sus m\u00e9todos com\u00fanmente utilizados son:</p> <ul> <li><code>boolean execute(String sql)</code>: ejecuta una sentencia SQL general. Devuelve verdadero si la consulta devuelve un <code>ResultSet</code>, falso si la consulta devuelve un recuento de actualizaciones o no devuelve nada. Este m\u00e9todo solo se puede utilizar con una sentencia.</li> <li><code>int executeUpdate(String sql)</code>: ejecuta una sentencia INSERT, UPDATE o DELETE y devuelve un conteo actualizado que indica el n\u00famero de filas afectadas (por ejemplo, 1 fila insertada, 2 filas actualizadas o 0 filas afectadas).</li> </ul> <pre><code>Statement stmt = con.createStatement();\nString q1 = \"insert into userid values (1, 'root', 'Steve Jobs')\";\nint x = stmt.executeUpdate(q1);\n</code></pre> </li> <li> <p><code>ResultSet executeQuery(String sql)</code>: ejecuta una sentencia SELECT y devuelve un objeto ResultSet que contiene los resultados devueltos. <code>ResultSet</code> contiene los datos de la tabla devueltos por una consulta SELECT. Este objeto se usa para iterar sobre las filas en el conjunto de resultados usando el m\u00e9todo <code>next()</code>.</p> <pre><code>try (Connection con = DriverManager.getConnection(url, user, password);\n         Statement stmt = con.createStatement()) {\n\n        // Ejecutar una consulta simple\n        String query = \"SELECT id, fullname FROM userid\";\n        ResultSet rs = stmt.executeQuery(query);\n\n        // Mostrar los resultados\n        while (rs.next()) {\n            int id = rs.getInt(\"id\");\n            String fullname = rs.getString(\"fullname\");\n            System.out.println(\"ID: \" + id + \", Fullname: \" + fullname);\n        }\n} catch (SQLException e) {\n        System.out.println(\"Error: \" + e.getMessage());\n}\n</code></pre> </li> </ul>"},{"location":"uutt/ut11/1103_Conectores.html#liberando-recursos","title":"Liberando recursos","text":"<p>Se debe cerrar expl\u00edcitamente <code>Statement</code>, <code>ResultSet</code> y <code>Connection</code> cuando ya no se necesiten, a menos que se declaren con un <code>try-catch-with-resources</code>. Las instancias de <code>Connection</code> y las de <code>Statement</code> almacenan, en memoria, mucha informaci\u00f3n relacionada con las ejecuciones realizadas. Adem\u00e1s, mientras permanecen activas mantienen en el SGBD un conjunto importante de recursos abiertos, destinados a servir de forma eficiente las peticiones de los clientes. El cierre de estos objetos permite liberar recursos tanto del cliente como del servidor.</p> <p>Aunque se haya cerrado la conexi\u00f3n, los objetos Statements que no se hab\u00edan cerrado expresamente permanecen m\u00e1s tiempo en memoria que los objetos cerrados previamente, ya que el garbage collector de Java deber\u00e1 hacer m\u00e1s comprobaciones para asegurar que ya no dispone de dependencias ni internas ni externas y se puede eliminar. Es por ello que se recomienda proceder siempre a cerrarlo manualmente utilizando el m\u00e9todo <code>close()</code>. El cierre de los objetos <code>Statement</code> asegura la liberaci\u00f3n inmediata de los recursos y la anulaci\u00f3n de las dependencias.</p> <p>Si en un mismo m\u00e9todo queremos cerrar un objeto <code>Statement</code> y <code>Connection</code>, lo haremos siguiendo estos pasos:</p> <ol> <li>Cerramos el <code>Statement</code> y</li> <li>la instancia <code>Connection</code>.</li> </ol> <p>Si lo hici\u00e9ramos al rev\u00e9s, cuando intent\u00e1ramos cerrar el Statement nos saltar\u00eda una excepci\u00f3n de tipo <code>SQLException</code>, ya que el cierre de la conexi\u00f3n lo habr\u00eda dejado inaccesible. Cuando se cierra un objeto Statement, su objeto <code>ResultSet</code> actual, si existe, tambi\u00e9n se cierra. Pero eso no ocurre cuando se cierra la conexi\u00f3n.</p> <pre><code>try (Connection connection = dataSource.getConnection();\n     Statement statement = connection.createStatement()) {\n\n    try (ResultSet resultSet = statement.executeQuery(\"SELECT * FROM ....\")) {\n        // Do actions.\n    }\n\n}\n</code></pre>"},{"location":"uutt/ut11/1103_Conectores.html#actividades","title":"Actividades","text":"<ul> <li> <p>AC 1101 (RA8 / IC1 / 3p). Escribe un programa que actualice el <code>limite_credito</code> de todos los clientes de un pa\u00eds concreto (por ejemplo, Espa\u00f1a), increment\u00e1ndolo en un 10%.</p> </li> <li> <p>PR 1102 (RA8 / IC1 / 5p). Crea un men\u00fa interactivo en consola que permita al usuario elegir entre las siguientes opciones:</p> <ul> <li>1) Insertar un nuevo cliente.</li> <li>2) Actualizar el tel\u00e9fono de un cliente por su c\u00f3digo.</li> <li>3) Eliminar un cliente por su c\u00f3digo.</li> <li>4) Salir.</li> </ul> </li> <li> <p>PR 1103 (RA8 / IC1 / 5p). Una empresa de jardiner\u00eda quiere desarrollar una aplicaci\u00f3n en Java para analizar la informaci\u00f3n contenida en su base de datos. Esta base de datos contiene informaci\u00f3n sobre oficinas, empleados, clientes, productos, pedidos y pagos. Tu tarea consiste en implementar un programa en Java que realice las siguientes consultas utilizando JDBC y muestre los resultados en consola:</p> <ul> <li>1) Mostrar todas las oficinas de la empresa, incluyendo el c\u00f3digo de oficina y la ciudad.</li> <li>2) Listar a todos los empleados junto con el nombre completo de su jefe.</li> <li>3) Mostrar los nombres de clientes que hayan realizado pagos y el nombre de su representante de ventas.</li> <li>4) Obtener el listado de productos de la gama \"Ornamentales\" con m\u00e1s de 100 unidades en stock, ordenados por precio de venta de mayor a menor.</li> <li>5) Mostrar los clientes que hayan realizado alg\u00fan pedido, pero no hayan realizado ning\u00fan pago.</li> <li>6) Contar el n\u00famero de empleados en la compa\u00f1\u00eda.</li> </ul> <p>Adem\u00e1s de realizar las consultas, deber\u00e1s:</p> <ul> <li>Establecer la conexi\u00f3n a la base de datos utilizando JDBC.</li> <li>Crear clases para representar entidades como Oficina, Empleado, Cliente, Producto, etc.</li> <li>Usar PreparedStatement para ejecutar las consultas.</li> <li>Mostrar los resultados en consola de forma legible.</li> </ul> <p>Implementa un men\u00fa de usuario simple donde el usuario pueda seleccionar qu\u00e9 consulta ejecutar.</p> </li> </ul>"},{"location":"uutt/ut11/1104_Transacciones.html","title":"Transacciones","text":"<p>En el \u00e1mbito de las Bases de Datos, una transacci\u00f3n es cualquier conjunto de sentencias SQL que se ejecutan como si de una sola se tratara. La idea principal es poder ejecutar varias sentencias, que est\u00e1n relacionadas de alguna manera, de forma que, si cualquiera de ellas fallara o produjera un error, no se ejecutara ninguna m\u00e1s e incluso se deshicieran todos los cambios que hayan podido efectuar las que ya se hab\u00edan ejecutado dentro de la misma transacci\u00f3n, por eso decimos, que las transacciones se consideran unitarias. Es decir, las operaciones que componen la transacci\u00f3n se deben ejecutar todas o ninguna. Esto ayuda a preservarla integridad de los datos e impide posibles desfases entre clientes y servidor.</p> <p>De entrada, cualquier sentencia SQL se considera una transacci\u00f3n en s\u00ed misma y si se produce un error durante su ejecuci\u00f3n se anular\u00e1n todas las operaciones simples derivadas de la ejecuci\u00f3n de la sentencia.</p> <p>Una transacci\u00f3n tiene dos finales posibles, COMMIT o ROLLBACK. Si se finaliza correctamente y sin problemas se har\u00e1 con COMMIT, con lo que los cambios se realizan en la base de datos, y si por alguna raz\u00f3n hay un fallo, se deshacen los cambios efectuados hasta ese momento, con la ejecuci\u00f3n de ROLLBACK.</p> <p>Por defecto, al menos en MySQL, en una conexi\u00f3n trabajamos en modo autocommit con valor true. Eso significa que cada consulta es una transacci\u00f3n en la base de datos, es decir, que los cambios se aplicar\u00e1n en la base de datos una vez que la query se haya ejecutado correctamente.</p> <p>Por tanto, si queremos definir una transacci\u00f3n de varias operaciones, estableceremos el modo autocommit a false con el m\u00e9todo setAutoCommit de la clase Connection. En modo no autocommit las transacciones quedan definidas por las ejecuciones de los m\u00e9todos commit y rollback. Una transacci\u00f3n abarca desde el \u00faltimo commit o rollback hasta el siguiente commit. Los m\u00e9todos commit o rollback forman parte de la clase Connection.</p> <pre><code>public static void execute(String[] sqlqueries) throws SQLException {\n    boolean autocommit = true;\n    String user = \"luffy\";\n    String password = \"dmonkey\";\n    String url = \"jdbc:mysql://localhost/gobiernomundial_ad\";\n\n    try (final Connection con = DriverManager.getConnection(url, user, password)) {\n        try (Statement stmt = con.createStatement()) {\n            autocommit = con.getAutoCommit();\n            con.setAutoCommit(false);\n\n            for (String query : sqlqueries) {\n                stmt.executeUpdate(query);\n            }\n\n            con.commit();\n            con.setAutoCommit(autocommit);\n        } catch (SQLException ex) {\n            con.rollback();\n            throw ex;\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut11/1105_Rendimiento.html","title":"Mejora de rendimiento","text":"<p>Otro aspecto importante que mide la calidad de las aplicaciones es la eficiencia con la que se consigue comunicar con el SGBD. Para optimizar la conexi\u00f3n es importante reconocer qu\u00e9 procesos pueden actuar de cuello de botella y bajo qu\u00e9 circunstancias o qu\u00e9 otras agilizan las respuestas de los SGBD.</p> <ol> <li> <p>En primer lugar, analizaremos la petici\u00f3n de conexi\u00f3n a un SGBD porque se trata de un proceso costoso pero inevitable que hay que considerar.</p> </li> <li> <p>En segundo lugar, estudiaremos las sentencias predefinidas <code>PreparedStatement</code>, porqu\u00e9 su uso facilita la creaci\u00f3n de datos clave e \u00edndices temporales de modo que sea posible anticiparse a la demanda o disponer de los datos de forma mucho m\u00e1s r\u00e1pida.</p> </li> </ol>"},{"location":"uutt/ut11/1105_Rendimiento.html#ciclo-de-vida-de-una-conexion","title":"Ciclo de vida de una conexi\u00f3n","text":"<p>El establecimiento de una conexi\u00f3n es un procedimiento bastante lento, tanto en la parte cliente como la parte servidor. En la parte cliente, DriverManager debe descubrir el controlador correcto de entre todos los que tenga que gestionar. La mayor\u00eda de veces las aplicaciones trabajar\u00e1n s\u00f3lo con un \u00fanico controlador, pero hay que tener en cuenta que DriverManager no conoce a priori qu\u00e9 URL de conexi\u00f3n corresponde a cada controlador, y para averiguarlo env\u00eda una petici\u00f3n de conexi\u00f3n a cada controlador que tenga registrado, el controlador que no le devuelve error ser\u00e1 el correcto.</p> <p>En el lado servidor, se crear\u00e1 un contexto espec\u00edfico y se habilitar\u00e1n un conjunto de recursos para cada cliente conectado. Es decir, que durante la petici\u00f3n de conexi\u00f3n del SGBD debe gastar un tiempo considerable antes de no dejar operativa la comunicaci\u00f3n cliente-servidor.</p> <p>Este elevado gasto de tiempo concentrado en el momento de la petici\u00f3n de conexi\u00f3n nos hace plantear si podemos considerar ineficiente abrir y cerrar la conexi\u00f3n cada vez que tengamos que ejecutar una sentencia SQL, como hemos hecho hasta ahora. Desafortunadamente no hay una \u00fanica respuesta, sino que depende de la frecuencia de uso de la conexi\u00f3n y el n\u00famero de conexiones contra un mismo SGBD coexistiendo al mismo tiempo.</p> <p>Como en todo, se trata de encontrar el punto de equilibrio entre la cantidad de recursos empleados por conexi\u00f3n y la rentabilidad que se saca en mantenerlas abiertas. </p> <ul> <li>Si el n\u00famero de clientes, y por tanto de conexiones, es bajo y la frecuencia de uso es alta, ser\u00e1 preferible mantener las conexiones abiertas mucho tiempo. </li> <li>Por el contrario, si el n\u00famero de conexiones es muy alto y el uso infrecuente, lo que ser\u00e1 preferible ser\u00e1 abrir y cerrar la conexi\u00f3n cada vez que se necesite. </li> </ul> <p>Mientras tanto, habr\u00e1 una multitud de casos en que la soluci\u00f3n consistir\u00e1 en mantener las conexiones abiertas, pero no permanentemente. Se puede dar un tiempo de vida a cada conexi\u00f3n, o bien cerrarlas despu\u00e9s de restar inactiva una cantidad determinada de tiempo, o se puede usar el criterio de mantener un n\u00famero m\u00e1ximo de conexiones abiertas, cerrando las m\u00e1s antiguas o las m\u00e1s inactivas cuando se sobrepase el l\u00edmite.</p>"},{"location":"uutt/ut11/1105_Rendimiento.html#sentencias-predefinidas","title":"Sentencias predefinidas","text":"<p>PreparedStatement presenta ventajas sobre su antecesor Statement cuando tengamos que trabajar con sentencias que haya que ejecutar varias veces. La raz\u00f3n es que cualquier sentencia SQL, cuando se env\u00eda el SGBD ser\u00e1 compilada antes de ser ejecutada. Usando un objeto <code>Statement</code>, cada vez que hacemos una ejecuci\u00f3n de una sentencia, ya sea v\u00eda executeUpdate o bien v\u00eda <code>executeQuery</code>, el SGBD la compilar\u00e1, ya que le llegar\u00e1 en forma de cadena de caracteres.</p> <p>En cambio, al <code>PreparedStament</code> la sentencia nunca var\u00eda y por lo tanto se puede compilar y almacenar dentro del mismo objeto, por lo que las siguientes veces que se ejecute no habr\u00e1 que compilarla. Esto reducir\u00e1 sensiblemente el tiempo de ejecuci\u00f3n. La parametrizaci\u00f3n, adem\u00e1s, ayuda a crear sentencias muy gen\u00e9ricas que se puedan reutilizar f\u00e1cilmente.</p> <p>En algunos sistemas gestores, adem\u00e1s, usar <code>PreparedStatement</code> puede llegar a suponer m\u00e1s ventajas, ya que utilizan la secuencia de bytes de la sentencia para detectar si se trata de una sentencia nueva o ya se ha servido con anterioridad. De esta manera se propicia que el sistema almacene las respuestas en la cach\u00e9, de manera que se puedan entregar de forma m\u00e1s r\u00e1pida.</p> <p>Quote</p> <p>This is a fact, a rule, a law -- use prepared statements EVERYWHERE. Use STATEMENTS almost no where.</p>"},{"location":"uutt/ut11/1105_Rendimiento.html#casos-de-uso","title":"Casos de uso","text":"Ejemplo 1Ejemplo 2 <p>Statement acepta cadenas como consultas SQL. Por lo tanto, el c\u00f3digo se vuelve menos legible cuando concatenamos cadenas SQL:</p> <pre><code>public void insert(PersonEntity personEntity) {\n    String query = \"INSERT INTO persons(id, name, age, email) VALUES(\" \n                + personEntity.getId() + \", '\"\n                + personEntity.getName() + \"', \"\n                + personEntity.getAge() + \", '\"\n                + personEntity.getEmail() + \"')\";\n\n    Statement statement = connection.createStatement();\n    statement.executeUpdate(query);\n}\n</code></pre> <p>Es vulnerable a la inyecci\u00f3n de SQL.</p> <p><pre><code>public void check(String name) {\n    String query = \"SELECT * FROM users WHERE name = '\" + name + \"'\";\n\n    Statement statement = connection.createStatement();\n    statement.executeUpdate(query);\n}\n</code></pre> Si un usuario malintencionado escribe como nombre de usuario a consultar:  <pre><code>Alicia'; DROP TABLE usuarios; SELECT * FROM datos WHERE nombre LIKE '%\n</code></pre> En la base de datos se ejecutar\u00eda la consulta en el orden dado, se seleccionar\u00edan todos los registros con el nombre 'Alicia', se borrar\u00eda la tabla 'usuarios' y finalmente se seleccionar\u00eda toda la tabla \"datos\", que no deber\u00eda estar disponible para los usuarios web comunes.</p>"},{"location":"uutt/ut11/1106_EstructuraProyecto.html","title":"Estructura de los proyectos","text":"<p>Para las tareas de clase vamos a seguir una estructura que iremos perfilando basada en el MVC. Para ello hay que ser ordenados y saber qu\u00e9 forma un proyecto. <pre><code>proyecto/\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 MainApp\n\u251c\u2500\u2500 model/\n\u2502   \u2514\u2500\u2500 Login\n\u251c\u2500\u2500 mysql/\n\u2502   \u2514\u2500\u2500 LoginHandleDB\n\u2514\u2500\u2500 util/\n    \u2514\u2500\u2500 DatabaseConnection\n</code></pre></p>"},{"location":"uutt/ut11/1106_EstructuraProyecto.html#creando-la-bbdd","title":"Creando la BBDD","text":"<p>Lo primero que tendremos que hacer asegurarnos de que tenemos el servidor de base de datos instalado y la base de datos creada con las tablas que necesitemos para nuestra aplicaci\u00f3n.</p>"},{"location":"uutt/ut11/1106_EstructuraProyecto.html#clase-connection","title":"Clase Connection","text":"<p>Conectar a la BD es un coste muy grande, ya que es un proceso lento, por lo tanto, implementaremos la clase de conexi\u00f3n a la base de datos utilizando el patr\u00f3n singleton.  Esta clase estar\u00e1 ubicada dentro del paquete util.</p> <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DatabaseConnection {\n    private static Connection connection = null;\n\n    // Constructor privado para evitar instanciaci\u00f3n\n    private DatabaseConnection() {}\n\n    // Bloque est\u00e1tico para inicializar la conexi\u00f3n\n    static {\n        String url = \"jdbc:mysql://localhost/gobiernomundial\";\n        String user = \"luffy\";\n        String password = \"dmonkey\";\n        try {\n            connection = DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // M\u00e9todo para obtener la conexi\u00f3n\n    public static Connection getConnection() {\n        return connection;\n    }\n\n    // M\u00e9todo para cerrar la conexi\u00f3n\n    public static void close() throws SQLException {\n        if (connection != null &amp;&amp; !connection.isClosed()) {\n            connection.close();\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut11/1106_EstructuraProyecto.html#creando-el-modelo","title":"Creando el modelo","text":"<p>El modelo contiene una representaci\u00f3n de ellos datos que maneja la aplicaci\u00f3n y su l\u00f3gica de negocio.</p> <p>Para el ejemplo, el modelo de Login debe contener los atributos que contiene la tabla login como variables de la clase Normalmente los modelos de la clase se encuentran en un paquete llamado <code>model</code>.</p> <pre><code>import java.time.LocalDateTime;\n\npublic class Login {\n    private int id;\n    private String username;\n    private String password;\n    private LocalDateTime createdAt;\n\n    // Constructores\n    public Login() {}\n\n    public Login(int id, String username, String password, LocalDateTime createdAt) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.createdAt = createdAt;\n    }\n\n    // Getters y Setters\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public LocalDateTime getCreatedAt() {\n        return createdAt;\n    }\n\n    public void setCreatedAt(LocalDateTime createdAt) {\n        this.createdAt = createdAt;\n    }\n\n    // M\u00e9todo toString\n    @Override\n    public String toString() {\n        return \"Login{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n    }\n}\n</code></pre>"},{"location":"uutt/ut11/1106_EstructuraProyecto.html#clases-para-la-manipulacion-de-la-base-de-datos","title":"Clases para la manipulaci\u00f3n de la base de datos","text":"<p>Dentro del paquete <code>mysql</code> a\u00f1adiremos clases que ser\u00e1n las encargadas de manipular la informaci\u00f3n contra la base de datos. </p> <p>En el ejemplo tenemos una clase que realiza la manipulaci\u00f3n de la informaci\u00f3n referente a la tabla <code>login</code>.</p> <pre><code>import java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LoginAccessDB {\n    private static Connection con = DatabaseConnection.getConnection();\n\n    public List&lt;Login&gt; getLogins() throws SQLException {\n        String sql = \"SELECT * FROM login\";\n        List&lt;Login&gt; logins = new ArrayList&lt;&gt;();\n\n        try (Statement statement = con.createStatement();\n             ResultSet resultSet = statement.executeQuery(sql)) {\n\n            while (resultSet.next()) {\n                Login login = new Login();\n                login.setId(resultSet.getInt(1));\n                login.setUsername(resultSet.getString(\"username\"));\n                login.setPassword(resultSet.getString(\"password\"));\n                login.setCreatedAt(resultSet.getTimestamp(\"created_at\").toLocalDateTime());\n\n                logins.add(login);\n            }\n        }\n\n        return logins;\n    }\n}\n</code></pre>"},{"location":"uutt/ut11/1106_EstructuraProyecto.html#test","title":"Test","text":"<p>Por \u00faltimo comprobamos que todo funciona correctamente haciendo una peque\u00f1a prueba en nuestro <code>main</code> o punto de entrada al programa.</p> <pre><code>public class MainApp {\n    public static void main(String[] args) {\n        LoginAccessDB loginHandleDB = new LoginAccessDB();\n\n        try {\n            for (Login l : loginHandleDB.getLogins()) {\n                System.out.println(l);\n            }\n        } catch (SQLException ex) {\n            System.out.println(\"SQLException: \" + ex.getMessage());\n            System.out.println(\"SQLState: \" + ex.getSQLState());\n            System.out.println(\"VendorError: \" + ex.getErrorCode());\n        }\n    }\n}\n</code></pre>"},{"location":"uutt/ut11/1106_EstructuraProyecto.html#fichero-readme","title":"Fichero README","text":"<p>El archivo README es el primer archivo que un desarrollador debe mirar antes de embarcarse en un proyecto, por lo que tambi\u00e9n es esencial saber c\u00f3mo escribir un buen archivo README, para que toda la informaci\u00f3n relevante se presente de forma compacta. </p> <p>Ayuda a crearlo</p> <p>Adem\u00e1s de hacerlo nosotros, existen proyectos que nos ayudan a generarlo como es readme.so</p>"},{"location":"uutt/ut11/1106_EstructuraProyecto.html#que-suelen-incluir-los-ficheros-readme","title":"\u00bfQu\u00e9 suelen incluir los ficheros README?","text":"<p>Suelen incluir informaci\u00f3n sobre:</p> <ul> <li>Una descripci\u00f3n general del sistema o proyecto.</li> <li>El estado del proyecto, que es particularmente importante si el proyecto est\u00e1 todav\u00eda en desarrollo. En \u00e9l se mencionan los cambios planeados y la direcci\u00f3n de desarrollo del proyecto, y se especifica directamente si un proyecto est\u00e1 terminado.</li> <li>Los requisitos del entorno de desarrollo para la integraci\u00f3n.</li> <li>Una lista de las tecnolog\u00edas utilizadas y, cuando proceda, enlaces con m\u00e1s informaci\u00f3n.</li> <li>Bugs conocidos y posibles correcciones de errores.</li> <li>Secci\u00f3n de preguntas frecuentes con todas las preguntas planteadas hasta la fecha.</li> <li>Informaci\u00f3n sobre derechos de autor y licencias.</li> </ul>"},{"location":"uutt/ut11/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 11","text":""},{"location":"uutt/ut11/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA8.CERA9.CE <ul> <li>Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n.</li> </ul> <ul> <li>a. Se han identificado las caracter\u00edsticas de las bases de datos orientadas a objetos.</li> <li>b. Se ha analizado su aplicaci\u00f3n en el desarrollo de aplicaciones mediante lenguajes orientados a objetos.</li> <li>c. Se han instalado sistemas gestores de bases de datos orientados a objetos.</li> <li>d. Se han clasificado y analizado los distintos m\u00e9todos soportados por los sistemas gestores para la gesti\u00f3n de la informaci\u00f3n almacenada.</li> <li>e. Se han creado bases de datos y las estructuras necesarias para el almacenamiento de objetos.</li> <li>f. Se han programado aplicaciones que almacenen objetos en las bases de datos creadas.</li> <li>g. Se han realizado programas para recuperar, actualizar y eliminar objetos de las bases de datos.</li> <li>h. Se han realizado programas para almacenar y gestionar tipos de datos estructurados, compuestos y relacionados.</li> </ul> <ul> <li>Gestiona informaci\u00f3n almacenada en bases de datos manteniendo la integridad y consistencia de los datos.</li> </ul> <ul> <li>a. Se han identificado las caracter\u00edsticas y m\u00e9todos de acceso a sistemas gestores de bases de datos.</li> <li>b. Se han programado conexiones con bases de datos.</li> <li>c. Se ha escrito un c\u00f3digo para almacenar informaci\u00f3n en bases de datos.</li> <li>d. Se han creado programas para recuperar y mostrar informaci\u00f3n almacenada en bases de datos.</li> <li>e. Se han efectuado borrados y modificaciones sobre la informaci\u00f3n almacenada.</li> <li>f. Se han creado aplicaciones que muestren la informaci\u00f3n almacenada en bases de datos.</li> <li>g. Se han creado aplicaciones para gestionar la informaci\u00f3n presente en bases de datos.</li> </ul>"},{"location":"uutt/ut11/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p> <ol> <li> <p>Persistencia de la informaci\u00f3n</p> <ol> <li>XML</li> <li>JSON</li> <li>Bases de datos</li> </ol> </li> <li> <p>Desfase objeto - relacional</p> </li> <li> <p>Conectores o drivers</p> <ol> <li>JDBC</li> <li>Conexi\u00f3n con la BBDD desde JDBC</li> <li>Establecimiento y cierre de conexi\u00f3n</li> </ol> </li> <li> <p>Transacciones</p> </li> <li> <p>Mejora de rendimiento</p> <ol> <li>Ciclo de vida de una conexi\u00f3n</li> <li>Sentencias predefinidas</li> </ol> </li> <li> <p>Estructura de los proyectos</p> </li> </ol>"},{"location":"uutt/ut11/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>21/03/2025</p> <p></p> <p></p> <p>02</p> <p>24/03/2025</p> <p></p> <p></p> <p>03</p> <p>24/03/2025</p> <p></p> <p></p> <p>04</p> <p>25/03/2025</p> <p></p> <p></p> <p>05</p> <p>26/03/2025</p> <p></p> <p></p> <p>06</p> <p>26/03/2025</p> <p></p> <p></p> <p>07</p> <p>27/03/2025</p> <p></p> <p></p> <p>08</p> <p>27/03/2025</p> <p></p> <p></p> <p>09</p> <p>28/03/2025</p> <p></p> <p></p> <p>10</p> <p>31/03/2025</p> <p></p> <p></p> <p>11</p> <p>01/04/2025</p> <p></p> <p></p> <p>12</p> <p>02/04/2025</p> <p></p> <p></p> <p>13</p> <p>02/04/2025</p> <p></p> <p></p> <p>14</p> <p>03/04/2025</p> <p></p> <p></p> <p>15</p> <p>03/04/2025</p> <p></p> <p></p> <p>16</p> <p>04/04/2025</p> <p></p> <p></p> <p>17</p> <p>07/04/2025</p> <p></p> <p></p> <p>18</p> <p>07/04/2025</p> <p></p> <p></p> <p>19</p> <p>08/04/2025</p> <p></p> <p></p> <p>20</p> <p>09/04/2025</p> <p></p> <p></p> <p>21</p> <p>09/04/2025</p> <p></p> <p></p> <p>22</p> <p>10/04/2025</p> <p></p> <p>PO UT 11</p> <p>23</p> <p>10/04/2025</p> <p></p> <p>PO UT 11</p> <p>24</p> <p>11/04/2025</p> <p></p> <p>Trabajo en clase</p>"},{"location":"uutt/ut11/ResumenUT.html#referencias","title":"Referencias","text":""},{"location":"uutt/ut11/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":""},{"location":"uutt/ut12/1201_JavaFX.html","title":"JavaFX","text":"<p>Las interfaces de usuario son las encargadas de la comunicaci\u00f3n con el usuario. Muchas veces el \u00e9xito de una aplicaci\u00f3n depende de su interfaz. De poco sirve que una aplicaci\u00f3n funcione bien, desde el punto de vista t\u00e9cnico, si el usuario la encuentra complicada. Por todo ello aparecen en el mercado las interfaces gr\u00e1ficas haciendo m\u00e1s agradable al usuario su manejo. </p> <p>JavaFX es una tecnolog\u00eda de software que, combinada con Java, permite crear y desplegar aplicaciones con un aspecto vanguardista y contenidos avanzados, audio y v\u00eddeo. JavaFX es una biblioteca de Java que se utiliza para crear aplicaciones de escritorio y de Internet enriquecidas (RIA). Las aplicaciones escritas con esta biblioteca se pueden ejecutar de manera uniforme en m\u00faltiples plataformas. Las aplicaciones desarrolladas con JavaFX pueden ejecutarse en varios dispositivos como computadoras de escritorio, tel\u00e9fonos m\u00f3viles, televisores, tabletas, etc.</p> <p>Una aplicaci\u00f3n en JavaFX est\u00e1 controlada por la plataforma JavaFX, un sistema en tiempo de ejecuci\u00f3n (runtime) que construye el objeto de aplicaci\u00f3n y construye el subproceso de aplicaci\u00f3n JavaFX. Para construir una aplicaci\u00f3n JavaFX, debe extender la clase JavaFX Application. El sistema de tiempo de ejecuci\u00f3n de JavaFX (JavaFX runtime system) controla el ciclo de vida de la aplicaci\u00f3n e invoca el m\u00e9todo <code>start()</code> de <code>Application</code> para comenzar. Por tanto, la clase que hace posible desarrollar aplicaciones con JavaFX es la clase <code>Application</code>. Debemos tener en cuenta que \u00e9sta, es el punto de partida de toda aplicaci\u00f3n desarrollada con esta tecnolog\u00eda. La clase <code>Application</code> perteneciente al paquete <code>javafx.application</code> es el punto de partida de cualquier aplicaci\u00f3n desarrollada en JavaFX. </p> <p>Por lo tanto para crear una aplicaci\u00f3n con esta tecnolog\u00eda la clase principal debe heredar de esta clase e implementar su m\u00e9todo abstracto <code>start()</code>, este m\u00e9todo es el que permitir\u00e1 inicializar la interfaz gr\u00e1fica. Para finalizar en el m\u00e9todo main tenemos el m\u00e9todo <code>launch()</code> el cual de manera interna se encargar\u00e1 de ejecutar todo lo que tenemos en el m\u00e9todo <code>start()</code>. </p> <p>Esta clase posee tres m\u00e9todos abstractos de suma importancia los cuales conforman el ciclo de vida de una aplicaci\u00f3n JavaFX, los m\u00e9todos <code>init()</code>, <code>start()</code>, y <code>stop()</code>. La estructura inicial de una aplicaci\u00f3n desarrollada con JavaFX es:</p> <pre><code>import javafx.application.Application;\nimport javafx.stage.Stage;\n\npublic class MiAplicacionJavaFX extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        // C\u00f3digo de inicializaci\u00f3n de la interfaz gr\u00e1fica\n    }\n\n    public static void main(String[] args) {\n        launch(); // Ejecuta el m\u00e9todo start()\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1202_EstructutaAPP.html","title":"Estructura de una aplicaci\u00f3n JavaFX","text":"<p>JavaFX utiliza una met\u00e1fora del teatro, es decir una aplicaci\u00f3n desarrollada con esta tecnolog\u00eda est\u00e1 compuesta por tres componentes esenciales los cuales son: </p> <ol> <li>Stage - Escenario. </li> <li>Scene - Escena. </li> <li>Nodes - Nodos.</li> </ol>"},{"location":"uutt/ut12/1202_EstructutaAPP.html#stage","title":"Stage","text":"<p>El contenedor de nivel superior es el escenario (<code>Stage</code>) y lo construye y proporciona autom\u00e1ticamente la plataforma. En las aplicaciones de escritorio, el escenario es la ventana, en la cual agregaremos todos los objetos de nuestra interfaz gr\u00e1fica; \u00e9sta actuar\u00e1 como contenedor principal, de forma similar a lo que hace en Java Swing la clase JFrame. </p> <p></p> <p>El escenario o <code>Stage</code> principal es creado por la plataforma en s\u00ed, y se pasa como argumento al m\u00e9todo <code>start()</code> de la clase <code>Application</code>. </p> <p>Para poder visualizar dicha ventana debemos hacer uso del m\u00e9todo <code>show()</code> o <code>showAndWait()</code>. La diferencia entre los m\u00e9todos <code>show()</code> y <code>showAndWait()</code>, es que <code>show()</code> hace visible el <code>Stage</code> y sale del m\u00e9todo inmediatamente, mientras que <code>showAndWait()</code> muestra el objeto <code>Stage</code> y luego lo bloquea (permanece dentro del m\u00e9todo <code>showAndWait()</code>) hasta que se cierre el <code>Stage</code>. </p> <p>Una aplicaci\u00f3n JavaFX puede tener m\u00faltiples objetos <code>Stage</code>. Cuando se crea un nuevo <code>Stage</code> se puede establecer su modalidad. La modalidad determina si la ventana que representa el <code>Stage</code> bloquear\u00e1 otras ventanas abiertas por la misma aplicaci\u00f3n.</p> <ul> <li><code>Modality.APPLICATION_MODAL</code>, bloquear\u00e1 todas las dem\u00e1s ventanas abiertas por esta aplicaci\u00f3n. No puede acceder a ninguna otra ventana hasta que se haya cerrado esta ventana. </li> <li><code>Modality.WINDOW_MODAL</code> el Stage creado bloquear\u00e1 la ventana del Stage que \"posee\" (propietario) el Stage creado, pero solo eso. No todas las ventanas de la aplicaci\u00f3n. </li> <li><code>Modality.NONE</code> el Stage no bloquear\u00e1 ninguna otra ventana abierta en esta aplicaci\u00f3n.</li> </ul>"},{"location":"uutt/ut12/1202_EstructutaAPP.html#scene","title":"Scene","text":"<p>Para mostrar cualquier cosa en un escenario <code>Stage</code> se necesita una escena <code>Scene</code>. Una escena est\u00e1 representada por un objeto <code>Scene</code> dentro de una aplicaci\u00f3n JavaFX. </p> <p>Un <code>Stage</code> solo puede mostrar una escena a la vez, pero es posible intercambiar la escena en tiempo de ejecuci\u00f3n. Al igual que un escenario en un teatro se puede reorganizar para mostrar varias escenas durante una obra, un objeto de escenario (<code>Stage</code>) en JavaFX puede mostrar varias escenas (una a la vez) durante la vida \u00fatil de una aplicaci\u00f3n JavaFX. </p> <p>Un ejemplo de aplicaci\u00f3n con varios Scene para un <code>Stage</code> ser\u00eda un juego de computador. Un juego puede tener m\u00faltiples \"pantallas\" para mostrar al usuario. Por ejemplo, una pantalla de men\u00fa inicial, la pantalla principal del juego (donde se juega el juego), una pantalla de finalizaci\u00f3n del juego y una pantalla de puntuaci\u00f3n m\u00e1s alta. Cada una de estas pantallas puede ser representada por una escena diferente. Cuando el juego necesita cambiar de una pantalla a la siguiente, simplemente adjunta la escena correspondiente al objeto <code>Stage</code> de la aplicaci\u00f3n JavaFX. </p> <p>Cuando nos referimos a la escena, estamos haciendo referencia a los o contenidos f\u00edsicos (nodos) de una aplicaci\u00f3n JavaFX; la clase <code>Scene</code> perteneciente al paquete Javafx.scene proporciona todos los m\u00e9todos para manejar un objeto de escena. </p> <p></p> <p>La escena consta de elementos como la ra\u00edz (Root Node), que es el elemento superior de la escena y contiene lo que se llama el gr\u00e1fico de escena (Scene Graph). El gr\u00e1fico de escena es una estructura estrictamente jer\u00e1rquica de elementos que visualizan la aplicaci\u00f3n. Estos elementos se denominan Nodos. Un nodo tiene exactamente un padre (excepto el nodo ra\u00edz) y puede contener otros nodos. O un nodo puede ser un nodo hoja sin hijos. Se deben agregar nodos al gr\u00e1fico de escena para participar en la representaci\u00f3n de esa escena. Adem\u00e1s, un nodo puede agregarse solo una vez a una escena, a menos que primero se elimine y luego se agregue en otro lugar.</p> <p>Al crear un objeto de tipo <code>Scene</code>, debemos pasar como argumento el nodo ra\u00edz el cual contendr\u00e1 todos los nodos que se visualizar\u00e1n en dicha interfaz e igualmente tenemos la posibilidad de asignar unas dimensiones (ancho y alto) a la escena.</p> <pre><code>import javafx.application.Application; \nimport javafx.scene.Parent; \nimport javafx.scene.Scene; \nimport javafx.scene.layout.StackPane; \nimport javafx.scene.text.Text; \nimport javafx.stage.Stage; \n\npublic class HelloApplication extends Application { \n\n    @Override \n    public void start(Stage stage) { \n        Text texto = new Text(\"Hello World\"); \n        StackPane nodoRaiz = new StackPane(texto); \n        Scene escena = new Scene(nodoRaiz, 300, 300); \n        stage.setScene(escena); stage.show(); \n    }\n    public static void main(String[] args) { \n        launch();\n    } \n}\n</code></pre>"},{"location":"uutt/ut12/1202_EstructutaAPP.html#node","title":"Node","text":"<p>Constituyen el nivel m\u00e1s bajo del diagrama. Un nodo hace referencia a los componentes, los cuales pueden ser: etiquetas de texto (Labels), Botones (Buttons), Tablas (Tables), Contenedores (Containers). </p> <p>La clase <code>Node</code>, <code>javafx.scene.Node</code>, es la clase base (superclase) para todos los componentes agregados a <code>JavaFX Scene Graph</code>. La clase <code>Node</code> es abstracta, por lo que solo agregar\u00e1 subclases de la clase <code>Node</code> al <code>Scene Graph</code>. Todas las instancias de Node en el escenario gr\u00e1fico comparten un conjunto de propiedades comunes que est\u00e1n definidas por la clase JavaFX Node.</p>"},{"location":"uutt/ut12/1202_EstructutaAPP.html#conceptos-basicos-de-javafx-node","title":"Conceptos b\u00e1sicos de JavaFX Node","text":"<p>Cada instancia de <code>Node</code> (subclase) solo se puede agregar al Scene Graph una vez. En otras palabras, cada instancia de <code>Node</code> solo puede aparecer en un lugar en el escenario gr\u00e1fico. Si intenta agregar la misma instancia de <code>Node</code>, o instancia de subclase de <code>Node</code>, al gr\u00e1fico de escena m\u00e1s de una vez, se generar\u00e1 una excepci\u00f3n. Un nodo JavaFX a veces puede tener subelementos, que tambi\u00e9n se denominan elementos secundarios. Una vez que se adjunta una instancia de node al gr\u00e1fico de escena, solo el hilo de la aplicaci\u00f3n JavaFX puede modificar la instancia de node. </p>"},{"location":"uutt/ut12/1202_EstructutaAPP.html#propiedades-de-javafx-node","title":"Propiedades de JavaFX Node","text":"<p>La clase Node y todas las subclases de Node, tienen las siguientes propiedades:</p> <ul> <li> <p>Sistema de coordenadas (Coordinate System). Cada nodo JavaFX tiene su propio sistema de coordenadas cartesianas. La \u00fanica diferencia con un sistema de coordenadas cartesianas regular es que el eje Y est\u00e1 invertido. Eso significa que el origen del sistema de coordenadas est\u00e1 en la esquina superior izquierda del sistema de coordenadas. A medida que aumentan los valores de Y, el punto se mueve hacia abajo desde la parte superior del sistema de coordenadas. Esta inversi\u00f3n del eje Y es normal en los sistemas de coordenadas de gr\u00e1ficos 2D. Es posible que un nodo JavaFX tenga coordenadas X e Y negativas.</p> <p>Cada nodo tiene su propio sistema de coordenadas. Este sistema de coordenadas se utiliza para colocar instancias de nodos secundarios dentro del nodo principal o al dibujar en un lienzo JavaFX. Eso significa que un nodo que es hijo de otro nodo tiene su propio sistema de coordenadas y una ubicaci\u00f3n (X,Y) dentro del sistema de coordenadas de su nodo principal. </p> </li> <li> <p>Items (Child nodes).Muchas subclases de nodos pueden contener elementos o nodos secundarios. La forma exacta en que agrega y accede a estos nodos secundarios depende de la subclase de nodo concreta. Algunas clases tienen un m\u00e9todo getItems() que devuelve una lista de elementos. Otras clases tienen un m\u00e9todo getChildren() que hace lo mismo. Se tendr\u00e1 que comprobar la subclase de Nodo concreta para averiguar si puede tener elementos o nodos secundarios, y c\u00f3mo los agrega y accede a ellos.</p> </li> </ul>"},{"location":"uutt/ut12/1203_Contenedores.html","title":"Contenedores en JavaFX.","text":"<p>Los contenedores o paneles de dise\u00f1o (layout) nos permiten a\u00f1adir controles de la interfaz de usuario dentro de un gr\u00e1fico de escena de una aplicaci\u00f3n JavaFX sin tener que escribir el c\u00f3digo necesario para gestionar el posicionamiento o el cambio de tama\u00f1o de esos controles. El <code>Layout</code> gestionar\u00e1 todo eso por nosotros.</p>"},{"location":"uutt/ut12/1203_Contenedores.html#stackpane","title":"StackPane","text":"<p>Los nodos se colocan uno encima de otro, de atr\u00e1s hacia delante en el orden que se agregan los nodos, como en una pila. El nodo agregado primero se coloca en la parte inferior de la pila y el siguiente nodo se coloca encima. Est\u00e1 representado por la clase denominada <code>StackPane</code> del paquete <code>javafx.scene.layout</code>.</p> <pre><code>import javafx.application.Application;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.layout.StackPane;\nimport javafx.scene.paint.Color;\nimport javafx.scene.shape.Rectangle;\nimport javafx.stage.Stage;\n\npublic class StackPaneApplication extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        // Crea un StackPane\n        StackPane pane = new StackPane();\n\n        // Crea 3 cuadrados\n        Rectangle rectBottom = new Rectangle(250, 250);\n        rectBottom.setFill(Color.AQUA);\n\n        Rectangle rectMiddle = new Rectangle(200, 200);\n        rectMiddle.setFill(Color.CADETBLUE);\n\n        Rectangle rectUpper = new Rectangle(150, 150);\n        rectUpper.setFill(Color.CORAL);\n\n        // Coloca los cuadrados uno encima del otro\n        pane.getChildren().addAll(rectBottom, rectMiddle, rectUpper);\n\n        // Crea una escena y la muestra en el stage\n        Scene scene = new Scene(pane);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"StackPane Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1203_Contenedores.html#gridpane","title":"GridPane","text":"<p>Permite colocar nodos secundarios en una cuadr\u00edcula bidimensional de tama\u00f1o flexible. Los componentes pueden abarcar filas y / o columnas, pero el tama\u00f1o de la fila es coherente para todos los componentes de una fila determinada. De manera similar, el ancho de la columna es consistente para una columna determinada. Tiene m\u00e9todos especializados que agregan nodos a una celda en particular designada por un n\u00famero de columna y fila. Los argumentos opcionales le permiten especificar valores de intervalo de filas y columnas.</p> <pre><code>import javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.layout.GridPane;\nimport javafx.stage.Stage;\n\npublic class GridPaneApplication extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        // Crear un GridPane\n        GridPane grid = new GridPane();\n        grid.setVgap(10); // Espacio vertical entre las filas\n        grid.setHgap(10); // Espacio horizontal entre las columnas\n\n        // Agregar botones al GridPane\n        grid.add(new Button(\"Posicion 0, 0\"), 0, 0);\n        grid.add(new Button(\"Posicion 1, 0\"), 1, 0);\n        grid.add(new Button(\"Posicion 0, 1\"), 0, 1);\n        grid.add(new Button(\"Posicion 1, 1\"), 1, 1);\n        grid.add(new Button(\"Posicion 0, 2\"), 0, 2);\n        grid.add(new Button(\"Posicion 1, 2\"), 1, 2);\n\n        // Crear la escena y asignarla al Stage\n        Scene scene = new Scene(grid);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"GridPane Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1203_Contenedores.html#flowpane","title":"FlowPane","text":"<p><code>FlowPane</code> administra a sus hijos en un flujo horizontal o vertical. La orientaci\u00f3n predeterminada es horizontal.</p> <pre><code>import javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.layout.FlowPane;\nimport javafx.stage.Stage;\n\npublic class FlowPaneApplication extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        // Crear un FlowPane (disposici\u00f3n de flujo horizontal)\n        FlowPane tile = new FlowPane();\n\n        // Configurar el n\u00famero de columnas y filas\n        tile.setPrefColumns(6); // Declaramos 6 columnas\n        tile.setPrefRows(4);    // Y 4 filas\n\n        // Agregar botones al FlowPane\n        for (int i = 0; i &lt; 20; i++) {\n            tile.getChildren().add(new Button(\"Bot\u00f3n \" + (i + 1)));\n        }\n\n        // Crear la escena y asignarla al Stage\n        Scene scene = new Scene(tile);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"FlowPane Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1203_Contenedores.html#borderpane","title":"BorderPane","text":"<p><code>BorderPane</code> es conveniente para aplicaciones de escritorio con secciones discretas, que incluyen una barra de herramientas superior (superior), una barra de estado inferior (inferior), un \u00e1rea de trabajo central (centro) y dos \u00e1reas laterales (derecha e izquierda). Cualquiera de las cinco secciones puede estar vac\u00eda. Los nodos se organizan por tanto en las posiciones Superior, Izquierda, Derecha, Inferior y Central.</p> <pre><code>import javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.layout.BorderPane;\nimport javafx.stage.Stage;\n\npublic class BorderPaneApplication extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        // Crear un BorderPane\n        BorderPane raiz = new BorderPane();\n\n        // Agregar botones en las diferentes regiones del BorderPane\n        raiz.setTop(new Button(\"TOP\"));\n        raiz.setBottom(new Button(\"BOTTOM\"));\n        raiz.setLeft(new Button(\"LEFT\"));\n        raiz.setRight(new Button(\"RIGHT\"));\n        raiz.setCenter(new Button(\"CENTER\"));\n\n        // Crear la escena y asignarla al Stage\n        Scene scene = new Scene(raiz);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"BorderPane Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1203_Contenedores.html#scrollpane","title":"ScrollPane","text":"<p>Es un contenedor que tiene 2 barras de desplazamiento para mostrar componentes que son m\u00e1s grandes que el \u00e1rea visible del contenedor</p> <pre><code>import javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ScrollPane;\nimport javafx.scene.control.TextArea;\nimport javafx.stage.Stage;\n\npublic class ScrollPaneApplication extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        primaryStage.setTitle(\"ScrollPane Application\");\n\n        // Crear un TextArea con texto de ejemplo\n        TextArea textArea = new TextArea(\"Escribe aqu\u00ed\\nen m\u00faltiples\\nl\u00edneas\\n\"\n                + \"y l\u00edneas muy largas que superan el tama\u00f1o visible...\\n\"\n                + \"y otra l\u00ednea\\notra l\u00ednea\\notra l\u00ednea\\notra l\u00ednea\");\n\n        // Agregar el TextArea a un ScrollPane\n        ScrollPane scrollPane = new ScrollPane(textArea);\n\n        // Crear la escena y asignarla al Stage\n        Scene scene = new Scene(scrollPane, 200, 100);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1203_Contenedores.html#tabpane","title":"TabPane","text":"<p>Es un contenedor que puede contener m\u00faltiples pesta\u00f1as internamente, las cuales pueden visualizarse haciendo clic en ellas. S\u00f3lo puede visualizarse una pesta\u00f1a a la vez. </p> <pre><code>import javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Tab;\nimport javafx.scene.control.TabPane;\nimport javafx.scene.control.Label;\nimport javafx.stage.Stage;\n\npublic class TabPaneApplication extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        primaryStage.setTitle(\"TabPane Application\");\n\n        // Crear pesta\u00f1as\n        Tab tab1 = new Tab(\"Pesta\u00f1a 1\", new Label(\"Comprar\"));\n        Tab tab2 = new Tab(\"Pesta\u00f1a 2\", new Label(\"Vender\"));\n\n        // Crear TabPane y agregar las pesta\u00f1as\n        TabPane tabPane = new TabPane(tab1, tab2);\n\n        // Crear la escena y asignarla al Stage\n        Scene scene = new Scene(tabPane, 300, 200);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1203_Contenedores.html#javafx-splitpane","title":"JavaFX SplitPane","text":"<p>Es un contenedor que divide los controles que contiene.</p> <pre><code>import javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.SplitPane;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\npublic class SplitPaneApplication extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        primaryStage.setTitle(\"SplitPane Application\");\n\n        // Crear un SplitPane\n        SplitPane splitPane = new SplitPane();\n\n        // Crear los controles para el lado izquierdo y derecho\n        VBox leftControl = new VBox(new Label(\"Izquierda\"));\n        VBox rightControl = new VBox(new Label(\"Derecha\"));\n\n        // Agregar los controles al SplitPane\n        splitPane.getItems().addAll(leftControl, rightControl);\n\n        // Crear la escena y asignarla al Stage\n        Scene scene = new Scene(splitPane, 300, 100);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1203_Contenedores.html#hbox-y-vbox","title":"HBox y VBox","text":"<p>Los controles de dise\u00f1o de HBox y VBox proporcionan ubicaciones \u00fanicas horizontales o verticales para los nodos secundarios. Se puede anidar nodos HBox dentro de un VBox para obtener un efecto similar a una cuadr\u00edcula o anidar nodos VBox dentro de un componente HBox. Es conveniente utilizar un panel de tipo ButtonBar para colocar una fila de botones del mismo tama\u00f1o en un contenedor horizontal. </p> <p>Si usamos HBox en el dise\u00f1o de nuestra aplicaci\u00f3n, todos los nodos se establecen en una sola fila horizontal. La clase denominada HBox del paquete javafx.scene.layout representa el panel HBox. </p> <p>Si usamos VBox todos los nodos se establecen en una sola columna vertical. La clase denominada VBox del paquete javafx.scene.layout representa el panel VBox.</p> <pre><code>import javafx.application.Application;\nimport javafx.geometry.Insets;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\npublic class VBoxTest extends Application {\n    private VBox cajaVertical;\n\n    @Override\n    public void start(Stage stage) {\n        // Asignamos 10 p\u00edxeles de separaci\u00f3n entre los nodos\n        cajaVertical = new VBox(10);\n\n        // Agregamos un relleno de 15 p\u00edxeles para separarlo del borde de la ventana\n        cajaVertical.setPadding(new Insets(15));\n\n        // Llamando al m\u00e9todo addAll podemos agregar nodos en una sola l\u00ednea\n        cajaVertical.getChildren().addAll(\n            new Button(\"Bot\u00f3n 1\"),\n            new Button(\"Bot\u00f3n 2\"),\n            new Button(\"Bot\u00f3n 3\")\n        );\n\n        // Crear la escena y asignarla al Stage\n        Scene scene = new Scene(cajaVertical);\n        stage.setScene(scene);\n        stage.setTitle(\"VBox Example\");\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"uutt/ut12/1204_Controles.html","title":"Controles en JavaFX","text":"<p>JavaFX permite crear aplicaciones utilizando componentes GUI. Una aplicaci\u00f3n con una GUI realiza tres tareas: </p> <ul> <li>Acepta entradas del usuario a trav\u00e9s de dispositivos de entrada como un teclado, un rat\u00f3n, pantalla t\u00e1ctil\u2026 </li> <li>Procesa las entradas (o realiza acciones basadas en la entrada). </li> <li>Muestra salidas.</li> </ul> <p>La GUI<sup>1</sup> proporciona un medio para intercambiar informaci\u00f3n en t\u00e9rminos de entrada y salida entre una aplicaci\u00f3n y sus usuarios. Ingresar texto usando un teclado, seleccionar un elemento de men\u00fa usando un rat\u00f3n, hacer clic en un bot\u00f3n u otras acciones son ejemplos de c\u00f3mo proporcionar entrada a una aplicaci\u00f3n GUI. La aplicaci\u00f3n muestra los resultados en un monitor de computadora usando texto, gr\u00e1ficos, cuadros de di\u00e1logo, etc. </p> <p>JavaFX proporciona un amplio conjunto de controles f\u00e1ciles de usar. Los controles se agregan a los paneles de dise\u00f1o que los colocan y dimensionan. Los paneles de dise\u00f1o se discutieron en cap\u00edtulos anteriores. Ahora se describir\u00e1 c\u00f3mo usar los controles disponibles en JavaFX. </p> <p>Cada control en JavaFX est\u00e1 representado por una instancia de una clase. Las clases de control se incluyen en el paquete <code>javafx.scene.control</code>. Una clase de control es una subclase, directa o indirecta, de la clase <code>Control</code>, que a su vez hereda de la <code>Region</code>.</p>"},{"location":"uutt/ut12/1204_Controles.html#resumen-de-controles","title":"Resumen de controles","text":"<p>Hay una gran variedad, y es recomendable investigarlos, a continuaci\u00f3n se muestra un resumen.</p> Control Descripci\u00f3n Ejemplo de Uso Label Muestra texto est\u00e1tico en la interfaz. <code>Label label = new Label(\"Hola, Mundo!\");</code> Button Bot\u00f3n que puede ser presionado para realizar una acci\u00f3n. <code>Button button = new Button(\"Click Me\");</code> TextField Campo de texto para ingresar una sola l\u00ednea de texto. <code>TextField textField = new TextField();</code> TextArea Campo de texto para ingresar varias l\u00edneas de texto. <code>TextArea textArea = new TextArea();</code> CheckBox Casilla de verificaci\u00f3n para seleccionar o deseleccionar una opci\u00f3n. <code>CheckBox checkBox = new CheckBox(\"Aceptar t\u00e9rminos\");</code> RadioButton Bot\u00f3n de opci\u00f3n que pertenece a un grupo de opciones mutuamente excluyentes. <code>RadioButton radioButton = new RadioButton(\"Opci\u00f3n 1\");</code> ToggleButton Bot\u00f3n que alterna entre estados activado y desactivado. <code>ToggleButton toggleButton = new ToggleButton(\"Activar\");</code> ComboBox Men\u00fa desplegable para seleccionar un elemento de una lista. <code>ComboBox&lt;String&gt; comboBox = new ComboBox&lt;&gt;();</code> ListView Lista de elementos que se pueden seleccionar. <code>ListView&lt;String&gt; listView = new ListView&lt;&gt;();</code> TableView Tabla para mostrar datos tabulares. <code>TableView&lt;Person&gt; tableView = new TableView&lt;&gt;();</code> ProgressBar Barra de progreso para indicar el estado de una operaci\u00f3n. <code>ProgressBar progressBar = new ProgressBar(0.5);</code> Slider Control deslizante para seleccionar un valor num\u00e9rico dentro de un rango. <code>Slider slider = new Slider(0, 100, 50);</code> DatePicker Selector de fechas que permite elegir una fecha del calendario. <code>DatePicker datePicker = new DatePicker();</code> TreeView Estructura jer\u00e1rquica de elementos en forma de \u00e1rbol. <code>TreeView&lt;String&gt; treeView = new TreeView&lt;&gt;();</code> ScrollPane Contenedor con barras de desplazamiento. <code>ScrollPane scrollPane = new ScrollPane(new Label(\"Texto largo\"));</code> TabPane Contenedor con pesta\u00f1as para organizar m\u00faltiples vistas. <code>TabPane tabPane = new TabPane(new Tab(\"Pesta\u00f1a 1\"));</code>"},{"location":"uutt/ut12/1204_Controles.html#ejemplo-de-uso","title":"Ejemplo de uso","text":"<pre><code>import javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\npublic class JavaFXExample extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        Button button = new Button(\"Click Me\");\n        VBox root = new VBox(10, button);\n        Scene scene = new Scene(root, 300, 200);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"JavaFX Controls Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre> <ol> <li> <p>Interfaz Gr\u00e1fica de Usuario\u00a0\u21a9</p> </li> </ol>"},{"location":"uutt/ut12/1205_Eventos.html","title":"Eventos en JavaFX","text":"<p>Cada vez que un usuario interact\u00faa con la aplicaci\u00f3n (nodos), se dice que ha ocurrido un evento. Existe un UIThread que est\u00e1 escuchando cuando lanzamos la aplicaci\u00f3n. Cuando el usuario hace algo el UIThread que est\u00e1 escuchando, mira a ver si se lanza un evento, y si es as\u00ed, env\u00eda el evento al controlador de eventos (event handler). El Event Handler se ejecuta en el subproceso del hilo UIThread. Mientras se ejecuta un evento del UIThread el usuario no puede interactuar con la aplicaci\u00f3n. </p> <p>Por ejemplo, hacer clic en un bot\u00f3n, mover el rat\u00f3n, ingresar un car\u00e1cter a trav\u00e9s del teclado, seleccionar un elemento de la lista, desplazarse por la p\u00e1gina, etc. son ejemplos de actividades que provocan que suceda un evento. </p> <p>Un evento notifica que ha ocurrido algo importante. Los eventos suelen ser la parte \"primitiva\" de un sistema de eventos (tambi\u00e9n conocido como bus de eventos). Generalmente, un sistema de eventos tiene las siguientes 3 responsabilidades: </p> <ol> <li>Trigger an event (disparar un evento)</li> <li>Notify listeners (notificar a los oyentes partes interesadas) sobre el evento </li> <li>Handle the event (manejar o procesar el evento). </li> </ol> <p>El mecanismo de notificaci\u00f3n de eventos lo realiza la plataforma JavaFX autom\u00e1ticamente. Por lo tanto, solo consideraremos c\u00f3mo disparar eventos, escuchar eventos y c\u00f3mo manejarlos. </p>"},{"location":"uutt/ut12/1205_Eventos.html#tipos-de-eventos","title":"Tipos de eventos.","text":"<ul> <li>Eventos en primer plano (foreground events): requieren la interacci\u00f3n directa de un usuario. Se generan como consecuencia de la interacci\u00f3n de una persona con los componentes gr\u00e1ficos en una interfaz gr\u00e1fica de usuario. Por ejemplo, hacer clic en un bot\u00f3n, mover el rat\u00f3n, ingresar un car\u00e1cter a trav\u00e9s del teclado, seleccionar un elemento de la lista, desplazarse por la p\u00e1gina, etc. </li> <li>Eventos de fondo (background events): no requieren la interacci\u00f3n del usuario final. Las interrupciones del sistema operativo, fallas de hardware o software, vencimiento del temporizador, finalizaci\u00f3n de la operaci\u00f3n son ejemplos de eventos en segundo plano.</li> </ul>"},{"location":"uutt/ut12/1205_Eventos.html#algunos-eventos-en-javafx","title":"Algunos eventos en JavaFX.","text":"<p>La clase denominada Event del paquete <code>javafx.event</code> es la clase base para un evento. Una instancia de cualquiera de sus subclases es un evento. JavaFX proporciona una amplia variedad de eventos. Algunos de ellos son:</p> <ul> <li>Mouse event: evento de entrada que ocurre cuando se hace clic con el rat\u00f3n. Est\u00e1 representado por la clase denominada MouseEvent. Incluye acciones como hacer clic con el rat\u00f3n, presionarlo, soltarlo, moverlo, objetivo ingresado con el rat\u00f3n, objetivo salido del rat\u00f3n, etc. </li> <li>Key event: evento de entrada que indica que se produjo una pulsaci\u00f3n de tecla en un nodo. Est\u00e1 representado por la clase denominada KeyEvent. Este evento incluye acciones como pulsaci\u00f3n de tecla, liberaci\u00f3n de tecla y escritura de tecla. </li> <li>Drag event: evento de entrada que ocurre cuando se arrastra el rat\u00f3n. Est\u00e1 representado por la clase llamada DragEvent. Incluye acciones como arrastrar para insertar, arrastrar para soltar, etc. </li> <li>Window event: evento relacionado con las acciones de mostrar/ocultar ventanas. Est\u00e1 representado por la clase llamada WindowEvent.</li> </ul>"},{"location":"uutt/ut12/1205_Eventos.html#manejo-de-eventos","title":"Manejo de eventos.","text":"<p>El Manejo de Eventos es el mecanismo que controla el evento y decide qu\u00e9 debe suceder, si ocurre un evento. Este mecanismo tiene el c\u00f3digo conocido como controlador de eventos que se ejecuta cuando ocurre un evento. JavaFX proporciona controladores y filtros para manejar eventos. En JavaFX cada evento tiene: </p> <ul> <li>Destino (Target): el nodo en el que ocurri\u00f3 un evento. Un objetivo puede ser una ventana, una escena y un nodo.</li> <li>Fuente (Source): la fuente a partir de la cual se genera el evento ser\u00e1 la fuente del evento. En el escenario anterior, el rat\u00f3n es la fuente del evento. </li> <li>Tipo (Type): tipo de evento ocurrido; en el caso de un evento de rat\u00f3n, el tipo de evento puede ser bot\u00f3n del rat\u00f3n presionado, bot\u00f3n del rat\u00f3n soltado\u2026</li> </ul>"},{"location":"uutt/ut12/1205_Eventos.html#fases-del-manejo-de-eventos","title":"Fases del manejo de eventos.","text":""},{"location":"uutt/ut12/1205_Eventos.html#fase-de-captura-de-eventos","title":"Fase de captura de eventos","text":"<p>Despu\u00e9s de la construcci\u00f3n de la cadena de distribuci\u00f3n de eventos, el nodo ra\u00edz de la aplicaci\u00f3n distribuye el evento. Este evento viaja a todos los nodos de la cadena de distribuci\u00f3n (de arriba a abajo). Si alguno de estos nodos tiene un filtro registrado para el evento generado, se ejecutar\u00e1. Si ninguno de los nodos en la cadena de distribuci\u00f3n tiene un filtro para el evento generado, entonces se pasa al nodo de destino y finalmente el nodo de destino procesa el evento. </p> <p>En el ejemplo anterior, si hacemos clic en bot\u00f3n de play, la ruta que se seguir\u00eda en esta fase ser\u00eda: </p> <p>Stage\u2192Scene\u2192Group\u2192Play Button </p>"},{"location":"uutt/ut12/1205_Eventos.html#fase-de-burbujeo-del-evento","title":"Fase de burbujeo del evento","text":"<p>En la fase de burbujeo de eventos, el evento viaja desde el nodo de destino al nodo de etapa (de abajo hacia arriba). Si alguno de los nodos de la cadena de distribuci\u00f3n de eventos tiene un controlador registrado para el evento generado, se ejecutar\u00e1. Si ninguno de estos nodos tiene manejadores para manejar el evento, entonces el evento llega al nodo ra\u00edz y finalmente se completar\u00e1 el proceso. </p> <p>En el ejemplo anterior, si hacemos clic en bot\u00f3n de play, la ruta que se seguir\u00eda en esta fase ser\u00eda: </p> <p>Play Button\u2192Group\u2192Scene\u2192Stage </p>"},{"location":"uutt/ut12/1205_Eventos.html#controladores-y-filtros-de-eventos","title":"Controladores y filtros de eventos","text":"<p>Los filtros y controladores de eventos son aquellos que contienen l\u00f3gica de aplicaci\u00f3n para procesar un evento. Un nodo puede registrarse en m\u00e1s de un controlador/filtro. En el caso de los nodos padre-hijo, se puede proporcionar un filtro/controlador com\u00fan a los padres, que se procesa de forma predeterminada para todos los nodos secundarios.</p> <p>Los filtros de eventos se llaman antes que los controladores de eventos. Como se mencion\u00f3 anteriormente, durante el evento, el procesamiento es un filtro que se ejecuta y durante la fase de propagaci\u00f3n del evento, se ejecuta un controlador. Todos los manejadores y filtros implementan la interfaz EventHandler del paquete javafx.event. </p> <p>Crear filtros y controladores de eventos es tan simple como crear objetos de la clase que implementan la interfaz EventHandler. Antes de Java 8, usaba clases internas para crear controladores y filtros de eventos, como en el siguiente c\u00f3digo:</p> <pre><code>EventHandler&lt;MouseEvent&gt; aHandler = new EventHandler&lt;MouseEvent&gt;() {\n    @Override\n    public void handle(MouseEvent e) {\n        // Aqu\u00ed metemos el c\u00f3digo que queremos ejecutar en respuesta al evento\n    }\n};\n</code></pre> <p>A partir de Java 8, el uso de expresiones lambda es la mejor opci\u00f3n para crear los filtros y controladores de eventos, como en el siguiente c\u00f3digo:</p> <pre><code>EventHandler&lt;MouseEvent&gt; aHandler = e -&gt; {\n    // El c\u00f3digo de manejo del evento va aqu\u00ed\n};\n</code></pre>"},{"location":"uutt/ut12/1205_Eventos.html#creacion-y-registro-de-un-eventfilter","title":"Creaci\u00f3n y registro de un EventFilter.","text":"<p>En el siguiente ejemplo se crea un EventFilter que se activar\u00e1 cuando se haga clic en un bot\u00f3n. Cuando se active el filtro se llamar\u00e1 al manejador de eventos llamado handler. Este manejador de eventos imprimir\u00e1 un mensaje por pantalla y cambiar\u00e1 el color del bot\u00f3n. Para este ejemplo se utiliza la sintaxis \u201ccl\u00e1sica\u201d previa al uso de expresiones lambda.</p> <pre><code>// Creaci\u00f3n de un manejador de evento\nEventHandler&lt;MouseEvent&gt; handler = new EventHandler&lt;MouseEvent&gt;() {\n    @Override\n    public void handle(MouseEvent e) {\n        System.out.println(\"Hello World\");\n        boton.setFill(Color.DARKSLATEBLUE);\n    }\n};\n\n// Creaci\u00f3n de un EventFilter\nboton.addEventFilter(MouseEvent.MOUSE_CLICKED, handler);\n</code></pre> <p>El siguiente c\u00f3digo muestra el mismo ejemplo, pero gestionando el evento mediante un EventHandler, en vez de un EventFilter. En este ejemplo se utiliza una expresi\u00f3n lambda para escribir el c\u00f3digo del manejador</p> <pre><code>// Creaci\u00f3n de un manejador de evento\nEventHandler&lt;MouseEvent&gt; handler = e -&gt; {\n    System.out.println(\"Hello World\");\n    boton.setFill(Color.DARKSLATEBLUE);\n};\n\n// Creaci\u00f3n de un EventHandler\nboton.addEventHandler(MouseEvent.MOUSE_CLICKED, handler);\n</code></pre>"},{"location":"uutt/ut12/1205_Eventos.html#eventos-de-raton","title":"Eventos de rat\u00f3n.","text":"<p>Un evento de rat\u00f3n est\u00e1 representado por la clase MouseEvent. </p> <ul> <li><code>ANY</code>: Es el supertipo de todos los tipos de eventos de rat\u00f3n. Si un nodo desea recibir todos los tipos de eventos de rat\u00f3n, debe registrar controladores para este tipo. <code>InputEvent.ANY</code> es el supertipo de este tipo de evento. </li> <li><code>MOUSE_PRESSED</code>: presionar un bot\u00f3n del rat\u00f3n genera este evento. El m\u00e9todo getButton() de la clase MouseEvent devuelve el bot\u00f3n del mouse que es responsable del evento. Un bot\u00f3n del rat\u00f3n est\u00e1 representado por las constantes <code>NONE</code>, <code>PRIMARY</code>, <code>MIDDLE</code> y <code>SECONDARY</code> definidas en la enumeraci\u00f3n MouseButton. </li> <li><code>MOUSE_RELEASED</code>: Soltar un bot\u00f3n del rat\u00f3n genera este evento. Este evento se env\u00eda al mismo nodo en el que se presion\u00f3 el rat\u00f3n. Por ejemplo, puede presionar un bot\u00f3n del rat\u00f3n en un c\u00edrculo, arrastrar el rat\u00f3n fuera del c\u00edrculo y soltar el bot\u00f3n del rat\u00f3n. El evento <code>MOUSE_RELEASED</code> se enviar\u00e1 al c\u00edrculo, no al nodo en el que se solt\u00f3 el bot\u00f3n del rat\u00f3n. </li> <li><code>MOUSE_CLICKED</code>: este evento se genera cuando se hace clic con un bot\u00f3n del rat\u00f3n en un nodo. El bot\u00f3n debe presionarse y soltarse en el mismo nodo para que ocurra este evento. </li> <li><code>MOUSE_MOVED</code>: Mover el rat\u00f3n sin presionar ning\u00fan bot\u00f3n genera este evento. </li> <li><code>MOUSE_ENTERED</code>: Este evento se genera cuando el rat\u00f3n ingresa a un nodo. La captura de eventos y las fases de propagaci\u00f3n no tienen lugar para este evento. Es decir, los filtros de eventos y los controladores de los nodos principales del destino del evento de este evento no son llamados. </li> <li><code>MOUSE_ENTERED_TARGET</code>: Este evento se genera cuando el rat\u00f3n ingresa a un nodo. Es una variante del tipo de evento <code>MOUSE_ENTERED</code>. A diferencia del evento <code>MOUSE_ENTERED</code>, la captura de eventos y las fases de propagaci\u00f3n tienen lugar para este evento. </li> <li><code>MOUSE_EXITED_TARGET</code>: este evento se genera cuando el rat\u00f3n sale de un nodo. Es una variante del tipo de evento <code>MOUSE_EXITED</code>. A diferencia del evento <code>MOUSE_EXITED</code>, la captura de eventos y las fases de propagaci\u00f3n tienen lugar para este evento. </li> <li><code>DRAG_DETECTED</code>: este evento se genera cuando se presiona el rat\u00f3n y se arrastra sobre un nodo sobre un umbral de distancia espec\u00edfico.</li> <li><code>MOUSE_DRAGGED</code>: Mover el rat\u00f3n con un bot\u00f3n presionado genera este evento. Este evento se env\u00eda al mismo nodo en el que se presion\u00f3 el bot\u00f3n del rat\u00f3n, independientemente de la ubicaci\u00f3n del puntero del rat\u00f3n durante el arrastre.</li> </ul>"},{"location":"uutt/ut12/1205_Eventos.html#eventos-de-teclado","title":"Eventos de teclado.","text":"<p>Un evento de rat\u00f3n est\u00e1 representado por la clase KeyEvent. A continuaci\u00f3n, se enumeran todas las constantes de la clase KeyEvent, que representan tipos de eventos de teclado: </p> <ul> <li><code>ANY</code> es el supertipo de todos. </li> <li><code>KEY_PRESSED</code> ocurre cuando se presiona una Tecla. </li> <li><code>KEY_RELEASED</code> cuando la Tecla es soltada. </li> <li><code>KEY_TYPED</code> cuando se teclea un car\u00e1cter Unicode. </li> </ul> <p>El m\u00e9todo <code>getCode()</code> devuelve una constante de enumeraci\u00f3n KeyCode que est\u00e1 asociada con la tecla que se presiona o suelta. Es v\u00e1lido para los eventos <code>KEY_PRESSED</code> y <code>KEY_RELEASED</code>. Para el evento <code>KEY_TYPED</code> se puede utilizar el m\u00e9todo <code>getCharacter()</code> que devuelve un String con la representaci\u00f3n de las teclas pulsadas.</p>"},{"location":"uutt/ut12/1205_Eventos.html#eventos-de-ventana","title":"Eventos de ventana.","text":"<p>Un evento de ventana ocurre cuando una ventana se muestra, oculta o cierra. Una instancia de la clase WindowEvent en el paquete <code>javafx.stage</code> representa un evento de ventana. Las constantes de la clase WindowEvent son: </p> <ul> <li><code>ANY</code> es el supertipo de todos los eventos de ventana. </li> <li><code>WINDOW_SHOWING</code> ocurre justo antes de que se muestre la ventana. </li> <li><code>WINDOW_SHOWN</code> ocurre justo despu\u00e9s de que se muestre la ventana. </li> <li><code>WINDOW_HIDING</code> ocurre justo antes de que se oculte la Ventana. </li> <li><code>WINDOW_HIDDEN</code> ocurre justo despu\u00e9s de que se oculte la Ventana. </li> <li><code>WINDOW_CLOSE_REQUEST</code> Se produce cuando hay una solicitud externa para cerrar esta ventana.</li> </ul>"},{"location":"uutt/ut12/1205_Eventos.html#eventos-mediante-metodos-de-conveniencia","title":"Eventos mediante m\u00e9todos de conveniencia.","text":"<p>Existe la posibilidad de registrar controladores (no de filtros) de algunos eventos espec\u00edficos mediante el uso de m\u00e9todos de conveniencia. Estos m\u00e9todos tienen el nombre <code>setOnXXX()</code>, donde XXX hace referencia al evento concreto. </p> <p>Por ejemplo, el m\u00e9todo <code>setOnMouseClicked()</code> registra un controlador de eventos para el evento en el que se hace clic con el rat\u00f3n, mientras que el m\u00e9todo <code>setOnKeyTyped()</code> lo hace para un evento de tipo <code>key</code> (teclado).</p> <pre><code>// Registra un controlador de evento para un evento de clic del rat\u00f3n. \nbotonx.setOnMouseClicked(handler);\n</code></pre>"},{"location":"uutt/ut12/1205_Eventos.html#resumen-de-eventos","title":"Resumen de eventos","text":"<p>Hay una gran variedad, y es recomendable investigarlos, a continuaci\u00f3n se muestra un resumen.</p> Evento Descripci\u00f3n Ejemplo de Uso <code>ActionEvent</code> Ocurre cuando se realiza una acci\u00f3n en un control (ej. bot\u00f3n). <code>button.setOnAction(e -&gt; System.out.println(\"Bot\u00f3n presionado!\"));</code> <code>MouseEvent</code> Se activa cuando ocurre un evento del rat\u00f3n (clic, mover). <code>node.setOnMouseClicked(e -&gt; System.out.println(\"Clic detectado!\"));</code> <code>KeyEvent</code> Se produce cuando se presiona, suelta o escribe una tecla. <code>scene.setOnKeyPressed(e -&gt; System.out.println(\"Tecla presionada: \" + e.getCode()));</code> <code>ScrollEvent</code> Generado cuando se usa la rueda de desplazamiento del rat\u00f3n. <code>node.setOnScroll(e -&gt; System.out.println(\"Scroll detectado!\"));</code> <code>DragEvent</code> Ocurre durante operaciones de arrastrar y soltar. <code>node.setOnDragDropped(e -&gt; System.out.println(\"Elemento soltado!\"));</code> <code>FocusEvent</code> Se genera cuando un nodo gana o pierde el foco. <code>textField.focusedProperty().addListener((obs, oldVal, newVal) -&gt; System.out.println(\"Foco cambiado!\"));</code> <code>TouchEvent</code> Detecta toques en dispositivos t\u00e1ctiles. <code>node.setOnTouchPressed(e -&gt; System.out.println(\"Pantalla t\u00e1ctil presionada!\"));</code> <code>ContextMenuEvent</code> Generado al abrir un men\u00fa contextual (bot\u00f3n derecho). <code>node.setOnContextMenuRequested(e -&gt; System.out.println(\"Men\u00fa contextual solicitado!\"));</code> <code>WindowEvent</code> Ocurre durante eventos de la ventana (abrir, cerrar, enfocar). <code>stage.setOnCloseRequest(e -&gt; System.out.println(\"Ventana cerr\u00e1ndose!\"));</code> <code>InputEvent</code> Clase base para eventos de entrada (rat\u00f3n, teclado, etc.). <code>node.addEventFilter(InputEvent.ANY, e -&gt; System.out.println(\"Evento de entrada detectado!\"));</code> <code>ChangeEvent</code> Indica cambios en un estado observable. <code>slider.valueProperty().addListener((obs, oldVal, newVal) -&gt; System.out.println(\"Valor cambiado: \" + newVal));</code>"},{"location":"uutt/ut12/1206_AplicandoMVC.html","title":"Aplicando MVC","text":"<p>Para trabajar con el modelo vista controlador, vamos a crear los siguientes elementos:</p> <ul> <li> <p>Para la clase controlador creamos un atributo que sea del tipo clase vista.</p> <pre><code>public class CartasController { // Clase controlador\n    private CartasApplication app;\n    public CartasController(CartasApplication app) {\n        this.app = app;\n    }\n}\n</code></pre> </li> <li> <p>Para la clase vista, cread un objeto de clase controlador y le pas\u00e1is un <code>this</code> al constructor.</p> <p><pre><code>public class CartasApplication extends Application { // Clase vista\n    CartasController cont = new CartasController(this);\n    protected TextArea areaTexto = new TextArea();\n    protected Button boton = new Button();\n}\n</code></pre> De esta forma, est\u00e1is pas\u00e1ndole la vista al controlador. Es una forma de relacionarlos de forma cruzada. Ahora, si yo invoco al objeto app en la clase controlador, puedo acceder a todos los m\u00e9todos y atributos de la clase vista.</p> </li> </ul> <p>Si se quiere una visi\u00f3n global del proyecto, se podr\u00eda iniciar con los siguientes ficheros:</p> <p><pre><code>public class CartasController { // Clase controlador\n    private CartasApplication app;\n\n    public CartasController(CartasApplication app) {\n        this.app = app;\n    }\n    EventHandler&lt;MouseEvent&gt; eventoPrueba = e -&gt; {\n        app.areaTexto.setText(\"Pongo texto desde controlador\");\n    };\n}\n</code></pre> <pre><code>public class CartasApplication extends Application { // Clase vista\n    CartasController cont = new CartasController(this);\n    protected TextArea areaTexto = new TextArea();\n    protected Button boton = new Button();\n\n    public static void main(String[] args) {\n        launch();\n    }\n\n    @Override\n    public void start(Stage stage) {\n    }\n}\n</code></pre> Si yo quiero ahora, desde la clase vista, asignar un evento (definido en controlador) a un bot\u00f3n, implementar\u00eda:</p> <p><pre><code>public class CartasController { // Clase controlador\n    private CartasApplication app;\n\n    public CartasController(CartasApplication app) {\n        this.app = app;\n    }\n\n    public void ponerTexto() {\n        app.areaTexto.setText(\"Pongo texto desde controlador\");\n    }\n    EventHandler&lt;MouseEvent&gt; eventoPrueba = e -&gt; {\n        // Eventos para el bot\u00f3n\n    };\n}\n</code></pre> <pre><code>public class CartasApplication extends Application { // Clase vista\n    CartasController cont = new CartasController(this);\n    protected TextArea areaTexto = new TextArea();\n    protected Button boton = new Button();\n\n    public static void main(String[] args) {\n        launch();\n    }\n    @Override\n    public void start(Stage stage) {\n        cont.ponerTexto(); // Ponemos texto a un text area desde el controlador\n        // Ahora asignamos un evento\n        boton.addEventHandler(MouseEvent.MOUSE_CLICKED, cont.eventoPrueba);\n    }\n}\n</code></pre> Esto es una forma de trabajar de forma  que se respete los principios del MVC sin mezclar clases.</p>"},{"location":"uutt/ut12/ResumenUT.html","title":"Propuesta did\u00e1ctica UT 12","text":""},{"location":"uutt/ut12/ResumenUT.html#resultado-de-aprendizaje","title":"Resultado de aprendizaje","text":"RA.CE"},{"location":"uutt/ut12/ResumenUT.html#contenidos","title":"Contenidos","text":"<p>La presente UT tratar\u00e1 los siguientes contenidos:</p>"},{"location":"uutt/ut12/ResumenUT.html#programacion-de-aula","title":"Programaci\u00f3n de aula","text":"<p>Sesi\u00f3n</p> <p>Fecha</p> <p>Conceptos</p> <p>Actividades</p> <p>01</p> <p>14/04/2025</p> <p></p> <p></p> <p>02</p> <p>14/04/2025</p> <p></p> <p></p> <p>03</p> <p>15/04/2025</p> <p></p> <p></p> <p>04</p> <p>29/04/2025</p> <p></p> <p></p> <p>05</p> <p>30/04/2025</p> <p></p> <p></p> <p>06</p> <p>30/04/2025</p> <p></p> <p></p> <p>07</p> <p>02/05/2025</p> <p></p> <p></p> <p>08</p> <p>05/05/2025</p> <p></p> <p></p> <p>09</p> <p>05/05/2025</p> <p></p> <p></p> <p>10</p> <p>06/05/2025</p> <p></p> <p></p> <p>11</p> <p>07/05/2025</p> <p></p> <p></p> <p>12</p> <p>07/05/2025</p> <p></p> <p></p> <p>13</p> <p>08/05/2025</p> <p></p> <p></p> <p>14</p> <p>08/05/2025</p> <p></p> <p></p> <p>15</p> <p>09/05/2025</p> <p></p> <p></p> <p>16</p> <p>12/05/2025</p> <p></p> <p></p> <p>17</p> <p>12/05/2025</p> <p></p> <p></p> <p>18</p> <p>13/05/2025</p> <p></p> <p></p> <p>19</p> <p>14/05/2025</p> <p></p> <p></p> <p>20</p> <p>14/05/2025</p> <p></p> <p></p> <p>21</p> <p>15/05/2025</p> <p></p> <p></p> <p>22</p> <p>15/05/2025</p> <p></p> <p></p> <p>23</p> <p>16/05/2025</p> <p></p> <p></p> <p>24</p> <p>19/05/2025</p> <p></p> <p></p>"},{"location":"uutt/ut12/ResumenUT.html#referencias","title":"Referencias","text":"<ul> <li>Web: JavaFX</li> <li>Web: JavaFX Documentaci\u00f3n oficial</li> </ul>"},{"location":"uutt/ut12/ResumenUT.html#links-de-interes","title":"Links de inter\u00e9s","text":"<ul> <li>Web: JavaFX Tutorial</li> <li>Web: JavaFX en IntelliJ</li> <li>Web: Introducci\u00f3n a Java FX</li> <li>V\u00eddeo: JavaFX GUI Full Course for free</li> <li>V\u00eddeo: CURSO PR\u00c1CTICO JAVAFX </li> </ul>"}]}